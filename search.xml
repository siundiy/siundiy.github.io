<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>积性函数线性筛</title>
      <link href="/2019/08/19/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
      <url>/2019/08/19/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有关积性函数的相关性质，请参考<a href="/2019/08/09/莫比乌斯反演/">莫比乌斯反演</a>。<br><br>与线性筛关系最大的便是以下性质：</p><blockquote><p>$gcd(a,b)=1$时，满足$f(ab)=f(a)f(b)$<br><a id="more"></a></p></blockquote><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p>首先明确一点，所有的线性筛出积性函数的方法都是通过线性筛素数实现的。</p><h2 id="如何筛素数？"><a href="#如何筛素数？" class="headerlink" title="如何筛素数？"></a>如何筛素数？</h2><h3 id="朴素筛法（复杂度-O-n-2-O-n-sqrt-n-）"><a href="#朴素筛法（复杂度-O-n-2-O-n-sqrt-n-）" class="headerlink" title="朴素筛法（复杂度$O(n^2)$~$O(n\sqrt {n})$）"></a>朴素筛法（复杂度$O(n^2)$~$O(n\sqrt {n})$）</h3><p>枚举每一个数和它的因子，如果只有1与它本身是它的因子，那么它就是质数。<br><br>因为所有$&gt;\sqrt{n}$的因子都可以被小于$\sqrt{n}$的因子表示，所以可以只枚举到$\sqrt{n}$，但是复杂度还是不够优秀。</p><h3 id="埃氏筛（复杂度-O-nloglogn-）"><a href="#埃氏筛（复杂度-O-nloglogn-）" class="headerlink" title="埃氏筛（复杂度$O(nloglogn)$）"></a>埃氏筛（复杂度$O(nloglogn)$）</h3><p>思想就是从枚举因子转化为枚举倍数。<br><br>很明显质数的倍数都不是质数，所以对于每个质数，枚举其倍数，并将其标记成非质数。<br><br>很明显这样做的话会使得一些数被筛去好几次，比如6会被2和3筛去，造成了时间上的浪费。<br><br>虽然这种筛法在实际应用上有更好的代替，但是其将枚举因子转化为枚举倍数的思想却能够优化解决很多问题。</p><h3 id="欧拉筛（复杂度-O-n-）"><a href="#欧拉筛（复杂度-O-n-）" class="headerlink" title="欧拉筛（复杂度$O(n)$）"></a>欧拉筛（复杂度$O(n)$）</h3><p>为了解决埃氏筛反复筛去一个数多次的问题，我们规定，每一个数只能被其最小的质因子删去。<br><br>通过代码进行进一步讲解<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(i, j, k) for(register int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">40010</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn], tot;</span><br><span class="line"><span class="keyword">char</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">innt</span><span class="params">()</span></span>&#123;</span><br><span class="line">vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">fr(i, <span class="number">2</span>, maxn - <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i])prime[++tot] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= maxn; ++j)&#123;</span><br><span class="line">vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//关键点！！！！！！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码中有一句：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><p>正是这句话保证了每个数只会被其最小的质因子删去。</p><h2 id="线性筛欧拉函数"><a href="#线性筛欧拉函数" class="headerlink" title="线性筛欧拉函数"></a>线性筛欧拉函数</h2><h3 id="欧拉函数定义"><a href="#欧拉函数定义" class="headerlink" title="欧拉函数定义"></a>欧拉函数定义</h3><p>欧拉函数是指小于x的整数中与x互质的数的个数，用$\varphi$表示，特殊的：$\varphi(1)=1$。</p><h3 id="欧拉函数性质"><a href="#欧拉函数性质" class="headerlink" title="欧拉函数性质"></a>欧拉函数性质</h3><p>1.对于质数$p$, $\varphi(p)=p-1$</p><blockquote><p>根据定义显然</p></blockquote><p>2.对于质数$p$,<br><br>若$p$是$x$的约数，则$\varphi(x<em>p)=\varphi(x)</em>p$。<br><br>若p不是x的约数，则$\varphi(x<em>p)=\varphi(x)</em>\varphi(p)=\varphi(x)*(p-1)$。<br><br>证明：</p><blockquote><p>1.若$x\%p==0$则$i<em>p$的最小素因子的个数多了1，其余无变化<br><br>2.若$x\%p!=0$，因为$\varphi$s是积性函数，所以当$x$与$p$互质时$\varphi(x</em>p)=\varphi(x)*\varphi(p)$。</p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(i, j, k) for(register int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">40010</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn], phi[maxn], tot;</span><br><span class="line"><span class="keyword">char</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">innt</span><span class="params">()</span></span>&#123;</span><br><span class="line">vis[<span class="number">1</span>] = <span class="number">1</span>, phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">fr(i, <span class="number">2</span>, maxn)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i])&#123;prime[++tot] = i;phi[i] = i - <span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= maxn; ++j)&#123;</span><br><span class="line">vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i % prime[j])&#123;</span><br><span class="line">phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">phi[i*prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性筛莫比乌斯函数"><a href="#线性筛莫比乌斯函数" class="headerlink" title="线性筛莫比乌斯函数"></a>线性筛莫比乌斯函数</h2><h3 id="莫比乌斯函数定义及性质"><a href="#莫比乌斯函数定义及性质" class="headerlink" title="莫比乌斯函数定义及性质"></a>莫比乌斯函数定义及性质</h3><p>请参考<a href="/2019/08/09/莫比乌斯反演/">莫比乌斯反演</a>。<br></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(i, j, k) for(register int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">40010</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn], mu[maxn], tot;</span><br><span class="line"><span class="keyword">char</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">innt</span><span class="params">()</span></span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">fr(i, <span class="number">2</span>, maxn)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i])prime[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>, w; j &lt;= cnt &amp;&amp; (w = (i * prime[j])) &lt;= maxn; ++j)&#123;</span><br><span class="line">vis[w] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!(i % prime[j]))&#123;mu[w] = <span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">else</span> mu[w]=-mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫比乌斯反演</title>
      <link href="/2019/08/09/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
      <url>/2019/08/09/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><del>这种神仙玩意儿一听就非常高端。</del>但是如果认真学习的话，还是比想象中的要简单的。<br><br><del>话说本来想拿去装13的却被初三小朋友痛斥过于娱乐…</del><br><a id="more"></a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>感谢：</p><blockquote><p><a href="https://panda2134.tk/%E7%AC%94%E8%AE%B0/2018/03/12/MobiusInversion/" target="_blank" rel="noopener">莫比乌斯反演学习笔记——by Panda2134</a><br><br><a href="https://dimensiontripper.github.io/2018/10/29/Mobius_Inversion/" target="_blank" rel="noopener">莫比乌斯反演学习笔记——by DimensionTripper</a><br><br><del>各种能百度到的资料</del></p></blockquote><h1 id="前置1：数论、积性函数"><a href="#前置1：数论、积性函数" class="headerlink" title="前置1：数论、积性函数"></a>前置1：数论、积性函数</h1><h2 id="什么叫数论函数？"><a href="#什么叫数论函数？" class="headerlink" title="什么叫数论函数？"></a>什么叫数论函数？</h2><blockquote><p>在数论上，算术函数（或称数论函数）指定义域为正整数、陪域为复数的函数<br><br>——来自百度百科</p></blockquote><p><del>无法识别的表达方式…</del><br><br>换句话说，数论函数就相当于<strong>定义域为$N^+$的函数</strong>。<br><br><strong>注1：</strong>陪域就相当于可以包含值域所有的集合。<br></p><p><fancybox><br><img src="https://s2.ax1x.com/2019/08/09/eqRVVs.png" alt="eqRVVs.png"></fancybox><br>如图，如果A是$f(x)$的值域，那么B与C都可以是$f(x)$的陪域。<br><br><strong>注2：</strong>复数是指形如$z=a+bi$的数…为全部实数与虚数的集合。</p><h2 id="什么叫积性函数？"><a href="#什么叫积性函数？" class="headerlink" title="什么叫积性函数？"></a>什么叫积性函数？</h2><p>指当$gcd(a,b)=1$时满足$f(ab)=f(a)f(b)$的数论函数。<br><br>还有一种更加特殊的情况，即d对于任意$a,b \in Z$时都满足$f(ab)=f(a)f(b)$的函数，被称为完全积性函数。<br><br>由于完全积性函数相较于积性函数并没有什么更加<del>可爱</del>的性质，故下文仅对积性函数进行讨论。</p><h2 id="有哪些常见的积性函数？"><a href="#有哪些常见的积性函数？" class="headerlink" title="有哪些常见的积性函数？"></a>有哪些常见的积性函数？</h2><blockquote><p>$\mu(n)$：<strong>本文主角，莫比乌斯函数。</strong><br></p><script type="math/tex; mode=display">\mu(n)=\begin{cases}\text{1}&&\text{(n==1)}\\\text{$(-1)^k$}&&\text{(当$n=p_1*p_2*...*p_k$时)}\\\text{0}&&\text{(当n存在平方因子时)}\\\end{cases}</script><p>$1(n)$：<strong>不变的函数，恒定值为1</strong><br><br>$\epsilon(n)$：<strong>单位元，当且仅当$n=1$时$\epsilon(n)=1$，其他情况$\epsilon(n)=0$，即</strong></p><script type="math/tex; mode=display">\epsilon(n)=\begin{cases}\text{1}&&\text{(n==1)}\\\text{0}&&\text{otherwise}\end{cases}</script><p>$id(n)$：<strong>就是$n$的大小，即$id[n]=n$</strong> <br><br>$\varphi(n)$：欧拉函数，指小于$n$的正整数中与$n$互质数的数目。<br><br>$gcd(n,k)$：当$k$固定时，$n$的最大公因子。<br><br>$d(n)$：$n$的正因子数目<br><br>$σ(n)$：$n$的所有正因子之和<br></p></blockquote><p>其中加粗的函数与莫比乌斯反演有比较重要的关系。</p><h2 id="积性函数的性质"><a href="#积性函数的性质" class="headerlink" title="积性函数的性质"></a>积性函数的性质</h2><p>1.对于任意积性函数$f$，$f(1)=1$。<br></p><blockquote><p>显然，$f(n)=f(n)f(1)\rightarrow f(1)=1$</p></blockquote><p>2.对于一个大于1的正整数$N$，设$N=\prod p_i ^ {a_i}$且$\forall p_i \not= p_j$（就是将$N$质因数分解，则对于一个积性函数$f$：</p><script type="math/tex; mode=display">    f(n)=f(\prod p_i ^ {a_i})=\prod f(p_i ^ {a_i})</script><blockquote><p>根据定义显然。</p></blockquote><h1 id="前置2：狄利克雷卷积"><a href="#前置2：狄利克雷卷积" class="headerlink" title="前置2：狄利克雷卷积"></a>前置2：狄利克雷卷积</h1><p><del>又是一个听起来非常高端的玩意儿…</del><br><br>设$f(n), g(n), h(n)$为数论函数，且</p><script type="math/tex; mode=display">h(n)=f(n)*g(n)</script><p>，则</p><script type="math/tex; mode=display">h(n)=\sum_{d|n}f(d)g(\frac{n}{d})</script><h2 id="几条性质"><a href="#几条性质" class="headerlink" title="几条性质"></a>几条性质</h2><p>1.交换律：<script type="math/tex">{(f*g)(n)=(g*f)(n)}</script>；<br><br>2.结合律：<script type="math/tex">((f*g)*h)(n)=(f*(g*h))(n)</script>；<br><br>3.分配律：定义两个数论函数<script type="math/tex">f(n),g(n)</script>的加法为逐项相加，即<script type="math/tex">(f+g)(n)=f(n)+g(n)</script>，那么<script type="math/tex">(f+g)*h=f*h+g*h</script>；<br><br>4.积性函数<script type="math/tex">*</script>积性函数<script type="math/tex">=</script>积性函数，即当<script type="math/tex">f(n),g(n)</script>为积性函数时，<script type="math/tex">h(n)=f(n)*g(n)</script>也为积性函数。<br><br>证明：</p><blockquote><p>设：$n=a*b$，且$gcd(a,b)=1$，则</p><script type="math/tex; mode=display">\begin{split}h(n)&&=\sum_{d|n}f(d)g(\frac{n}{d})\\&&=\sum_{d1|a}\sum_{d2|b}f(d1d2)g(\frac{a}{d1}\frac{b}{d2})\\&&=\sum_{d1|a}\sum_{d2|b}f(d1)f(d2)g(\frac{a}{d1})g(\frac{b}{d2})\\&&=\sum_{d1|a}f(d1)g(\frac{a}{d1})\sum_{d2|b}f(d2)g(\frac{b}{d2})\\&&=h(a)*h(b)\\\end{split}</script></blockquote><p>5.$(f*e)=f$ <br><br>证明：</p><blockquote><script type="math/tex; mode=display">\begin{split}(f*e)(n)&&=e*f(n)\\&&=\sum_{d|n}e(d)*f(\frac{n}{d})\\&&=f(n)\\\end{split}</script></blockquote><p><strong>注：</strong>非积性函数亦可卷积。</p><h1 id="前置3：莫比乌斯函数"><a href="#前置3：莫比乌斯函数" class="headerlink" title="前置3：莫比乌斯函数"></a>前置3：莫比乌斯函数</h1><h2 id="几条性质-1"><a href="#几条性质-1" class="headerlink" title="几条性质"></a>几条性质</h2><p>1.$\mu(n)$是积性函数<br><br>证明：</p><blockquote><p>因为</p><script type="math/tex; mode=display">\begin{split}\begin{cases}\mu(p_i^{a_i})=-1&&(a_i==-1)\\\mu(p_i^{a_i})=0&&(a_i\ge 2)\\\end{cases}\end{split}</script><p>所以</p><script type="math/tex; mode=display">\mu(n)=\prod p_i^{a_i}</script><p>由积性函数性质2得：$\mu$是积性函数。<br></p></blockquote><p>2.$\mu*1=\epsilon$ <br><br>证明：</p><blockquote><p>因为$\mu$、$1$、$\epsilon$均为积性函数<br><br>所以原命题转化为证明：</p><script type="math/tex; mode=display">(\mu * 1)(p^k)=\epsilon(p^k)</script><p>其中</p><script type="math/tex; mode=display">(\mu * 1)(p^k)=\sum_{j=0}^{k} \mu(p^j)1(p^{k-j})</script><p>而</p><script type="math/tex; mode=display">\begin{split}\mu(p^j)=\begin{cases}1 &&(j==0)\\-1 &&(j==1)\\0 &&(j\ge 2)\\\end{cases}\end{split}</script><p>所以</p><script type="math/tex; mode=display">\begin{split}\sum_{j=0}^{k} \mu(p^j)1(p^{k-j})=\begin{cases}1-1+0+0+0...&&(k>0)\\1&&(k==0)\end{cases}\end{split}</script><p>即原命题成立</p></blockquote><p>该命题还有另一种表达方式：</p><script type="math/tex; mode=display">\sum_{d|n} \mu(d)=[n==1]</script><p>因为：</p><script type="math/tex; mode=display">\sum_{d|n}\mu(d)=\sum_{d|n}\mu(d)*1=(\mu*1)(n)=\epsilon(n)</script><p><strong>注：</strong>其中$[$ &nbsp; $]$ 表示<strong>艾佛森括号</strong>，方括号其中的条件满足则为1，不满足则为0，即：</p><script type="math/tex; mode=display">\begin{aligned}\\[P]&=1 &\text{(If P is true)}\\[P]&=0 &\text{(Otherwise)}\end{aligned}</script><h1 id="正题：莫比乌斯反演"><a href="#正题：莫比乌斯反演" class="headerlink" title="正题：莫比乌斯反演"></a>正题：莫比乌斯反演</h1><p><strong>形式一：</strong>已知$f(x),g(x)$为两个数论函数，如果</p><script type="math/tex; mode=display">f(n)=\sum_{d|n}g(d)</script><p>则</p><script type="math/tex; mode=display">g(n)=\sum_{d|n}f(d)*\mu(\frac{n}{d})</script><p>证明1：（狄利克雷卷积法）</p><blockquote><p>已知</p><script type="math/tex; mode=display">f(n)=\sum_{d|n}g(d)</script><p>改写成卷积的形式</p><script type="math/tex; mode=display">f(n)=g(n)*1</script><p>等式两侧同时$*\mu$</p><script type="math/tex; mode=display">f*\mu=g*1*\mu</script><p>由莫比乌斯函数性质知：$\mu*1=\epsilon$，<br>即</p><script type="math/tex; mode=display">f*\mu=g*\epsilon=g</script><p>根据狄利克雷卷积展开，则</p><script type="math/tex; mode=display">g(n)=\sum_{d|n}f(d)*g(\frac{n}{d})</script></blockquote><p>证明2：(定义法)</p><blockquote><p>由$f(n)$的定义知：</p><script type="math/tex; mode=display">\begin{aligned}\sum_{d|n}\mu(d)f(\frac{n}{d})=&\sum_{d|n}\mu(d)\sum_{i|\frac{n}{d}}g(i)\\=&\sum_{d|n}\sum_{i|\frac{n}{d}}\mu(d)g(i)\\=&\sum_{i|n}\sum_{d|\frac{n}{i}}\mu(d)g(i)\\=&\sum_{i|n}g(i)\sum_{d|\frac{n}{i}}\mu(d)\\\end{aligned}</script><p>根据莫比乌斯函数的性质：当且仅当$\frac{n}{i}==1$时，<br>$\sum_{d|\frac{n}{i}}\mu(d)=1$，所以：</p><script type="math/tex; mode=display">\sum_{i|n}g(i)\sum_{d|\frac{n}{i}}\mu(d)=g(n)</script></blockquote><p><strong>形式二：</strong><br>如果</p><script type="math/tex; mode=display">g(n)=\sum_{n|d}f(d)</script><p>那么</p><script type="math/tex; mode=display">f(n)=\sum_{n|d}\mu(\frac{d}{n})g(d)</script><p>证明：</p><blockquote><script type="math/tex; mode=display">\begin{aligned}\sum_{n|d}\mu(\frac{d}{n})g(d)=&\sum_{k=1}^{+\infty}\mu(k)g(nk)\\=&\sum_{k=1}^{+\infty}\mu(k)\sum_{nk|t}f(d)\\=&\sum_{n|t}f(t)\sum_{k|(t|n)}\mu(k)\\=&\sum_{n|t}f(t)[t==n]\\=&f(n)\end{aligned}</script></blockquote><hr><p><del>具体实现咕到下篇博客里…</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组哪里难？</title>
      <link href="/2019/08/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%93%AA%E9%87%8C%E9%9A%BE%EF%BC%9F/"/>
      <url>/2019/08/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%93%AA%E9%87%8C%E9%9A%BE%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>感谢</p><blockquote><p>2009年国家集训队论文<br><br><a href="https://www.cnblogs.com/victorique/p/8480093.html" target="_blank" rel="noopener">后缀数组 最详细讲解</a><br><br><a href="https://www.luogu.org/problemnew/solution/P3809" target="_blank" rel="noopener">luoguP3809 【模板】后缀排序 题解</a> <br><br><a href="https://www.luogu.org/problemnew/solution/P2408" target="_blank" rel="noopener">luoguP2408 不同子串个数 题解</a><br></p></blockquote><p>以及</p><blockquote><p>来自<del>ZhengRuIOI</del>的课件</p></blockquote><p>让本蒟蒻<del>大概</del>明白了这种算法<br><a id="more"></a></p><h2 id="什么是后缀数组？"><a href="#什么是后缀数组？" class="headerlink" title="什么是后缀数组？"></a>什么是后缀数组？</h2><p>后缀数组指的是一个一维的数组，将一个给定的字符串的每一个后缀以其起始位置作为编号，按照字典序的大小排好序后放到一个数组中，我们便得到了一个后缀数组。</p><h2 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h2><blockquote><p>后缀数组——处理字符串的有力工具<br><br>——罗穗骞</p></blockquote><p>如上所述，后缀数组可以解决许多<del>花里胡哨</del>的字符串问题，尤其是子串相关问题。后缀数组相较后缀自动机更易实现，且有更优秀的空间复杂度，而且许多后缀自动机的操作后缀数组都能完成。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>一般通用的方法有倍增法与DC3法，倍增法的时间复杂度为$O(logn)$，而DC3法则以思维难度的提升与代码实现方式的复杂化使时间复杂度提升为$O(n)$。<br><br>由于本人过于菜(<del>懒</del>)，在本文章中暂时只介绍倍增法。</p><h2 id="配套食用"><a href="#配套食用" class="headerlink" title="配套食用"></a>配套食用</h2><p>单纯的后缀数组虽然<del>看上去</del>非常牛，但是我们一般不仅仅要需要后缀的信息，更希望知道子串的相关信息，这时，就要用到LCP（最长公共前缀）这种奇妙的东西和$height$数组了。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="数组设定"><a href="#数组设定" class="headerlink" title="数组设定"></a>数组设定</h2><p>后缀数组相交于以前学过的其他算法，有着更加复杂的数组设定，下面加以综述。</p><blockquote><p>$sa[i]$：排好序的后缀数组第$i$位的后缀开头位置<br><br>$rk[i]$：开头位置为$i$的后缀在后缀数组中的位置<br><br>$x[i]$：基数排序时的第一关键字排名（待会会讲）<br><br>$y[i]$：基数排序的第二关键字排名，同时也是在$sa$数组计算过程中存储的暂时排名<br><br>$c[i]$：基数排序所用的桶<br><br>$height[i]$：$sa[i]$与$sa[i-1]$的<strong>最长公共前缀</strong></p></blockquote><p>很明显$sa[i]$与$rk[i]$互为逆运算。</p><h2 id="前置：基数排序"><a href="#前置：基数排序" class="headerlink" title="前置：基数排序"></a>前置：基数排序</h2><p>一种奇妙的可以实现$O(n)$ 排序的方法<br><br>与桶排类似，不过是将每一个数拆分成个位、十位…<br><br>先按照个位插入桶中，再逐个放入答案数组中，这样的一次操作可以保证个位有序。再按照十位插入桶中，放入答案数组中，这一次操作后会使十位有序，因为个位已经有序了，那么前两位就全部有序了。<br><br>值得注意的一点，在从桶中弹出的时候，应该倒序枚举($n \rightarrow 1$)，这样才能保证之前排好的顺序不会乱掉。<br><br>举个例子吧：</p><blockquote><p>21 18 12 42 56 66 22 46</p></blockquote><p>先按个位排</p><blockquote><p>21<br>12 42 22<br>56 66 46<br>18<br></p></blockquote><p>然后</p><blockquote><p>21 12 42 22 56 66 46 18<br></p></blockquote><p>再按十位排</p><blockquote><p>12 18<br> 21 22<br>42 46<br>56<br>66<br></p></blockquote><p>得到答案</p><blockquote><p>12 18 21 22 42 46 56 66<br></p></blockquote><h2 id="求后缀数组的倍增法（-SA-）"><a href="#求后缀数组的倍增法（-SA-）" class="headerlink" title="求后缀数组的倍增法（$SA()$）"></a>求后缀数组的倍增法（$SA()$）</h2><p>我们要判断两个后缀的字典序，当然可以$O(n)$的去扫一遍，不过面对全部后缀，使用快速排序的话，$O(n^2 logn)$显然无法接受。这时，提出一种新的方法——倍增法，其做法是这样的：<br>首先针对每一位上的子串获得一个排名。</p><p><fancybox><br><img src="https://s2.ax1x.com/2019/08/09/eb831U.png" alt="eb831U.png"></fancybox></p><p>然后我们将第$i$位的排名与$i+1$位合并</p><p><fancybox><br><img src="https://s2.ax1x.com/2019/08/09/ebtarD.png" alt="ebtarD.png"></fancybox></p><p>在这个<del>可爱</del>的例子中，我们已经完成了排序，如果两次没有完成，那么就不断沿着当前点往后的$2^k$合并，很明显，如果每一个后缀的排名都不同的话，算法就可以停止了。<br><br>代码长这样<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(i, j, k) for(register int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rf(i, j, k) for(register int i = j; i &gt;= k; --i)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span></span>&#123;</span><br><span class="line">fr(i, <span class="number">1</span>, n)c[x[i] = a[i]]++;<span class="comment">//塞到桶里</span></span><br><span class="line">fr(i, <span class="number">2</span>, m)c[i] += c[i - <span class="number">1</span>];<span class="comment">//做个前缀和</span></span><br><span class="line">rf(i, n, <span class="number">1</span>)sa[c[x[i]]--] = i;<span class="comment">//第一次的排名</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>)&#123;<span class="comment">//枚举2的k次</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">fr(i, n - k + <span class="number">1</span>, n)y[++num] = i;<span class="comment">//最后的k个数很明显没有第二关键字，所以它们在y数组的最前面</span></span><br><span class="line">fr(i, <span class="number">1</span>, n)<span class="keyword">if</span>(sa[i] &gt; k)y[++num] = sa[i] - k;<span class="comment">//如果当前的排名大于k，就可以作为别人的第二关键字，塞到第二关键字中</span></span><br><span class="line">fr(i, <span class="number">1</span>, m)c[i] = <span class="number">0</span>;</span><br><span class="line">fr(i, <span class="number">1</span>, n)c[x[i]]++;</span><br><span class="line">fr(i, <span class="number">2</span>, m)c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">rf(i, n, <span class="number">1</span>)sa[c[x[y[i]]]--] = y[i], y[i] = <span class="number">0</span>;<span class="comment">//基数排序</span></span><br><span class="line">swap(x, y);<span class="comment">//准备通过旧的x生成新的x</span></span><br><span class="line">x[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">num = <span class="number">1</span>;</span><br><span class="line">fr(i, <span class="number">2</span>, n)&#123;</span><br><span class="line">x[sa[i]] = (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) ? num : ++num; <span class="comment">//通过排好序的sa[i]生成新的第一关键字</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num == n)<span class="keyword">break</span>;<span class="comment">//排名全都不一样就可以退出了</span></span><br><span class="line">m = num;<span class="comment">//数据的范围变成只有num个</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最大公共前缀（LCP）"><a href="#最大公共前缀（LCP）" class="headerlink" title="最大公共前缀（LCP）"></a>最大公共前缀（LCP）</h2><p>其实后缀数组本身能解决的问题有限，我们很多时候都要与$LCP$和$height$数组配套使用。<br></p><h3 id="怎么求-height-？"><a href="#怎么求-height-？" class="headerlink" title="怎么求$height$？"></a>怎么求$height$？</h3><p>直接暴力$O(n)$求解每个$height[i]$显然不可行，但是某些极其牛的人证出了一条不那么显然的结论：</p><script type="math/tex; mode=display">height[i] \ge height[i - 1] - 1</script><p>下面我来尝试以一种更加浅显的方式来证明。<br><br>首先考虑$i$在原串中的前一位$i-1$，再考虑$i-1$在后缀数组中的前一位$k$。<br>很明显分一下两种情况：<br>第一种情况$k$与$i-1$没有公共前缀，即$height[i-1] == 0$，此时结论显然成立。</p><p><fancybox><br><img src="https://s2.ax1x.com/2019/08/09/equOvd.png" alt="equOvd.png"></fancybox></p><p>第二种情况如上图，$k$与$i-1$有公共前缀，即$height[i] \not= 0$。此时考虑k在原串中的后一位$k+1$与$i$之间的公共前缀，可以明显地得到以下结论：</p><blockquote><p>1.在排好序的后缀数组中，$k+1$在$i$的前面。(因为$k+1$是$k$的后缀，$i$是$i-1$的后缀)<br><br>2.$k+1$与$i$之间的最长公共前缀为$height[i-1]-1$</p></blockquote><p><fancybox><br><a href="https://imgchr.com/i/eqMc6J" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/08/09/eqMc6J.png" alt="eqMc6J.png"></a></fancybox></p><p>那么也就说明了，$height[i]$的大小至少为$height[i-1]-1$，因为如果有一个后缀插在$k+1$与$i$中间的话，它与$i$的最长公共公共前缀不可能会比$k+1$与$i$的最长公共前缀小。就这样，我们得到了一个$O(n)$的解法来求解$height$数组。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_height</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">fr(i, <span class="number">1</span>, n)rk[sa[i]] = i;<span class="comment">//获取排名</span></span><br><span class="line">fr(i, <span class="number">1</span>, n)&#123;</span><br><span class="line">j = sa[rk[i] - <span class="number">1</span>];<span class="comment">//j是i在sa数组中的前一位</span></span><br><span class="line"><span class="keyword">if</span>(k) k--;<span class="comment">//因为是&gt;= height[i-1] - 1，所以要-1</span></span><br><span class="line"><span class="keyword">while</span>(a[i + k] == a[j + k])k++;</span><br><span class="line">height[rk[i]] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一道模版题"><a href="#一道模版题" class="headerlink" title="一道模版题"></a>一道模版题</h1><p><a href="https://www.luogu.org/problem/P3809" target="_blank" rel="noopener">luoguP3809 【模板】后缀排序</a><br><br><br>直接求出$sa$数组即可</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(i, j, k) for(register int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rf(i, j, k) for(register int i = j; i &gt;= k; --i)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn], c[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> sa[maxn], rk[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span></span>&#123;</span><br><span class="line">fr(i, <span class="number">1</span>, n)c[x[i] = s[i]]++;</span><br><span class="line">fr(i, <span class="number">2</span>, m)c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">rf(i, n, <span class="number">1</span>)sa[c[x[i]]--] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">fr(i, n - k + <span class="number">1</span>, n)y[++num] = i;</span><br><span class="line">fr(i, <span class="number">1</span>, n)<span class="keyword">if</span>(sa[i] &gt; k)y[++num] = sa[i] - k;</span><br><span class="line">fr(i, <span class="number">1</span>, m)c[i] = <span class="number">0</span>;</span><br><span class="line">fr(i, <span class="number">1</span>, n)c[x[i]]++;</span><br><span class="line">fr(i, <span class="number">2</span>, m)c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">rf(i, n, <span class="number">1</span>)sa[c[x[y[i]]]--] = y[i], y[i] = <span class="number">0</span>;</span><br><span class="line">swap(x, y);</span><br><span class="line">x[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">num = <span class="number">1</span>;</span><br><span class="line">fr(i, <span class="number">2</span>, n)&#123;</span><br><span class="line">x[sa[i]] = (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) ? num : ++num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num == n)<span class="keyword">break</span>;</span><br><span class="line">m = num;</span><br><span class="line">&#125;</span><br><span class="line">fr(i, <span class="number">1</span>, n)<span class="built_in">printf</span>(<span class="string">"%d "</span>, sa[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">gets(s+<span class="number">1</span>);</span><br><span class="line">n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">m = <span class="number">122</span>;</span><br><span class="line">SA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>评论的使用方法</title>
      <link href="/2019/08/06/%E8%AF%84%E8%AE%BA%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2019/08/06/%E8%AF%84%E8%AE%BA%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>评论系统来自<a href="https://valine.js.org/" target="_blank" rel="noopener">valine</a><br><a id="more"></a></p><p><fancybox><br><img src="https://s2.ax1x.com/2019/08/06/ehlXX8.png" alt="ehlXX8.png"></fancybox></p><h3 id="1-昵称"><a href="#1-昵称" class="headerlink" title="1. 昵称"></a>1. 昵称</h3><p>顾名思义就是你评论之后显示的名称啦</p><h3 id="2-邮箱"><a href="#2-邮箱" class="headerlink" title="2. 邮箱"></a>2. 邮箱</h3><p>获取头像用的</p><p>请自行登录或注册<a href="https://cn.gravatar.com/" target="_blank" rel="noopener">Gravatar</a>，然后修改自己的头像。（详情请咨询度娘）</p><p>评论的时候，留下在<a href="https://cn.gravatar.com/" target="_blank" rel="noopener">Gravatar</a>注册时所使用的邮箱即可。</p><h3 id="3-链接"><a href="#3-链接" class="headerlink" title="3. 链接"></a>3. 链接</h3><p>可选项，填写后会在你的评论上自动生成一个链接（<del>记得加  https://</del>），效果如图：</p><p><fancybox><br><img src="https://s2.ax1x.com/2019/08/06/eh8CQ0.png" alt="eh8CQ0.png"></fancybox></p><h3 id="4-内容"><a href="#4-内容" class="headerlink" title="4. 内容"></a>4. 内容</h3><p>支持emoji与markdown</p><hr><p><strong>全部完成后点击发布即可！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-7题解综合2——DP</title>
      <link href="/2019/08/04/2019-7-29%E9%A2%98%E8%A7%A3%E7%BB%BC%E5%90%88/"/>
      <url>/2019/08/04/2019-7-29%E9%A2%98%E8%A7%A3%E7%BB%BC%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="7-29-“简单”DP"><a href="#7-29-“简单”DP" class="headerlink" title="7.29 “简单”DP"></a>7.29 “简单”DP</h1><a id="more"></a><h2 id="luogu-P2467-SDOI2010-地精部落"><a href="#luogu-P2467-SDOI2010-地精部落" class="headerlink" title="luogu P2467 [SDOI2010]地精部落"></a>luogu P2467 [SDOI2010]地精部落</h2><p><a href="https://www.luogu.org/problem/P2467" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>一个序列符合要求，当且仅当其是一个$1 \sim n$的排列，且每一个$a[i]$ <br><br>满足$a[i-1]\le a[i]$且$a[i]\ge a[i+1]$ <br><br>或者满足$a[i-1]\ge a[i]$且$a[i]\le a[i+1]$ <br><br>求长度为$n$的合法序列方案数</p><h3 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h3><p>神仙题。。。。<br><br><del>显然</del>有以下性质：</p><blockquote><p>1.当$i$与$i+1$不相邻时，交换$i$与$i+1$仍会得到一个合法的解<br><br>如:$3 2 4 1 5 \rightarrow 3 1 4 2 5$ <br><br>2.一串序列$a[i]$，$i\in [1,n]$满足条件时，则$(i+1)-a[i]$亦满足条件<br><br>如:$3 2 4 1 5 \rightarrow 3 4 2 5 1$ <br><br>3.满足条件的序列具有对称性 <br><br>如:$3 2 4 1 5 \rightarrow 5 1 4 2 3$ <br></p></blockquote><p>则设$dp[i][j]$表示当前为前$i$个数的<strong>排列</strong>，且首位是$j$且为<strong>山峰</strong>的方案数。<br></p><script type="math/tex; mode=display">\!\begin{split}& 由性质1可知:\!\begin{cases}\text{当$j$与$j-1$不相邻时，$dp[i][j]=dp[i][j-1]$}\\\end{cases}\\& 由性质2可知:\!\begin{cases}\text{首位做山峰的方案数=首位做山谷的方案数}\\\downarrow \\\text{(也就是说最后的答案是$2*\sum_{i=1}^n dp[n][i]$)}\\\\\text{当$j$与$j-1$相邻时，}\\\text{方案数即为$i-1$个数，$j-1$为首位且为山谷的方案数}\\\text{$\downarrow$}\\\text{即$dp[i][j]=dp[i-1][(i-1+1)-(j-1)]$}\end{cases}\end{split}</script><p>综上，$dp[i][j]=dp[i][j-1]+dp[i-1][i-j+1]$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, p;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">2</span>][<span class="number">4300</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;p);</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">dp[i &amp; <span class="number">1</span>][j] = (dp[i &amp; <span class="number">1</span>][j - <span class="number">1</span>] + dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][i - j + <span class="number">1</span>]) % p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">ans = ans + dp[n &amp; <span class="number">1</span>][i] % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans &lt;&lt; <span class="number">1</span>) % p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="luogu-P2519-HAOI2011-problem-a"><a href="#luogu-P2519-HAOI2011-problem-a" class="headerlink" title="luogu P2519 [HAOI2011]problem a"></a>luogu P2519 [HAOI2011]problem a</h2><p><a href="https://www.luogu.org/problem/P2519" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>一次考试共有$n$个人参加，第$i$个人说：“有$ai$个人分数比我高，$bi$个人分数比我低。”问最少有几个人没有说真话(可能有相同的分数)</p><h3 id="大体思路-1"><a href="#大体思路-1" class="headerlink" title="大体思路"></a>大体思路</h3><p>先进行补集转化，目标变成求说真话的人数。<br>有$ai$个人分数比我低，$bi$个人分数比我高，就意味着$[ai+1,n-bi-1]$是相同的数。<br><br>问题转化为使$k$段区间不重叠且权值和最大。按照右端点排序之后dp即可。<br>几点细节:</p><blockquote><p>1.合法解可以有完全重合的区间，但是一段区间最多只能有<strong>区间长度</strong>个说真话的人。<br><br>2.要特判$ai \ge bi$的情况</p></blockquote><p>设$f[i]$表示当前为第$i$位的区间最大值，则</p><script type="math/tex; mode=display">f[i]=max(f[i-1],f[L[j]-1]+w[j])  (R[j]==i)</script><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> gc;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line"><span class="keyword">if</span>(!(ch ^ <span class="string">'-'</span>))f = <span class="number">-1</span>, gc;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line"><span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> r == a.r ? l &lt; a.l : r &lt; a.r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;p[maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn], L[maxn], R[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">int</span> a, b, tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">a = read(), b = read();</span><br><span class="line"><span class="comment">// cout&lt;&lt;a&lt;&lt; " "&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line">p[i].l = a + <span class="number">1</span>, p[i].r = n - b;</span><br><span class="line">&#125;</span><br><span class="line">sort(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i].l &gt; p[i].r)<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// cout&lt;&lt;p[i].l&lt;&lt; " "&lt;&lt;p[i].r&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(p[i].l != p[i - <span class="number">1</span>].l || p[i].r != p[i - <span class="number">1</span>].r)tot++;</span><br><span class="line"><span class="comment">// cout&lt;&lt;tot&lt;&lt;endl;</span></span><br><span class="line">w[tot] = min(w[tot] + <span class="number">1</span>, p[i].r - p[i].l + <span class="number">1</span>);</span><br><span class="line">L[tot] = p[i].l, R[tot] = p[i].r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for(int i = 1; i &lt;= tot; ++i)&#123;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;w[i]&lt;&lt; " "&lt;&lt;L[i]&lt;&lt; " "&lt;&lt;R[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="comment">// int j = 1;</span></span><br><span class="line">f[i] = f[i - <span class="number">1</span>];</span><br><span class="line"><span class="comment">// cout&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">while</span>(j &lt;= tot &amp;&amp; R[j] == i)&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;L[j]&lt;&lt;endl;</span></span><br><span class="line">f[i] = max(f[i], f[L[j] - <span class="number">1</span>] + w[j]);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - f[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1016C-Vasya-And-The-Mushrooms"><a href="#CF1016C-Vasya-And-The-Mushrooms" class="headerlink" title="CF1016C Vasya And The Mushrooms"></a>CF1016C Vasya And The Mushrooms</h2><p><a href="https://www.luogu.org/problem/CF1016C" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个$2<em>n$的方格阵，经过一个格子获得的价值为$ai</em>$进入时间,求从左上角出发遍历一次全部格子获得的价值最大值。</p><h3 id="大体思路-2"><a href="#大体思路-2" class="headerlink" title="大体思路"></a>大体思路</h3><p>很明显的一道dp题。。。<br><br>稍加思考便能发现能够遍历整个方阵的方案可能是长这样的</p><p><fancybox><br><img src="https://s2.ax1x.com/2019/08/05/e2CXDg.png" alt="e2CXDg.png"></fancybox></p><p>或者是长这样的</p><p><fancybox><br><img src="https://s2.ax1x.com/2019/08/05/e2PZVJ.png" alt="e2PZVJ.png"></fancybox></p><p>总之就是先是一个蛇形结构，然后接一个U形结构，很明显这两个部分都是可以预处理的。</p><p><br><br>设$f[i][0/1]$表示蛇形部分进行到第$i$列，第$0/1$行的权值<br><br>则</p><script type="math/tex; mode=display">\begin{split}&f[i][0]=\begin{cases}\text{f[i-1][0]+(2*(i-1))*val[i][0]       (i&1==0)}\\\text{f[i][1]+(2*(i-1)+1)*val[i][0]     (i&1!=0)}\\\end{cases}\\&f[i][1]=\begin{cases}\text{f[i][0]+(2*(i-1)+1)*val[i][1]     (i&1==0)}\\\text{f[i-1][1]+(2*(i-1))*val[i][1]       (i&1!=0)}\\\end{cases}\end{split}</script><p><br><br>U形部分的计算方法：</p><script type="math/tex; mode=display">\begin{split}&\text{自左向右的部分}\\&\sum_{i=k}^n vi*[T+(i-k)]\\ &\downarrow\\&\sum_{i=k}^n vi*i+\sum_{i=k}^n vi*(T-k)\\\\&\text{自右向左的部分}\\&\sum_{i=k}^n vi*[T+(n-k)+(n-k-i+1)]\\&\downarrow\\&\sum_{i=k}^n vi*(T+2*n-2*k+1)-\sum_{i=k}^n vi*i\\\end{split}</script><p>$k$为U形部分开始的位置<br><br>设$g[i][0/1]$表示U形部分<strong>从0/1列， i行开始</strong>的权值，$sum[i][0/1]$表示本行<strong>距离结尾</strong>的权值和$nxt[i][0/1]$表示<strong>距离结尾</strong>的<strong>权值与列数乘积之和</strong><br><br>则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(i &amp; <span class="number">1</span>))&#123;</span><br><span class="line">g[i][<span class="number">1</span>] = nxt[i][<span class="number">1</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) - i) * sum[i][<span class="number">1</span>];</span><br><span class="line">g[i][<span class="number">1</span>] += (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">2</span> * n - i + <span class="number">1</span>) * sum[i][<span class="number">0</span>] - nxt[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">g[i][<span class="number">0</span>] = nxt[i][<span class="number">0</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) - i) * sum[i][<span class="number">0</span>];</span><br><span class="line">g[i][<span class="number">0</span>] += (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">2</span> * n - i + <span class="number">1</span>) * sum[i][<span class="number">1</span>] - nxt[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的答案就是每一种合法的蛇形与U形组合取$max$。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> gc;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>, gc;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line"><span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">readll</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll ret = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> gc;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>, gc;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line"><span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3</span> * <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line">ll val[maxn][<span class="number">2</span>];</span><br><span class="line">ll sum[maxn][<span class="number">2</span>], nxt[maxn][<span class="number">2</span>];</span><br><span class="line">ll f[maxn][<span class="number">2</span>], g[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">val[i][<span class="number">0</span>] = readll();</span><br><span class="line"><span class="comment">// cnt[i][0] = val[i][0] * i;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">val[i][<span class="number">1</span>] = readll();</span><br><span class="line"><span class="comment">// cnt[i][1] = val[i][1] * i;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">sum[i][<span class="number">0</span>] = sum[i + <span class="number">1</span>][<span class="number">0</span>] + val[i][<span class="number">0</span>];</span><br><span class="line">sum[i][<span class="number">1</span>] = sum[i + <span class="number">1</span>][<span class="number">1</span>] + val[i][<span class="number">1</span>];</span><br><span class="line">nxt[i][<span class="number">0</span>] = nxt[i + <span class="number">1</span>][<span class="number">0</span>] + val[i][<span class="number">0</span>] * i;</span><br><span class="line">nxt[i][<span class="number">1</span>] = nxt[i + <span class="number">1</span>][<span class="number">1</span>] + val[i][<span class="number">1</span>] * i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>)) * val[i][<span class="number">0</span>];</span><br><span class="line">f[i][<span class="number">1</span>] = f[i][<span class="number">0</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">1</span>) * val[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>)) * val[i][<span class="number">1</span>];</span><br><span class="line">f[i][<span class="number">0</span>] = f[i][<span class="number">1</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">1</span>) * val[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for(int i = 1; i &lt;= n; ++i)&#123;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;"sum"&lt;&lt;sum[i][0]&lt;&lt; " "&lt;&lt;sum[i][1]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;"nxt"&lt;&lt;nxt[i][0]&lt;&lt; " "&lt;&lt;nxt[i][1]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(i &amp; <span class="number">1</span>))&#123;</span><br><span class="line">g[i][<span class="number">1</span>] = nxt[i][<span class="number">1</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) - i) * sum[i][<span class="number">1</span>];</span><br><span class="line">g[i][<span class="number">1</span>] += (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">2</span> * n - i + <span class="number">1</span>) * sum[i][<span class="number">0</span>] - nxt[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">g[i][<span class="number">0</span>] = nxt[i][<span class="number">0</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) - i) * sum[i][<span class="number">0</span>];</span><br><span class="line">g[i][<span class="number">0</span>] += (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">2</span> * n - i + <span class="number">1</span>) * sum[i][<span class="number">1</span>] - nxt[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for(int i = 1; i &lt;= n; ++i)&#123;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;"!!"&lt;&lt;f[i][0]&lt;&lt; " "&lt;&lt;f[i][1]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;g[i][0]&lt;&lt; " "&lt;&lt;g[i][1]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;f[i][1]&lt;&lt; " "&lt;&lt;g[i + 1][1]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;f[i][0]&lt;&lt; " "&lt;&lt;g[i + 1][0]&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">ans = max(ans, f[i][<span class="number">1</span>] + g[i + <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ans = max(ans, f[i][<span class="number">0</span>] + g[i + <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF467C-George-and-Job"><a href="#CF467C-George-and-Job" class="headerlink" title="CF467C George and Job"></a>CF467C George and Job</h2><p><a href="https://www.luogu.org/problem/CF467C" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一组有$n$个整数的数列$p_1,p_2,…,p_n$，你需要挑出$k$组长度为$m$的数，要求这些数互不重叠，即：$[l_1,r_1],[l_2,r_2],…,<a href="1 \le l_1 \le r_1 &lt; l_2 \le r_2 &lt; ... &lt; l_k \le r_k \le n; r_i-l_i+1=m">l_k,r_k</a>$ 且使选出的数和值最大</p><h3 id="大体思路-3"><a href="#大体思路-3" class="headerlink" title="大体思路"></a>大体思路</h3><p>直接依照题意dp即可。<br><br>设$f[i][j]$为当前在第$i$位，选了$j$个区间时的最大值，$s[i]$为以$i$为起始点的长度为$m$的权值之和 <br><br>转移为：$f[i][j]=max(f[i-1][j],f[i-m][j-1]+s[i])$</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5010</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>;<span class="keyword">char</span> gc;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line"><span class="keyword">if</span>(!(ch ^<span class="string">'-'</span>))f = <span class="number">-1</span>, gc;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line"><span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">readll</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>, f = <span class="number">1</span>;<span class="keyword">char</span> gc;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line"><span class="keyword">if</span>(!(ch ^<span class="string">'-'</span>))f = <span class="number">-1</span>, gc;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line"><span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> p[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[maxn][maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">n = read(), m = read(), k = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">p[i] = readll();</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt;= n; ++i)&#123;</span><br><span class="line">s[i] = sum[i] - sum[i - m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k &amp;&amp; j * m &lt;= i; ++j)&#123;</span><br><span class="line">f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">f[i][j] = max(f[i][j], f[i - m][j - <span class="number">1</span>] + s[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f[n][k]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019.7题解综合1 —— 并查集与分治</title>
      <link href="/2019/08/01/2019-7%E9%A2%98%E8%A7%A3%E7%BB%BC%E5%90%88/"/>
      <url>/2019/08/01/2019-7%E9%A2%98%E8%A7%A3%E7%BB%BC%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>第一次在外面参加这么长时间的集训… 被各路大佬摧残…<br><a id="more"></a></p><h1 id="7-25-并查集相关"><a href="#7-25-并查集相关" class="headerlink" title="7.25 并查集相关"></a>7.25 并查集相关</h1><h2 id="CF468b-TWOSETS"><a href="#CF468b-TWOSETS" class="headerlink" title="CF468b TWOSETS"></a>CF468b TWOSETS</h2><p><a href="https://www.luogu.org/problem/CF468B" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出 $n$ 个各不相同的数字，将它们分别放入 $A$ 和 $B$ 两个集合中，使它们满足：</p><blockquote><p>若数字 $x$ 在集合 $A$ 中，那么数字 $a-x$ 也在集合 $A$ 中；<br><br>若数字 $x$ 在集合 $B$ 中，那么数字 $b-x$ 也在集合 $B$ 中。<br></p></blockquote><h3 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h3><p>分为以下几种情况</p><blockquote><p>1.$a-x$与$b-x$有一个存在<br><br>$a-x$与$b-x$都不存在<br><br>$a-x$与$b-x$都存在<br></p></blockquote><p>很显然，$a-(a-x)=x$,因此如果$a-x(b-x)$不在给定的集合中，则$x$就只能在$B(A)$中（注意顺序）。而如果$a-x$与$b-x$都不存在，便会无解。<br><br>重点在于情况三，如果$a-x$与$b-x$都存在，那么$x$在哪个集合都可以，这时候决定$x$在哪里的并不是$x$本身，而是与$a-x$与$b-x$有关的数。<br><br>综合以上情况，考虑用并查集维护。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>;<span class="keyword">char</span> gc;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>,gc;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line"><span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> pos[maxn];</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findx</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = findx(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fi = findx(x), fj = findx(y);</span><br><span class="line"><span class="keyword">if</span>(fi != fj)</span><br><span class="line">fa[fi] = fj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = read(), a = read(), b = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">pos[i] = read();</span><br><span class="line">mp[pos[i]] = i;</span><br><span class="line">fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">x = n + <span class="number">1</span>, y = n + <span class="number">2</span>;</span><br><span class="line">fa[x] = x, fa[y] = y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;pos[i]&lt;&lt;"  "&lt;&lt;a-pos[i]&lt;&lt; " "&lt;&lt;b-pos[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;"!!"&lt;&lt;mp[a - pos[i]]&lt;&lt; " "&lt;&lt;mp[b - pos[i]]&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(!mp[a - pos[i]])&#123;</span><br><span class="line">merge(i, y);</span><br><span class="line"><span class="comment">// merge(mp[])</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">merge(mp[a - pos[i]], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!mp[b - pos[i]])&#123;</span><br><span class="line">merge(i, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">merge(mp[b - pos[i]], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cout&lt;&lt;findx(i)&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x1 = findx(x), x2 = findx(y);</span><br><span class="line"><span class="keyword">if</span>(x1 == x2)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;findx(i)&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(findx(i) == x1)<span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"1"</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="luogu-P3295-SCOI2016-萌萌哒"><a href="#luogu-P3295-SCOI2016-萌萌哒" class="headerlink" title="luogu P3295 [SCOI2016]萌萌哒"></a>luogu P3295 [SCOI2016]萌萌哒</h2><p><a href="https://www.luogu.org/problem/P3295" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个序列$S$的长度为$n$以及$m$对区间$(l_1,r_1,l_2,r_2)$知每一对区间中的每个数都相同，求最终序列的方案数。</p><h3 id="大体思路-1"><a href="#大体思路-1" class="headerlink" title="大体思路"></a>大体思路</h3><p>有$m$对区间，每对区间中的每个数都相同。因为最终要求的是方案数，不用考虑单独的一种方案，考虑使用并查集维护，将每一对区间中的每一对数塞到一个并查集内部，最终答案就是$10^x＊９$($ｘ$为并查集的总数)。<br><br>此时合并的复杂度最差为$O(n^2)$，但是查询的复杂度仅为$O(n)$，无法接受。<br><br>然后通过细（<del>看</del>）致（<del>了</del>）思（<del>题</del>）考（<del>解</del>），发现可以使用类似ST表的倍增进行解决。设$id[j][i]$表示以$i$为左端点，长度为$2^j$的区间的编号，在合并时，直接合并代表两段区间的$(logn)$个区间即可。查询时，因为查询的是原始的$n$个节点，所以需要针对一段区间，将其合并下放。（实现方式与st表类似）。此时合并$O(logn)$，查询$O(logn)$，可以通过。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> tot, l1, r1, l2, r2;</span><br><span class="line"><span class="keyword">int</span> id[<span class="number">30</span>][maxn], num[maxn * <span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> fa[maxn * <span class="number">30</span>], h[maxn * <span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> bin[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findx</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = findx(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fi = findx(x), fj = findx(y);</span><br><span class="line"><span class="keyword">if</span>(h[fi] &gt; h[fj])&#123;</span><br><span class="line">swap(fi, fj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(h[fi] == h[fj])h[fj] ++;</span><br><span class="line">fa[fi] = fj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll now, ll a)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>, base = now;</span><br><span class="line"><span class="keyword">while</span>(a)&#123;</span><br><span class="line"><span class="keyword">if</span>(a &amp; <span class="number">1</span>)</span><br><span class="line">res = (<span class="number">1l</span>l * res * base) % mod;</span><br><span class="line">base = (<span class="number">1l</span>l * base * base) % mod;</span><br><span class="line">a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">bin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= <span class="number">20</span>; ++p)&#123;</span><br><span class="line">bin[p] = (bin[p - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">20</span>; ++j)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">id[j][i] = ++tot, num[tot] = i;</span><br><span class="line">fa[tot] = tot, h[tot] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">20</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line"><span class="keyword">if</span>(l1 + bin[j] - <span class="number">1</span> &lt;= r1)&#123;</span><br><span class="line">merge(id[j][l1], id[j][l2]);</span><br><span class="line">l1 += bin[j], l2 += bin[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cout&lt;&lt;1&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">20</span>; j; --j)&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;j&lt;&lt; " ";</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + bin[j] - <span class="number">1</span> &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">int</span> x = findx(id[j][i]), a = num[x];</span><br><span class="line">merge(id[j - <span class="number">1</span>][a], id[j - <span class="number">1</span>][i]);</span><br><span class="line">merge(id[j - <span class="number">1</span>][a + bin[j - <span class="number">1</span>]], id[j - <span class="number">1</span>][i + bin[j - <span class="number">1</span>]]);</span><br><span class="line"><span class="comment">// cout&lt;&lt;"j"&lt;&lt;j&lt;&lt; " "&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cout&lt;&lt;1&lt;&lt;endl;</span></span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(findx(id[<span class="number">0</span>][i]) == id[<span class="number">0</span>][i])cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(<span class="number">9l</span>l * ksm(<span class="number">10</span>, cnt - <span class="number">1</span>)) % mod;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-25-分治相关"><a href="#7-25-分治相关" class="headerlink" title="7.25 分治相关"></a>7.25 分治相关</h1><h2 id="luogu-P1429-平面最近点对（加强版）"><a href="#luogu-P1429-平面最近点对（加强版）" class="headerlink" title="luogu P1429 平面最近点对（加强版）"></a>luogu P1429 平面最近点对（加强版）</h2><p><a href="https://www.luogu.org/problem/P1429" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>平面上有$n$个点$(2≤n≤200000)$，求距离最近的点对</p><h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h3><p>考虑直接枚举$n$个点，$O(n^2)$显然不可做。。。。<br><br>考虑分治，将平面沿$x$坐标的中位数裁开，这样要求的解被分成三类。</p><blockquote><p>1.在左侧的解<br><br>2.在右侧的解<br><br>3.横跨分割线的解<br></p></blockquote><p>解1与解2分开递归计算即可，重点考虑解3如何处理。<br><br>然后发现了一种优美的性质。<strong>对于一个点来说，其要想和横跨分治边界的另一个点更新最优解，最多只有$6$个点符合要求。</strong><br><br>设左侧的递归答案为$d1$，右侧的递归答案为$d2$，则当前最优解为$\delta=min(d1,d2)$,如果要想使$dis(x,y) &lt; \delta$，很明显另一个点的取值只能是一个$[\delta,2<em>\delta]$的矩形，又因为$\delta=min(d1,d2)$，则右侧每两个点之间的距离$dis\le\delta$，也就是说，最多只能有$6$个点被选择。<br><br>先按$x$轴第一关键字，$y$轴第二关键字排序,<br>每一层分治的复杂度为$O(6</em>n)$，总复杂度$O(logn)$。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">2</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> x, y;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">int</span> tmp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(node &amp;a, node &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">int</span> &amp;i, <span class="keyword">int</span> &amp;j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a[i].y &lt; a[j].y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> d = inf;</span><br><span class="line"><span class="keyword">if</span>(l == r)<span class="keyword">return</span> d;</span><br><span class="line"><span class="keyword">if</span>(l + <span class="number">1</span> == r)<span class="keyword">return</span> dist(l, r);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> d1 = merge(l, mid);</span><br><span class="line"><span class="keyword">double</span> d2 = merge(mid + <span class="number">1</span>, r);</span><br><span class="line">d = min(d1, d2);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(a[mid].x - a[i].x) &lt; d)&#123;</span><br><span class="line">tmp[++cnt] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(tmp + <span class="number">1</span>, tmp + cnt + <span class="number">1</span>, cmp2);</span><br><span class="line"><span class="keyword">double</span> d3;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">fabs</span>(a[tmp[j]].y - a[tmp[i]].y) &lt; d; j++)&#123;</span><br><span class="line">d3 = dist(tmp[i], tmp[j]);</span><br><span class="line"><span class="keyword">if</span>(d &gt; d3)d = d3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.4lf"</span>, merge(<span class="number">1</span>, n));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新式骗分——模拟退火</title>
      <link href="/2019/06/14/%E6%96%B0%E5%BC%8F%E9%AA%97%E5%88%86%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"/>
      <url>/2019/06/14/%E6%96%B0%E5%BC%8F%E9%AA%97%E5%88%86%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/</url>
      
        <content type="html"><![CDATA[<p>博客咕咕咕的时间有点长(似乎是太长了)</p><p>今天写一下模拟退火吧。。。发现了骗分的新大陆</p><!-- （!--似乎是太长了--!） --><a id="more"></a><h1 id="一：背景"><a href="#一：背景" class="headerlink" title="一：背景"></a>一：背景</h1><h3 id="模拟退火解决的是一种什么样的问题呢？"><a href="#模拟退火解决的是一种什么样的问题呢？" class="headerlink" title="模拟退火解决的是一种什么样的问题呢？"></a>模拟退火解决的是一种什么样的问题呢？</h3><blockquote><p>模拟退火算法（Simulate Anneal，SA）是一种通用概率演算法， <strong>用来在一个大的搜寻空间内找寻命题的最优解。</strong> 模拟退火是由S.Kirkpatrick, C.D.Gelatt和&gt;M.P.Vecchi在1983年所发明的。V.Čern&yacute;在1985年也独立发明此演算法。模&gt;拟退火算法是解决TSP问题的有效方法之一。<br>—— 来自百度百科</p></blockquote><p>照例引用百度百科。</p><p> 其实模拟退火就是一种解决问题的普遍方法。</p><h1 id="二：爬山算法及其优化"><a href="#二：爬山算法及其优化" class="headerlink" title="二：爬山算法及其优化"></a>二：爬山算法及其优化</h1><p> 针对一个求最值的问题，我们可以采用一种贪心的方法，被称作“爬山算法”。爬山算法指的就是每一步都将当前节点的值与其邻居节点比较，如果有更优值就取，否则就维持当前的解。很明显，这个算法可以找到一个局部最优解。但是其有一个致命的缺陷，那就是只能找到局部最优解，但是并不能保证找到的解是一个全局最优解。</p><p> <img src="https://s2.ax1x.com/2019/07/26/euJztA.png" alt="euJztA.png"></p><p> 就比如说上面这个图，当我们在D点出发，使用爬山算法，即可到达B点，很明显这既是局部最优解，又是全局最优解。但是如果从C点或E点出发，我们最后会到达A点，（<del>然后愉快的WA</del>）<br> 这种做法很明显是不行的，那么怎么使其变的正确 或者说大约正确呢？<br> 上文提到的三位大佬想出来了一个绝妙的解决方案：<br> 使用随机算法，使得每一次搜索到比当前解差的解时，都有一定概率接受这个解。但是光随机也是不行的，所以随着循环次数的增加，会不断降低接受更劣解的概率。这就是模拟退火的主要思想。</p><h1 id="三：具体实现"><a href="#三：具体实现" class="headerlink" title="三：具体实现"></a>三：具体实现</h1><p> 先定义一下变量及数组</p><blockquote><p>t: 温度 决定了接受更劣解的概率 与down一起决定了退火的时长 更高的初始温度意味着更精确的答案， 但也意味着需要更多的时间<br><br>down: 每一次循环降低t的系数，一般是 0.9 ~ 1 的一个实数<br><br>delta: 当前解与最优解的差<br><br>now_w: 目前得到的最优解<br><br>ew：当前解</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><p>1.透过最优解计算出当前解。<br><br>2.如果获得了更优解 直接接受<br>3.更劣解有概率接受<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">sa</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> t = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">while</span>(t &gt; <span class="number">1e-15</span>)&#123;</span><br><span class="line"><span class="keyword">double</span> ex = ans_x + (rand() * <span class="number">2</span> - RAND_MAX) * t;</span><br><span class="line"><span class="keyword">double</span> ey = ans_y + (rand() * <span class="number">2</span> - RAND_MAX) * t;</span><br><span class="line"><span class="keyword">double</span> ew = get_eng(ex, ey);<span class="comment">//构造解的函数</span></span><br><span class="line"><span class="keyword">double</span> delta = ew - ans_w;</span><br><span class="line"><span class="keyword">if</span>(delta &lt; <span class="number">0</span>)&#123;</span><br><span class="line">ans_x = ex;</span><br><span class="line">ans_y = ey;</span><br><span class="line">ans_w = ew;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>(-delta / t) * RAND_MAX &gt; rand())&#123;</span><br><span class="line">ans_x = ex;</span><br><span class="line">ans_y = ey;</span><br><span class="line">&#125;</span><br><span class="line">t *= down;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>来自luoguP1337 [JSOI2004]平衡点 / 吊打XXX</p></blockquote><p> 值得注意的几个点：</p><blockquote><p>(rand() <em> 2 - RAND_MAX) </em> t : 求新解的方法<br><br>exp(-delta / t) * RAND_MAX &gt; rand()  : 来自前人的玄学判断</p></blockquote><p> <img src="https://s2.ax1x.com/2019/07/26/eu1JDH.png" alt="eu1JDH.png"></p><blockquote><p>模拟退火流程图</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可爱的数据结构——线段树</title>
      <link href="/2019/03/30/%E5%8F%AF%E7%88%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2019/03/30/%E5%8F%AF%E7%88%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="可爱的数据结构——线段树"><a href="#可爱的数据结构——线段树" class="headerlink" title="可爱的数据结构——线段树"></a>可爱的数据结构——线段树</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是数据结构呢？"><a href="#什么是数据结构呢？" class="headerlink" title="什么是数据结构呢？"></a>什么是数据结构呢？</h3><blockquote><p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关 </p><p>—-来自百度百科<br><a id="more"></a><br>简单来说，数据结构就是通过合理的方式在计算机中存储数据，来达到修改、查询的目的。</p></blockquote><p><strong>几个例子</strong><br>（纯个人看法）</p><p>朴素的数据结构</p><pre><code>数组（-_-）链表队列栈</code></pre><p>看起来高端一些的数据结构</p><pre><code>矩阵哈希表（hash）堆树状数组</code></pre><p>更高级的数据结构    </p><pre><code>线段树各种平衡树主席树</code></pre><h3 id="什么是线段树呢？"><a href="#什么是线段树呢？" class="headerlink" title="什么是线段树呢？"></a>什么是线段树呢？</h3><blockquote><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p><p>—-依然来自百度百科</p></blockquote><p>换句话说，就是把一个区间变成一个多层的树形结构，以一种二分与递归的思想实现高效的区间操作</p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>写一个数据结构，要求支持在O(logn)的时间复杂度内支持区间加与区间和。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流初识———EK</title>
      <link href="/2018/12/16/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%88%9D%E8%AF%86%E2%80%94%E2%80%94EK/"/>
      <url>/2018/12/16/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%88%9D%E8%AF%86%E2%80%94%E2%80%94EK/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当初刚开始学OI的时候，对各种奇怪的中高级算法抱有极大的兴趣（结果自然是看不懂-_-），网络流则是排在前列的几大算法之一（话说我是如何在连建图和SPFA都搞不明白的情况下看进去的…）。</p><p>如今过了一年（技术还是没有什么长进，该不会的还是不会），重新看了一篇网络流与费用流，似乎。。。有那么一点理解了，谨以此文，来表达我对网络流的一点看法。</p><h1 id="什么是网络流？"><a href="#什么是网络流？" class="headerlink" title="什么是网络流？"></a>什么是网络流？</h1><p>“网络流(network-flows)是一种类比水流的解决问题方法，与线性规划密切相关。”（来自百度百科）</p><p>举个例子，从某地要向某地输水，中间有许多粗细不同的管子，网络流算法解决的就是利用这些管子怎样使单位时间总输送量最大化的问题。 </p><a id="more"></a><h1 id="如何解决网络流问题？"><a href="#如何解决网络流问题？" class="headerlink" title="如何解决网络流问题？"></a>如何解决网络流问题？</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>会建图，会dfs、bfs（似乎只需要这些。。。）</p><h2 id="在开始之前…"><a href="#在开始之前…" class="headerlink" title="在开始之前…"></a>在开始之前…</h2><p>我们先来明晰几个概念：</p><p><strong>点的属性：</strong></p><pre><code>  源点(s): 一切的开始，入度为0  汇点(t): 一切的结束，出度为0</code></pre><p><strong>边的属性：</strong></p><pre><code>首先很明显图应该是DAG流量(flow)：每条边能通过的最大值</code></pre><h2 id="如何建图？"><a href="#如何建图？" class="headerlink" title="如何建图？"></a>如何建图？</h2><p>先不负责任的提出解决方案：对于每一条有向边，建一条与之方向相反（出入点相反），流量为0的边。</p><p><strong>为什么？</strong></p><p>我们先来明确一下网络流的工作原理：</p><p>每一次搜索结束后，便会找到一条从源点到汇点的路径（这条路径叫增广路），且该路径上的边的流量均大于0，通过这条路可以增加的流量便是这条路径中的最小流量（自行理解一下）。然后在每次搜索结束时，将这条路径上的边的流量减去可以增加的流量。重复此过程直到找不出路径为止。</p><p>这种看起来就像是贪心的算法很明显是错的… 你搜索到的流量会与你搜索的路径的顺序有关，这怎么行！</p><p>所以在建图时，要采用上文所述的方式，建一条反向边，并且在搜索完毕后减去增加流量的同时，在反向边加上增加的流量，这样在下一次搜索增广路时可以沿着反向边把流量回退，从而实现发现真正意义上的最大流的目的。</p><h1 id="上代码！"><a href="#上代码！" class="headerlink" title="上代码！"></a>上代码！</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">51000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p, m, f, u, v;</span><br><span class="line"><span class="keyword">int</span> s, t;</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nt, to, flow, val;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">        nt = n, to = t, flow = f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> h[maxn], c[maxn], tot = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;e[++tot].<span class="built_in">set</span>(h[a], b, c), h[a] = tot; e[++tot].<span class="built_in">set</span>(h[b], a, <span class="number">0</span>), h[b] = tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> dis[maxn], vis[maxn], pre[maxn], last[maxn], flow[maxn]; <span class="comment">//存路径和更新的流量</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)pre[i] = <span class="number">-1</span>, vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(last, <span class="number">-1</span>, <span class="keyword">sizeof</span>(last));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">    q.push(s);</span><br><span class="line">    pre[s] = inf;</span><br><span class="line">    flow[s] = inf;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[now]; i != <span class="number">-1</span>; i = e[i].nt)&#123;</span><br><span class="line">            <span class="keyword">int</span> nex = e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(e[i].flow &gt; <span class="number">0</span> &amp;&amp; vis[nex] == <span class="number">0</span>)&#123;</span><br><span class="line">                pre[nex] = now;</span><br><span class="line">                last[nex] = i;</span><br><span class="line">                <span class="keyword">if</span>(e[i].flow &lt; flow[now])</span><br><span class="line">                    flow[nex] = e[i].flow;</span><br><span class="line">                <span class="keyword">else</span> flow[nex] = flow[now];</span><br><span class="line">                <span class="keyword">if</span>(!vis[nex])&#123;</span><br><span class="line">                    vis[nex] = <span class="number">1</span>;</span><br><span class="line">                    q.push(nex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[t] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ek</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s, t))&#123;</span><br><span class="line">        maxflow += flow[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pre[i])&#123;</span><br><span class="line">            e[last[i]].flow -= flow[t];</span><br><span class="line">            e[last[i] ^ <span class="number">1</span>].flow += flow[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) h[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> u, v, f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u,&amp;v,&amp;f);</span><br><span class="line">        adde(u, v, f);</span><br><span class="line">    &#125;</span><br><span class="line">    ek(s, t);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxflow&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
