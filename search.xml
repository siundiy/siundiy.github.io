<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2019-7题解综合2——DP</title>
      <link href="/2019/08/04/2019-7-29%E9%A2%98%E8%A7%A3%E7%BB%BC%E5%90%88/"/>
      <url>/2019/08/04/2019-7-29%E9%A2%98%E8%A7%A3%E7%BB%BC%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="7-29-“简单”DP"><a href="#7-29-“简单”DP" class="headerlink" title="7.29 “简单”DP"></a>7.29 “简单”DP</h1><a id="more"></a><h2 id="luogu-P2467-SDOI2010-地精部落"><a href="#luogu-P2467-SDOI2010-地精部落" class="headerlink" title="luogu P2467 [SDOI2010]地精部落"></a>luogu P2467 [SDOI2010]地精部落</h2><p><a href="https://www.luogu.org/problem/P2467" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>一个序列符合要求，当且仅当其是一个$1 \sim n$的排列，且每一个$a[i]$ <br><br>满足$a[i-1]\le a[i]$且$a[i]\ge a[i+1]$ <br><br>或者满足$a[i-1]\ge a[i]$且$a[i]\le a[i+1]$ <br><br>求长度为$n$的合法序列方案数</p><h3 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h3><p>神仙题。。。。<br><br><del>显然</del>有以下性质：</p><blockquote><p>1.当$i$与$i+1$不相邻时，交换$i$与$i+1$仍会得到一个合法的解<br><br>如:$3 2 4 1 5 \rightarrow 3 1 4 2 5$ <br><br>2.一串序列$a[i]$，$i\in [1,n]$满足条件时，则$(i+1)-a[i]$亦满足条件<br><br>如:$3 2 4 1 5 \rightarrow 3 4 2 5 1$ <br><br>3.满足条件的序列具有对称性 <br><br>如:$3 2 4 1 5 \rightarrow 5 1 4 2 3$ <br></p></blockquote><p>则设$dp[i][j]$表示当前为前$i$个数的<strong>排列</strong>，且首位是$j$且为<strong>山峰</strong>的方案数。<br></p><script type="math/tex; mode=display">\!\begin{split}& 由性质1可知:\!\begin{cases}\text{当$j$与$j-1$不相邻时，$dp[i][j]=dp[i][j-1]$}\\\end{cases}\\& 由性质2可知:\!\begin{cases}\text{首位做山峰的方案数=首位做山谷的方案数}\\\downarrow \\\text{(也就是说最后的答案是$2*\sum_{i=1}^n dp[n][i]$)}\\\\\text{当$j$与$j-1$相邻时，}\\\text{方案数即为$i-1$个数，$j-1$为首位且为山谷的方案数}\\\text{$\downarrow$}\\\text{即$dp[i][j]=dp[i-1][(i-1+1)-(j-1)]$}\end{cases}\end{split}</script><p>综上，$dp[i][j]=dp[i][j-1]+dp[i-1][i-j+1]$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, p;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">2</span>][<span class="number">4300</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;p);</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">dp[i &amp; <span class="number">1</span>][j] = (dp[i &amp; <span class="number">1</span>][j - <span class="number">1</span>] + dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][i - j + <span class="number">1</span>]) % p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">ans = ans + dp[n &amp; <span class="number">1</span>][i] % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans &lt;&lt; <span class="number">1</span>) % p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="luogu-P2519-HAOI2011-problem-a"><a href="#luogu-P2519-HAOI2011-problem-a" class="headerlink" title="luogu P2519 [HAOI2011]problem a"></a>luogu P2519 [HAOI2011]problem a</h2><p><a href="https://www.luogu.org/problem/P2519" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>一次考试共有$n$个人参加，第$i$个人说：“有$ai$个人分数比我高，$bi$个人分数比我低。”问最少有几个人没有说真话(可能有相同的分数)</p><h3 id="大体思路-1"><a href="#大体思路-1" class="headerlink" title="大体思路"></a>大体思路</h3><p>先进行补集转化，目标变成求说真话的人数。<br>有$ai$个人分数比我低，$bi$个人分数比我高，就意味着$[ai+1,n-bi-1]$是相同的数。<br><br>问题转化为使$k$段区间不重叠且权值和最大。按照右端点排序之后dp即可。<br>几点细节:</p><blockquote><p>1.合法解可以有完全重合的区间，但是一段区间最多只能有<strong>区间长度</strong>个说真话的人。<br><br>2.要特判$ai \ge bi$的情况</p></blockquote><p>设$f[i]$表示当前为第$i$位的区间最大值，则</p><script type="math/tex; mode=display">f[i]=max(f[i-1],f[L[j]-1]+w[j])  (R[j]==i)</script><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> gc;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line"><span class="keyword">if</span>(!(ch ^ <span class="string">'-'</span>))f = <span class="number">-1</span>, gc;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line"><span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> r == a.r ? l &lt; a.l : r &lt; a.r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;p[maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn], L[maxn], R[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">int</span> a, b, tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">a = read(), b = read();</span><br><span class="line"><span class="comment">// cout&lt;&lt;a&lt;&lt; " "&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line">p[i].l = a + <span class="number">1</span>, p[i].r = n - b;</span><br><span class="line">&#125;</span><br><span class="line">sort(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i].l &gt; p[i].r)<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// cout&lt;&lt;p[i].l&lt;&lt; " "&lt;&lt;p[i].r&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(p[i].l != p[i - <span class="number">1</span>].l || p[i].r != p[i - <span class="number">1</span>].r)tot++;</span><br><span class="line"><span class="comment">// cout&lt;&lt;tot&lt;&lt;endl;</span></span><br><span class="line">w[tot] = min(w[tot] + <span class="number">1</span>, p[i].r - p[i].l + <span class="number">1</span>);</span><br><span class="line">L[tot] = p[i].l, R[tot] = p[i].r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for(int i = 1; i &lt;= tot; ++i)&#123;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;w[i]&lt;&lt; " "&lt;&lt;L[i]&lt;&lt; " "&lt;&lt;R[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="comment">// int j = 1;</span></span><br><span class="line">f[i] = f[i - <span class="number">1</span>];</span><br><span class="line"><span class="comment">// cout&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">while</span>(j &lt;= tot &amp;&amp; R[j] == i)&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;L[j]&lt;&lt;endl;</span></span><br><span class="line">f[i] = max(f[i], f[L[j] - <span class="number">1</span>] + w[j]);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - f[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1016C-Vasya-And-The-Mushrooms"><a href="#CF1016C-Vasya-And-The-Mushrooms" class="headerlink" title="CF1016C Vasya And The Mushrooms"></a>CF1016C Vasya And The Mushrooms</h2><p><a href="https://www.luogu.org/problem/CF1016C" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个$2<em>n$的方格阵，经过一个格子获得的价值为$ai</em>$进入时间,求从左上角出发遍历一次全部格子获得的价值最大值。</p><h3 id="大体思路-2"><a href="#大体思路-2" class="headerlink" title="大体思路"></a>大体思路</h3><p>很明显的一道dp题。。。<br><br>稍加思考便能发现能够遍历整个方阵的方案可能是长这样的<br><img src="https://s2.ax1x.com/2019/08/05/e2CXDg.png" alt="e2CXDg.png"></p><p>或者是长这样的<br><img src="https://s2.ax1x.com/2019/08/05/e2PZVJ.png" alt="e2PZVJ.png"><br>总之就是先是一个蛇形结构，然后接一个U形结构，很明显这两个部分都是可以预处理的。<br><br>设$f[i][0/1]$表示蛇形部分进行到第$i$列，第$0/1$行的权值<br><br>则</p><script type="math/tex; mode=display">\begin{split}&f[i][0]=\begin{cases}\text{f[i-1][0]+(2*(i-1))*val[i][0]       (i&1==0)}\\\text{f[i][1]+(2*(i-1)+1)*val[i][0]     (i&1!=0)}\\\end{cases}\\&f[i][1]=\begin{cases}\text{f[i][0]+(2*(i-1)+1)*val[i][1]     (i&1==0)}\\\text{f[i-1][1]+(2*(i-1))*val[i][1]       (i&1!=0)}\\\end{cases}\end{split}</script><p><br><br>U形部分的计算方法：</p><script type="math/tex; mode=display">\begin{split}&\text{自左向右的部分}\\&\sum_{i=k}^n vi*[T+(i-k)]\\ &\downarrow\\&\sum_{i=k}^n vi*i+\sum_{i=k}^n vi*(T-k)\\\\&\text{自右向左的部分}\\&\sum_{i=k}^n vi*[T+(n-k)+(n-k-i+1)]\\&\downarrow\\&\sum_{i=k}^n vi*(T+2*n-2*k+1)-\sum_{i=k}^n vi*i\\\end{split}</script><p>$k$为U形部分开始的位置<br><br>设$g[i][0/1]$表示U形部分<strong>从0/1列， i行开始</strong>的权值，$sum[i][0/1]$表示本行<strong>距离结尾</strong>的权值和$nxt[i][0/1]$表示<strong>距离结尾</strong>的<strong>权值与列数乘积之和</strong><br><br>则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(i &amp; <span class="number">1</span>))&#123;</span><br><span class="line">g[i][<span class="number">1</span>] = nxt[i][<span class="number">1</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) - i) * sum[i][<span class="number">1</span>];</span><br><span class="line">g[i][<span class="number">1</span>] += (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">2</span> * n - i + <span class="number">1</span>) * sum[i][<span class="number">0</span>] - nxt[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">g[i][<span class="number">0</span>] = nxt[i][<span class="number">0</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) - i) * sum[i][<span class="number">0</span>];</span><br><span class="line">g[i][<span class="number">0</span>] += (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">2</span> * n - i + <span class="number">1</span>) * sum[i][<span class="number">1</span>] - nxt[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的答案就是每一种合法的蛇形与U形组合取$max$。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> gc;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>, gc;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line"><span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">readll</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll ret = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> gc;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>, gc;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line"><span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3</span> * <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line">ll val[maxn][<span class="number">2</span>];</span><br><span class="line">ll sum[maxn][<span class="number">2</span>], nxt[maxn][<span class="number">2</span>];</span><br><span class="line">ll f[maxn][<span class="number">2</span>], g[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">val[i][<span class="number">0</span>] = readll();</span><br><span class="line"><span class="comment">// cnt[i][0] = val[i][0] * i;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">val[i][<span class="number">1</span>] = readll();</span><br><span class="line"><span class="comment">// cnt[i][1] = val[i][1] * i;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">sum[i][<span class="number">0</span>] = sum[i + <span class="number">1</span>][<span class="number">0</span>] + val[i][<span class="number">0</span>];</span><br><span class="line">sum[i][<span class="number">1</span>] = sum[i + <span class="number">1</span>][<span class="number">1</span>] + val[i][<span class="number">1</span>];</span><br><span class="line">nxt[i][<span class="number">0</span>] = nxt[i + <span class="number">1</span>][<span class="number">0</span>] + val[i][<span class="number">0</span>] * i;</span><br><span class="line">nxt[i][<span class="number">1</span>] = nxt[i + <span class="number">1</span>][<span class="number">1</span>] + val[i][<span class="number">1</span>] * i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>)) * val[i][<span class="number">0</span>];</span><br><span class="line">f[i][<span class="number">1</span>] = f[i][<span class="number">0</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">1</span>) * val[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>)) * val[i][<span class="number">1</span>];</span><br><span class="line">f[i][<span class="number">0</span>] = f[i][<span class="number">1</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">1</span>) * val[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for(int i = 1; i &lt;= n; ++i)&#123;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;"sum"&lt;&lt;sum[i][0]&lt;&lt; " "&lt;&lt;sum[i][1]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;"nxt"&lt;&lt;nxt[i][0]&lt;&lt; " "&lt;&lt;nxt[i][1]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(i &amp; <span class="number">1</span>))&#123;</span><br><span class="line">g[i][<span class="number">1</span>] = nxt[i][<span class="number">1</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) - i) * sum[i][<span class="number">1</span>];</span><br><span class="line">g[i][<span class="number">1</span>] += (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">2</span> * n - i + <span class="number">1</span>) * sum[i][<span class="number">0</span>] - nxt[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">g[i][<span class="number">0</span>] = nxt[i][<span class="number">0</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) - i) * sum[i][<span class="number">0</span>];</span><br><span class="line">g[i][<span class="number">0</span>] += (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">2</span> * n - i + <span class="number">1</span>) * sum[i][<span class="number">1</span>] - nxt[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for(int i = 1; i &lt;= n; ++i)&#123;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;"!!"&lt;&lt;f[i][0]&lt;&lt; " "&lt;&lt;f[i][1]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;g[i][0]&lt;&lt; " "&lt;&lt;g[i][1]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;f[i][1]&lt;&lt; " "&lt;&lt;g[i + 1][1]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;f[i][0]&lt;&lt; " "&lt;&lt;g[i + 1][0]&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">ans = max(ans, f[i][<span class="number">1</span>] + g[i + <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ans = max(ans, f[i][<span class="number">0</span>] + g[i + <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF467C-George-and-Job"><a href="#CF467C-George-and-Job" class="headerlink" title="CF467C George and Job"></a>CF467C George and Job</h2><p><a href="https://www.luogu.org/problem/CF467C" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一组有$n$个整数的数列$p_1,p_2,…,p_n$，你需要挑出$k$组长度为$m$的数，要求这些数互不重叠，即：$[l_1,r_1],[l_2,r_2],…,<a href="1 \le l_1 \le r_1 &lt; l_2 \le r_2 &lt; ... &lt; l_k \le r_k \le n; r_i-l_i+1=m">l_k,r_k</a>$ 且使选出的数和值最大</p><h3 id="大体思路-3"><a href="#大体思路-3" class="headerlink" title="大体思路"></a>大体思路</h3><p>直接依照题意dp即可。<br><br>设$f[i][j]$为当前在第$i$位，选了$j$个区间时的最大值，$s[i]$为以$i$为起始点的长度为$m$的权值之和 <br><br>转移为：$f[i][j]=max(f[i-1][j],f[i-m][j-1]+s[i])$</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5010</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>;<span class="keyword">char</span> gc;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line"><span class="keyword">if</span>(!(ch ^<span class="string">'-'</span>))f = <span class="number">-1</span>, gc;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line"><span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">readll</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>, f = <span class="number">1</span>;<span class="keyword">char</span> gc;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line"><span class="keyword">if</span>(!(ch ^<span class="string">'-'</span>))f = <span class="number">-1</span>, gc;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line"><span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> p[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[maxn][maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">n = read(), m = read(), k = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">p[i] = readll();</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt;= n; ++i)&#123;</span><br><span class="line">s[i] = sum[i] - sum[i - m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k &amp;&amp; j * m &lt;= i; ++j)&#123;</span><br><span class="line">f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">f[i][j] = max(f[i][j], f[i - m][j - <span class="number">1</span>] + s[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f[n][k]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019.7题解综合1 —— 并查集与分治</title>
      <link href="/2019/08/01/2019-7%E9%A2%98%E8%A7%A3%E7%BB%BC%E5%90%88/"/>
      <url>/2019/08/01/2019-7%E9%A2%98%E8%A7%A3%E7%BB%BC%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>第一次在外面参加这么长时间的集训… 被各路大佬摧残…<br><a id="more"></a></p><h1 id="7-25-并查集相关"><a href="#7-25-并查集相关" class="headerlink" title="7.25 并查集相关"></a>7.25 并查集相关</h1><h2 id="CF468b-TWOSETS"><a href="#CF468b-TWOSETS" class="headerlink" title="CF468b TWOSETS"></a>CF468b TWOSETS</h2><p><a href="https://www.luogu.org/problem/CF468B" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出 $n$ 个各不相同的数字，将它们分别放入 $A$ 和 $B$ 两个集合中，使它们满足：</p><blockquote><p>若数字 $x$ 在集合 $A$ 中，那么数字 $a-x$ 也在集合 $A$ 中；<br><br>若数字 $x$ 在集合 $B$ 中，那么数字 $b-x$ 也在集合 $B$ 中。<br></p></blockquote><h3 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h3><p>分为以下几种情况</p><blockquote><p>1.$a-x$与$b-x$有一个存在<br><br>$a-x$与$b-x$都不存在<br><br>$a-x$与$b-x$都存在<br></p></blockquote><p>很显然，$a-(a-x)=x$,因此如果$a-x(b-x)$不在给定的集合中，则$x$就只能在$B(A)$中（注意顺序）。而如果$a-x$与$b-x$都不存在，便会无解。<br><br>重点在于情况三，如果$a-x$与$b-x$都存在，那么$x$在哪个集合都可以，这时候决定$x$在哪里的并不是$x$本身，而是与$a-x$与$b-x$有关的数。<br><br>综合以上情况，考虑用并查集维护。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>;<span class="keyword">char</span> gc;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>,gc;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line"><span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> pos[maxn];</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findx</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = findx(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fi = findx(x), fj = findx(y);</span><br><span class="line"><span class="keyword">if</span>(fi != fj)</span><br><span class="line">fa[fi] = fj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = read(), a = read(), b = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">pos[i] = read();</span><br><span class="line">mp[pos[i]] = i;</span><br><span class="line">fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">x = n + <span class="number">1</span>, y = n + <span class="number">2</span>;</span><br><span class="line">fa[x] = x, fa[y] = y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;pos[i]&lt;&lt;"  "&lt;&lt;a-pos[i]&lt;&lt; " "&lt;&lt;b-pos[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;"!!"&lt;&lt;mp[a - pos[i]]&lt;&lt; " "&lt;&lt;mp[b - pos[i]]&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(!mp[a - pos[i]])&#123;</span><br><span class="line">merge(i, y);</span><br><span class="line"><span class="comment">// merge(mp[])</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">merge(mp[a - pos[i]], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!mp[b - pos[i]])&#123;</span><br><span class="line">merge(i, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">merge(mp[b - pos[i]], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cout&lt;&lt;findx(i)&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x1 = findx(x), x2 = findx(y);</span><br><span class="line"><span class="keyword">if</span>(x1 == x2)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;findx(i)&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(findx(i) == x1)<span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"1"</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="luogu-P3295-SCOI2016-萌萌哒"><a href="#luogu-P3295-SCOI2016-萌萌哒" class="headerlink" title="luogu P3295 [SCOI2016]萌萌哒"></a>luogu P3295 [SCOI2016]萌萌哒</h2><p><a href="https://www.luogu.org/problem/P3295" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个序列$S$的长度为$n$以及$m$对区间$(l_1,r_1,l_2,r_2)$知每一对区间中的每个数都相同，求最终序列的方案数。</p><h3 id="大体思路-1"><a href="#大体思路-1" class="headerlink" title="大体思路"></a>大体思路</h3><p>有$m$对区间，每对区间中的每个数都相同。因为最终要求的是方案数，不用考虑单独的一种方案，考虑使用并查集维护，将每一对区间中的每一对数塞到一个并查集内部，最终答案就是$10^x＊９$($ｘ$为并查集的总数)。<br><br>此时合并的复杂度最差为$O(n^2)$，但是查询的复杂度仅为$O(n)$，无法接受。<br><br>然后通过细（<del>看</del>）致（<del>了</del>）思（<del>题</del>）考（<del>解</del>），发现可以使用类似ST表的倍增进行解决。设$id[j][i]$表示以$i$为左端点，长度为$2^j$的区间的编号，在合并时，直接合并代表两段区间的$(logn)$个区间即可。查询时，因为查询的是原始的$n$个节点，所以需要针对一段区间，将其合并下放。（实现方式与st表类似）。此时合并$O(logn)$，查询$O(logn)$，可以通过。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> tot, l1, r1, l2, r2;</span><br><span class="line"><span class="keyword">int</span> id[<span class="number">30</span>][maxn], num[maxn * <span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> fa[maxn * <span class="number">30</span>], h[maxn * <span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> bin[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findx</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = findx(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fi = findx(x), fj = findx(y);</span><br><span class="line"><span class="keyword">if</span>(h[fi] &gt; h[fj])&#123;</span><br><span class="line">swap(fi, fj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(h[fi] == h[fj])h[fj] ++;</span><br><span class="line">fa[fi] = fj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll now, ll a)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>, base = now;</span><br><span class="line"><span class="keyword">while</span>(a)&#123;</span><br><span class="line"><span class="keyword">if</span>(a &amp; <span class="number">1</span>)</span><br><span class="line">res = (<span class="number">1l</span>l * res * base) % mod;</span><br><span class="line">base = (<span class="number">1l</span>l * base * base) % mod;</span><br><span class="line">a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">bin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= <span class="number">20</span>; ++p)&#123;</span><br><span class="line">bin[p] = (bin[p - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">20</span>; ++j)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">id[j][i] = ++tot, num[tot] = i;</span><br><span class="line">fa[tot] = tot, h[tot] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">20</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line"><span class="keyword">if</span>(l1 + bin[j] - <span class="number">1</span> &lt;= r1)&#123;</span><br><span class="line">merge(id[j][l1], id[j][l2]);</span><br><span class="line">l1 += bin[j], l2 += bin[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cout&lt;&lt;1&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">20</span>; j; --j)&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;j&lt;&lt; " ";</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + bin[j] - <span class="number">1</span> &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">int</span> x = findx(id[j][i]), a = num[x];</span><br><span class="line">merge(id[j - <span class="number">1</span>][a], id[j - <span class="number">1</span>][i]);</span><br><span class="line">merge(id[j - <span class="number">1</span>][a + bin[j - <span class="number">1</span>]], id[j - <span class="number">1</span>][i + bin[j - <span class="number">1</span>]]);</span><br><span class="line"><span class="comment">// cout&lt;&lt;"j"&lt;&lt;j&lt;&lt; " "&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cout&lt;&lt;1&lt;&lt;endl;</span></span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(findx(id[<span class="number">0</span>][i]) == id[<span class="number">0</span>][i])cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(<span class="number">9l</span>l * ksm(<span class="number">10</span>, cnt - <span class="number">1</span>)) % mod;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-25-分治相关"><a href="#7-25-分治相关" class="headerlink" title="7.25 分治相关"></a>7.25 分治相关</h1><h2 id="luogu-P1429-平面最近点对（加强版）"><a href="#luogu-P1429-平面最近点对（加强版）" class="headerlink" title="luogu P1429 平面最近点对（加强版）"></a>luogu P1429 平面最近点对（加强版）</h2><p><a href="https://www.luogu.org/problem/P1429" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>平面上有$n$个点$(2≤n≤200000)$，求距离最近的点对</p><h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h3><p>考虑直接枚举$n$个点，$O(n^2)$显然不可做。。。。<br><br>考虑分治，将平面沿$x$坐标的中位数裁开，这样要求的解被分成三类。</p><blockquote><p>1.在左侧的解<br><br>2.在右侧的解<br><br>3.横跨分割线的解<br></p></blockquote><p>解1与解2分开递归计算即可，重点考虑解3如何处理。<br><br>然后发现了一种优美的性质。<strong>对于一个点来说，其要想和横跨分治边界的另一个点更新最优解，最多只有$6$个点符合要求。</strong><br><br>设左侧的递归答案为$d1$，右侧的递归答案为$d2$，则当前最优解为$\delta=min(d1,d2)$,如果要想使$dis(x,y) &lt; \delta$，很明显另一个点的取值只能是一个$[\delta,2<em>\delta]$的矩形，又因为$\delta=min(d1,d2)$，则右侧每两个点之间的距离$dis\le\delta$，也就是说，最多只能有$6$个点被选择。<br><br>先按$x$轴第一关键字，$y$轴第二关键字排序,<br>每一层分治的复杂度为$O(6</em>n)$，总复杂度$O(logn)$。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">2</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> x, y;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">int</span> tmp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(node &amp;a, node &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">int</span> &amp;i, <span class="keyword">int</span> &amp;j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a[i].y &lt; a[j].y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> d = inf;</span><br><span class="line"><span class="keyword">if</span>(l == r)<span class="keyword">return</span> d;</span><br><span class="line"><span class="keyword">if</span>(l + <span class="number">1</span> == r)<span class="keyword">return</span> dist(l, r);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> d1 = merge(l, mid);</span><br><span class="line"><span class="keyword">double</span> d2 = merge(mid + <span class="number">1</span>, r);</span><br><span class="line">d = min(d1, d2);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(a[mid].x - a[i].x) &lt; d)&#123;</span><br><span class="line">tmp[++cnt] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(tmp + <span class="number">1</span>, tmp + cnt + <span class="number">1</span>, cmp2);</span><br><span class="line"><span class="keyword">double</span> d3;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">fabs</span>(a[tmp[j]].y - a[tmp[i]].y) &lt; d; j++)&#123;</span><br><span class="line">d3 = dist(tmp[i], tmp[j]);</span><br><span class="line"><span class="keyword">if</span>(d &gt; d3)d = d3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.4lf"</span>, merge(<span class="number">1</span>, n));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新式骗分——模拟退火</title>
      <link href="/2019/06/14/%E6%96%B0%E5%BC%8F%E9%AA%97%E5%88%86%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"/>
      <url>/2019/06/14/%E6%96%B0%E5%BC%8F%E9%AA%97%E5%88%86%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/</url>
      
        <content type="html"><![CDATA[<p>博客咕咕咕的时间有点长(似乎是太长了)</p><p>今天写一下模拟退火吧。。。发现了骗分的新大陆</p><!-- （!--似乎是太长了--!） --><a id="more"></a><h1 id="一：背景"><a href="#一：背景" class="headerlink" title="一：背景"></a>一：背景</h1><h3 id="模拟退火解决的是一种什么样的问题呢？"><a href="#模拟退火解决的是一种什么样的问题呢？" class="headerlink" title="模拟退火解决的是一种什么样的问题呢？"></a>模拟退火解决的是一种什么样的问题呢？</h3><blockquote><p>模拟退火算法（Simulate Anneal，SA）是一种通用概率演算法， <strong>用来在一个大的搜寻空间内找寻命题的最优解。</strong> 模拟退火是由S.Kirkpatrick, C.D.Gelatt和&gt;M.P.Vecchi在1983年所发明的。V.Čern&yacute;在1985年也独立发明此演算法。模&gt;拟退火算法是解决TSP问题的有效方法之一。<br>—— 来自百度百科</p></blockquote><p>照例引用百度百科。</p><p> 其实模拟退火就是一种解决问题的普遍方法。</p><h1 id="二：爬山算法及其优化"><a href="#二：爬山算法及其优化" class="headerlink" title="二：爬山算法及其优化"></a>二：爬山算法及其优化</h1><p> 针对一个求最值的问题，我们可以采用一种贪心的方法，被称作“爬山算法”。爬山算法指的就是每一步都将当前节点的值与其邻居节点比较，如果有更优值就取，否则就维持当前的解。很明显，这个算法可以找到一个局部最优解。但是其有一个致命的缺陷，那就是只能找到局部最优解，但是并不能保证找到的解是一个全局最优解。</p><p> <img src="https://s2.ax1x.com/2019/07/26/euJztA.png" alt="euJztA.png"></p><p> 就比如说上面这个图，当我们在D点出发，使用爬山算法，即可到达B点，很明显这既是局部最优解，又是全局最优解。但是如果从C点或E点出发，我们最后会到达A点，（<del>然后愉快的WA</del>）<br> 这种做法很明显是不行的，那么怎么使其变的正确 或者说大约正确呢？<br> 上文提到的三位大佬想出来了一个绝妙的解决方案：<br> 使用随机算法，使得每一次搜索到比当前解差的解时，都有一定概率接受这个解。但是光随机也是不行的，所以随着循环次数的增加，会不断降低接受更劣解的概率。这就是模拟退火的主要思想。</p><h1 id="三：具体实现"><a href="#三：具体实现" class="headerlink" title="三：具体实现"></a>三：具体实现</h1><p> 先定义一下变量及数组</p><blockquote><p>t: 温度 决定了接受更劣解的概率 与down一起决定了退火的时长 更高的初始温度意味着更精确的答案， 但也意味着需要更多的时间<br><br>down: 每一次循环降低t的系数，一般是 0.9 ~ 1 的一个实数<br><br>delta: 当前解与最优解的差<br><br>now_w: 目前得到的最优解<br><br>ew：当前解</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><p>1.透过最优解计算出当前解。<br><br>2.如果获得了更优解 直接接受<br>3.更劣解有概率接受<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">sa</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> t = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">while</span>(t &gt; <span class="number">1e-15</span>)&#123;</span><br><span class="line"><span class="keyword">double</span> ex = ans_x + (rand() * <span class="number">2</span> - RAND_MAX) * t;</span><br><span class="line"><span class="keyword">double</span> ey = ans_y + (rand() * <span class="number">2</span> - RAND_MAX) * t;</span><br><span class="line"><span class="keyword">double</span> ew = get_eng(ex, ey);<span class="comment">//构造解的函数</span></span><br><span class="line"><span class="keyword">double</span> delta = ew - ans_w;</span><br><span class="line"><span class="keyword">if</span>(delta &lt; <span class="number">0</span>)&#123;</span><br><span class="line">ans_x = ex;</span><br><span class="line">ans_y = ey;</span><br><span class="line">ans_w = ew;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>(-delta / t) * RAND_MAX &gt; rand())&#123;</span><br><span class="line">ans_x = ex;</span><br><span class="line">ans_y = ey;</span><br><span class="line">&#125;</span><br><span class="line">t *= down;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>来自luoguP1337 [JSOI2004]平衡点 / 吊打XXX</p></blockquote><p> 值得注意的几个点：</p><blockquote><p>(rand() <em> 2 - RAND_MAX) </em> t : 求新解的方法<br><br>exp(-delta / t) * RAND_MAX &gt; rand()  : 来自前人的玄学判断</p></blockquote><p> <img src="https://s2.ax1x.com/2019/07/26/eu1JDH.png" alt="eu1JDH.png"></p><blockquote><p>模拟退火流程图</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可爱的数据结构——线段树</title>
      <link href="/2019/03/30/%E5%8F%AF%E7%88%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2019/03/30/%E5%8F%AF%E7%88%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="可爱的数据结构——线段树"><a href="#可爱的数据结构——线段树" class="headerlink" title="可爱的数据结构——线段树"></a>可爱的数据结构——线段树</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是数据结构呢？"><a href="#什么是数据结构呢？" class="headerlink" title="什么是数据结构呢？"></a>什么是数据结构呢？</h3><blockquote><p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关 </p><p>—-来自百度百科<br><a id="more"></a><br>简单来说，数据结构就是通过合理的方式在计算机中存储数据，来达到修改、查询的目的。</p></blockquote><p><strong>几个例子</strong><br>（纯个人看法）</p><p>朴素的数据结构</p><pre><code>数组（-_-）链表队列栈</code></pre><p>看起来高端一些的数据结构</p><pre><code>矩阵哈希表（hash）堆树状数组</code></pre><p>更高级的数据结构    </p><pre><code>线段树各种平衡树主席树</code></pre><h3 id="什么是线段树呢？"><a href="#什么是线段树呢？" class="headerlink" title="什么是线段树呢？"></a>什么是线段树呢？</h3><blockquote><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p><p>—-依然来自百度百科</p></blockquote><p>换句话说，就是把一个区间变成一个多层的树形结构，以一种二分与递归的思想实现高效的区间操作</p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>写一个数据结构，要求支持在O(logn)的时间复杂度内支持区间加与区间和。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流初识———EK</title>
      <link href="/2018/12/16/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%88%9D%E8%AF%86%E2%80%94%E2%80%94EK/"/>
      <url>/2018/12/16/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%88%9D%E8%AF%86%E2%80%94%E2%80%94EK/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当初刚开始学OI的时候，对各种奇怪的中高级算法抱有极大的兴趣（结果自然是看不懂-_-），网络流则是排在前列的几大算法之一（话说我是如何在连建图和SPFA都搞不明白的情况下看进去的…）。</p><p>如今过了一年（技术还是没有什么长进，该不会的还是不会），重新看了一篇网络流与费用流，似乎。。。有那么一点理解了，谨以此文，来表达我对网络流的一点看法。</p><h1 id="什么是网络流？"><a href="#什么是网络流？" class="headerlink" title="什么是网络流？"></a>什么是网络流？</h1><p>“网络流(network-flows)是一种类比水流的解决问题方法，与线性规划密切相关。”（来自百度百科）</p><p>举个例子，从某地要向某地输水，中间有许多粗细不同的管子，网络流算法解决的就是利用这些管子怎样使单位时间总输送量最大化的问题。 </p><a id="more"></a><h1 id="如何解决网络流问题？"><a href="#如何解决网络流问题？" class="headerlink" title="如何解决网络流问题？"></a>如何解决网络流问题？</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>会建图，会dfs、bfs（似乎只需要这些。。。）</p><h2 id="在开始之前…"><a href="#在开始之前…" class="headerlink" title="在开始之前…"></a>在开始之前…</h2><p>我们先来明晰几个概念：</p><p><strong>点的属性：</strong></p><pre><code>  源点(s): 一切的开始，入度为0  汇点(t): 一切的结束，出度为0</code></pre><p><strong>边的属性：</strong></p><pre><code>首先很明显图应该是DAG流量(flow)：每条边能通过的最大值</code></pre><h2 id="如何建图？"><a href="#如何建图？" class="headerlink" title="如何建图？"></a>如何建图？</h2><p>先不负责任的提出解决方案：对于每一条有向边，建一条与之方向相反（出入点相反），流量为0的边。</p><p><strong>为什么？</strong></p><p>我们先来明确一下网络流的工作原理：</p><p>每一次搜索结束后，便会找到一条从源点到汇点的路径（这条路径叫增广路），且该路径上的边的流量均大于0，通过这条路可以增加的流量便是这条路径中的最小流量（自行理解一下）。然后在每次搜索结束时，将这条路径上的边的流量减去可以增加的流量。重复此过程直到找不出路径为止。</p><p>这种看起来就像是贪心的算法很明显是错的… 你搜索到的流量会与你搜索的路径的顺序有关，这怎么行！</p><p>所以在建图时，要采用上文所述的方式，建一条反向边，并且在搜索完毕后减去增加流量的同时，在反向边加上增加的流量，这样在下一次搜索增广路时可以沿着反向边把流量回退，从而实现发现真正意义上的最大流的目的。</p><h1 id="上代码！"><a href="#上代码！" class="headerlink" title="上代码！"></a>上代码！</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">51000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p, m, f, u, v;</span><br><span class="line"><span class="keyword">int</span> s, t;</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nt, to, flow, val;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">        nt = n, to = t, flow = f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> h[maxn], c[maxn], tot = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;e[++tot].<span class="built_in">set</span>(h[a], b, c), h[a] = tot; e[++tot].<span class="built_in">set</span>(h[b], a, <span class="number">0</span>), h[b] = tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> dis[maxn], vis[maxn], pre[maxn], last[maxn], flow[maxn]; <span class="comment">//存路径和更新的流量</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)pre[i] = <span class="number">-1</span>, vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(last, <span class="number">-1</span>, <span class="keyword">sizeof</span>(last));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">    q.push(s);</span><br><span class="line">    pre[s] = inf;</span><br><span class="line">    flow[s] = inf;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[now]; i != <span class="number">-1</span>; i = e[i].nt)&#123;</span><br><span class="line">            <span class="keyword">int</span> nex = e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(e[i].flow &gt; <span class="number">0</span> &amp;&amp; vis[nex] == <span class="number">0</span>)&#123;</span><br><span class="line">                pre[nex] = now;</span><br><span class="line">                last[nex] = i;</span><br><span class="line">                <span class="keyword">if</span>(e[i].flow &lt; flow[now])</span><br><span class="line">                    flow[nex] = e[i].flow;</span><br><span class="line">                <span class="keyword">else</span> flow[nex] = flow[now];</span><br><span class="line">                <span class="keyword">if</span>(!vis[nex])&#123;</span><br><span class="line">                    vis[nex] = <span class="number">1</span>;</span><br><span class="line">                    q.push(nex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[t] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ek</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s, t))&#123;</span><br><span class="line">        maxflow += flow[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pre[i])&#123;</span><br><span class="line">            e[last[i]].flow -= flow[t];</span><br><span class="line">            e[last[i] ^ <span class="number">1</span>].flow += flow[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) h[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> u, v, f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u,&amp;v,&amp;f);</span><br><span class="line">        adde(u, v, f);</span><br><span class="line">    &#125;</span><br><span class="line">    ek(s, t);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxflow&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
