<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>初赛后扯淡</title>
    <url>/2019/10/23/%E5%88%9D%E8%B5%9B%E5%90%8E%E6%89%AF%E6%B7%A1/</url>
    <content><![CDATA[<h1 id="扯淡"><a href="#扯淡" class="headerlink" title="扯淡"></a>扯淡</h1><p>话说似乎要初赛退役了。</p>
<p>哎。<br><a id="more"></a></p>
<p>都在说自己要是当初再努力一点就好了。</p>
<p>但是如果真的让你回到当初，你还是会做出一样的选择对吧。</p>
<p>你始终认为自己还有机会，但是事实却并非总是如你所愿。</p>
<p>毕竟开始了就没什么可后悔的。</p>
<p>时间浪费了这么多，到头来还是碌碌无为。</p>
<p>真的只能是这样了吗？</p>
<p>别人都在努力的往前奔跑，只有你还躺在床上抱怨不想起床。</p>
<p>哎，根本就没有别的东西可以让你去责怪。</p>
<p>你要是每天都拼命学习，还会有时间去多愁善感吗？</p>
<p>我不知道。</p>
<p>但我知道你总会选择站起来的，哪怕你总是明的暗的想要从窗口离开这世界。</p>
<p>结果还是每天笑嘻嘻的，浑浑噩噩的度日。</p>
<p>我希望你有一天能喊出“我受够了，我要改变。”</p>
<p>因为早就没有退路可走了。</p>
<p>逃避永远不是解决办法。</p>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>DsuOnTree</title>
    <url>/2019/10/23/DsuOnTree/</url>
    <content><![CDATA[<h1 id="dsu-on-tree"><a href="#dsu-on-tree" class="headerlink" title="dsu on tree"></a>dsu on tree</h1><a id="more"></a>
<h2 id="这是什么？"><a href="#这是什么？" class="headerlink" title="这是什么？"></a>这是什么？</h2><p>dsu on tree 指的是“树上启发式合并”。（<del>和并查集没有关系</del>）</p>
<p>解决的是一类不带修改的子树统计问题。</p>
<h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><p>一棵有根树，每一个节点上都有一个颜色。</p>
<p>求每一个节点i的子树中出现颜色为k的节点。</p>
<h3 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h3><p>可以很简单的得到一个（ $n^2$ ）的做法，从每个点开始dfs一遍就完了。</p>
<p>当然你也可以dfs序+主席树水过，但是此做法不在本博客讨论范围内。</p>
<p>考虑一下暴力的过程。</p>
<p>我们对于每个节点，暴力地通过dfs统计出其子树中的答案，再暴力地删除贡献，计算下一个节点。</p>
<p>这个过程中很明显进行了一堆重复的操作。</p>
<p>如何优化呢？</p>
<p>有一个很妙的想法（即dsu on tree），参照了重链剖分的思路。</p>
<p>那就是求出每个点的重儿子，然后先递归进入每一个点的轻儿子统计答案，随后消除其影响。</p>
<p>再针对重儿子统计答案，但是不消除其影响。</p>
<p>最后再得出该点的贡献。</p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ul>
<li><p>剖出重儿子与轻儿子</p>
</li>
<li><p>递归进入轻儿子统计答案并消除影响</p>
</li>
<li><p>进入重儿子统计答案，不消除影响</p>
</li>
<li><p>统计该点贡献</p>
</li>
<li><p>如果该点是轻儿子，那么消除其影响</p>
</li>
</ul>
<p>代码长这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> opt)</span></span>&#123;<span class="comment">//①</span></span><br><span class="line">fre(i, now)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex == fa[now] || nex == son[now])<span class="keyword">continue</span>;</span><br><span class="line">dfs(nex, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(son[now])dfs(son[now], <span class="number">1</span>);</span><br><span class="line">pos = son[now];</span><br><span class="line">calc(son[now], <span class="number">1</span>);<span class="comment">//②</span></span><br><span class="line">pos = <span class="number">0</span>;</span><br><span class="line">ans[now] = sum;</span><br><span class="line"><span class="keyword">if</span>(!opt)&#123;</span><br><span class="line">clac(now, <span class="number">-1</span>);<span class="comment">//③</span></span><br><span class="line">sum = maxx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①：opt == 1 表示不清除当前点的影响， opt == 0 表示清除影响</p>
<p>②：表示计算重儿子贡献并不清除dfs</p>
<p>③：表示去除轻儿子贡献</p>
<h2 id="复杂度计算"><a href="#复杂度计算" class="headerlink" title="复杂度计算"></a>复杂度计算</h2><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="CF666E-Lomsat-gelral"><a href="#CF666E-Lomsat-gelral" class="headerlink" title="CF666E Lomsat gelral"></a>CF666E Lomsat gelral</h3><p><a href="https://www.luogu.org/problem/CF600E" target="_blank" rel="noopener">题目传送门</a></p>
<p>一棵树有n个结点，每个结点都是一种颜色，每个颜色有一个编号，求树中每个子树的最多的颜色编号的和。</p>
<p>其实就是例题，直接dfs暴力统计就可以了。<br>代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(i, j, k) for(register int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rf(i, j, k) for(register int i = j; i &gt;= k; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fre(i, now) for(register int i = h[now], nex = to[i]; i; i = nt[i], nex = to[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> gc;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line"><span class="keyword">if</span>(!(ch ^ <span class="string">'-'</span>))f = <span class="number">-1</span>, gc;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line"><span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> to[maxn &lt;&lt; <span class="number">1</span>], nt[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">to[++tot] = b, nt[tot] = h[a], h[a] = tot;</span><br><span class="line">to[++tot] = a, nt[tot] = h[b], h[b] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> son[maxn], fa[maxn], siz[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;now&lt;&lt; " "&lt;&lt;f&lt;&lt;endl;</span></span><br><span class="line">fa[now] = f;</span><br><span class="line">siz[now] = <span class="number">1</span>;</span><br><span class="line">fre(i, now)&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;"hhhh"&lt;&lt;to[i]&lt;&lt;" "&lt;&lt;nex&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(nex == f)<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// cout&lt;&lt;"!!"&lt;&lt;f&lt;&lt;" "&lt;&lt;nex&lt;&lt; " "&lt;&lt;now&lt;&lt;endl;</span></span><br><span class="line">dfs1(nex, now);</span><br><span class="line">siz[now] += siz[nex];</span><br><span class="line"><span class="keyword">if</span>(!son[now] || (siz[son[now]] &lt; siz[nex]))son[now] = nex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn], cor[maxn];</span><br><span class="line"><span class="keyword">int</span> now_son, maxx;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">cnt[cor[now]] += val;</span><br><span class="line"><span class="keyword">if</span>(cnt[cor[now]] &gt; maxx)&#123;maxx = cnt[cor[now]];sum = cor[now];&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt[cor[now]] == maxx)&#123;sum += (<span class="keyword">long</span> <span class="keyword">long</span>)cor[now];&#125;</span><br><span class="line">fre(i, now)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex == fa[now] || nex == now_son)<span class="keyword">continue</span>;</span><br><span class="line">add(nex, val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> opt)</span></span>&#123;</span><br><span class="line">fre(i, now)&#123;</span><br><span class="line"><span class="keyword">if</span>(nex == fa[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(nex != son[now])dfs2(nex, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(son[now]) dfs2(son[now], <span class="number">1</span>), now_son = son[now];</span><br><span class="line">add(now, <span class="number">1</span>);</span><br><span class="line">now_son = <span class="number">0</span>;</span><br><span class="line">ans[now] = sum;</span><br><span class="line"><span class="keyword">if</span>(!opt)&#123;</span><br><span class="line">add(now, <span class="number">-1</span>);</span><br><span class="line">sum = <span class="number">0</span>, maxx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">fr(i, <span class="number">1</span>, n)&#123;</span><br><span class="line">cor[i] = read();</span><br><span class="line">&#125;</span><br><span class="line">fr(i, <span class="number">1</span>, n - <span class="number">1</span>)&#123;</span><br><span class="line">x = read(), y = read();</span><br><span class="line">adde(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fr(i, 1, n)&#123;</span></span><br><span class="line"><span class="comment">// fre(j, i)&#123;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;i&lt;&lt; " "&lt;&lt;nt[j]&lt;&lt; " "&lt;&lt;to[j]&lt;&lt; " "&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// fr(i, 1, n)&#123;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;siz[i]&lt;&lt; " "&lt;&lt;son[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">fr(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d "</span>, ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CF741D（题目太长不贴了）"><a href="#CF741D（题目太长不贴了）" class="headerlink" title="CF741D（题目太长不贴了）"></a>CF741D（题目太长不贴了）</h3><p><a href="https://www.luogu.org/problem/CF741D" target="_blank" rel="noopener">题目传送门</a></p>
<p>一棵根为1 的树，每条边上有一个字符（a-v共22种）。</p>
<p>一条简单路径被称为Dokhtar-kosh当且仅当路径上的字符经过重新排序后可以变成一个回文串。</p>
<p>求每个子树中最长的Dokhtar-kosh路径的长度。</p>
<p>字符范围只有[0, 22]，考虑状压。</p>
<p>进一步分析，当且仅当所有字符都出现偶数次或者只有一个字符出现奇数次时才合法。</p>
<p>也就是说状压之后为2的幂次的路径才是合法的。</p>
<p>我们的目标就是对于每个点x，在其子树中找到点a，b。</p>
<p>使得d[a] ^ d[b] 为2的幂次且dep[a] + dep[b] - dep[lca] * 2 最大。</p>
<p>（d[i]指的是状压之后从1到i的路径）</p>
<p>使用dsu on tree 解决即可。</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(i, j, k) for(register int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rf(i, j, k) for(register int i = j; i &gt;= k; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fre(i, now) for(register int i = h[now]; i; i = nt[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> gc;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>, gc;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line"><span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> to[maxn &lt;&lt; <span class="number">1</span>], nt[maxn &lt;&lt; <span class="number">1</span>], val[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">to[++tot] = b, nt[tot] = h[a], val[tot] = c, h[a] = tot;</span><br><span class="line">to[++tot] = a, nt[tot] = h[b], val[tot] = c, h[b] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d[maxn], fa[maxn], siz[maxn], son[maxn], dep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> ff)</span></span>&#123;</span><br><span class="line">fa[now] = ff, siz[now] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cout&lt;&lt;now&lt;&lt; " "&lt;&lt;ff&lt;&lt;endl;</span></span><br><span class="line">fre(i, now)&#123;</span><br><span class="line"><span class="keyword">int</span> nex = to[i];</span><br><span class="line"><span class="keyword">if</span>(nex == ff)<span class="keyword">continue</span>;</span><br><span class="line">d[nex] = d[now] ^ (<span class="number">1</span> &lt;&lt; val[i]);</span><br><span class="line">dep[nex] = dep[now] + <span class="number">1</span>;</span><br><span class="line">dfs1(nex, now);</span><br><span class="line">siz[now] += siz[nex];</span><br><span class="line"><span class="keyword">if</span>(!son[now] || siz[son[now]] &lt; siz[nex])son[now] = nex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ccf[<span class="number">1</span> &lt;&lt; <span class="number">22</span>], maxx, last, ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">ccf[d[u]] = max(dep[u], ccf[d[u]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ccf[d[now]])&#123;maxx = max(maxx, dep[now] + ccf[d[now]] - last);&#125;</span><br><span class="line">fr(i, <span class="number">0</span>, <span class="number">21</span>)<span class="keyword">if</span>(ccf[(<span class="number">1</span> &lt;&lt; i) ^ d[now]])&#123;maxx = max(maxx, dep[now] + ccf[(<span class="number">1</span> &lt;&lt; i) ^ d[now]] - last);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getup</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">update(now);</span><br><span class="line">fre(i, now)&#123;</span><br><span class="line"><span class="keyword">int</span> nex = to[i];</span><br><span class="line"><span class="keyword">if</span>(nex == fa[now])<span class="keyword">continue</span>;</span><br><span class="line">getup(nex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getcal</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">cal(now);</span><br><span class="line">fre(i, now)&#123;</span><br><span class="line"><span class="keyword">int</span> nex = to[i];</span><br><span class="line"><span class="keyword">if</span>(nex == fa[now])<span class="keyword">continue</span>;</span><br><span class="line">getcal(nex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">ccf[d[now]] = <span class="number">0</span>;</span><br><span class="line">fre(i, now)&#123;</span><br><span class="line"><span class="keyword">int</span> nex = to[i];</span><br><span class="line"><span class="keyword">if</span>(nex == fa[now])<span class="keyword">continue</span>;</span><br><span class="line">clear(nex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> opt)</span></span>&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;now&lt;&lt; " "&lt;&lt;fa[now]&lt;&lt;endl;</span></span><br><span class="line">fre(i, now)&#123;</span><br><span class="line"><span class="keyword">int</span> nex = to[i];</span><br><span class="line"><span class="keyword">if</span>(nex == fa[now] || nex == son[now])<span class="keyword">continue</span>;</span><br><span class="line">dfs2(nex, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(son[now])dfs2(son[now], <span class="number">1</span>);</span><br><span class="line">last = dep[now] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">fre(i, now)&#123;</span><br><span class="line"><span class="keyword">int</span> nex = to[i];</span><br><span class="line"><span class="keyword">if</span>(nex == fa[now])<span class="keyword">continue</span>;</span><br><span class="line">maxx = max(ans[nex], maxx);</span><br><span class="line">&#125;</span><br><span class="line">fre(i, now)&#123;</span><br><span class="line"><span class="keyword">int</span> nex = to[i];</span><br><span class="line"><span class="keyword">if</span>(nex == fa[now] || nex == son[now])<span class="keyword">continue</span>;</span><br><span class="line">getcal(nex);</span><br><span class="line">getup(nex);</span><br><span class="line">&#125;</span><br><span class="line">cal(now); update(now);</span><br><span class="line">ans[now] = maxx;</span><br><span class="line"><span class="keyword">if</span>(!opt)&#123;</span><br><span class="line">maxx = <span class="number">0</span>;</span><br><span class="line">clear(now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// freopen("test.in", "r", stdin);</span></span><br><span class="line"><span class="comment">// freopen("test.out", "w", stdout);</span></span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">char</span> z[<span class="number">15</span>];</span><br><span class="line">fr(i, <span class="number">2</span>, n)&#123;</span><br><span class="line">x = read();</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;z;</span><br><span class="line">adde(i, x, (<span class="keyword">int</span>)z[<span class="number">0</span>] - <span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">fr(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/zcysky/p/6822395.html" target="_blank" rel="noopener">https://www.cnblogs.com/zcysky/p/6822395.html</a><br><a href="https://www.cnblogs.com/zwfymqz/p/9683124.html" target="_blank" rel="noopener">https://www.cnblogs.com/zwfymqz/p/9683124.html</a></p>
<p>感谢。</p>
]]></content>
      <tags>
        <tag>树</tag>
        <tag>DsuOnTree</tag>
      </tags>
  </entry>
  <entry>
    <title>憨批线段树合并</title>
    <url>/2019/10/23/%E6%86%A8%E6%89%B9%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p>增强复用型憨憨<del>线段</del>树合并</p>
<h1 id="线段树合并"><a href="#线段树合并" class="headerlink" title="线段树合并"></a>线段树合并</h1><a id="more"></a>
<h2 id="前置芝士：动态开点线段树"><a href="#前置芝士：动态开点线段树" class="headerlink" title="前置芝士：动态开点线段树"></a>前置芝士：动态开点线段树</h2><p>线段树节省空间的一种方法，就是不一开始就建好整棵树，而是在访问到这个节点的同时再进行更新。</p>
<p>普通的线段树要在最前面加入一个build函数<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;sum[rt] = a[l]; <span class="keyword">return</span>;&#125;</span><br><span class="line">build(ls, l, mid);</span><br><span class="line">build(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">push_up(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是在动态开点线段树中却被newnode函数取代<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt; r)<span class="keyword">return</span>;</span><br><span class="line">rt = ++cnt;</span><br><span class="line">sum[rt] = r - l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并且此时由于建点没有必然顺序，所以左右儿子用ls[rt], rs[rt]表示。</p>
<p>然后以单点修改为例<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!rt)rt = newnode(rt, l, r);</span><br><span class="line"><span class="keyword">if</span>(!ls[rt])ls[rt] = newnode(ls[rt], l, mid);</span><br><span class="line"><span class="keyword">if</span>(!rs[rt])rs[rt] = newnode(rs[rt], mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum[rt] = k;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">push_down(rt, l, r);</span><br><span class="line"><span class="keyword">if</span>(pos &lt;= mid)ls[rt] = change(ls[rt], l, mid, pos, k);</span><br><span class="line"><span class="keyword">else</span> rs[rt] = change(rs[rt], mid + <span class="number">1</span>, r, pos, k);</span><br><span class="line"><span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是这样。</p>
<h2 id="线段树合并方式"><a href="#线段树合并方式" class="headerlink" title="线段树合并方式"></a>线段树合并方式</h2><p>你现在要维护一个子树中的权值最大值。</p>
<p>有两棵动态开点开出的线段树，你要把他们摁到一棵线段树里。</p>
<p>你直接递归进入两个根节点的左右儿子，重复此操作直到成为叶节点。</p>
<p>因为线段树是动态建的，所以在没有该节点时可以直接返回另一个节点的值</p>
<p>如果递归到 $ l == r $，那么就可以直接权值相加了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!a)<span class="keyword">return</span> b; <span class="keyword">if</span>(!b)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;val[a] += val[b];pos[a] = l; <span class="keyword">return</span> a;&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">ls[a] = merge(ls[a], ls[b], l, mid);</span><br><span class="line">rs[a] = merge(rs[a], rs[b], mid + <span class="number">1</span>, r);</span><br><span class="line">push_up(a);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的一点是，这样直接覆盖节点，由于b树的信息被保留在a树上，在更新时可能会导致错误。<br>因此只适用于<strong>离线做法</strong>！</p>
<p>但是如果在线段树合并的时候参考主席树的做法新建节点，就不会有问题了，缺点是非常炸空间…</p>
<h2 id="线段树合并解决的问题"><a href="#线段树合并解决的问题" class="headerlink" title="线段树合并解决的问题"></a>线段树合并解决的问题</h2><p>你有一棵树，你要解决一种子树问题，(比如子树中出现次数最多的权值)，对于每一个点都可以非常方便的写一棵线段树维护，这时候使用线段树合并进行统计就非常方便了。</p>
<p>一道例题：</p>
<h3 id="luoguP4556-Vani有约会-雨天的尾巴"><a href="#luoguP4556-Vani有约会-雨天的尾巴" class="headerlink" title="luoguP4556 [Vani有约会]雨天的尾巴"></a>luoguP4556 [Vani有约会]雨天的尾巴</h3><p><a href="https://www.luogu.org/problem/P4556" target="_blank" rel="noopener">题目传送门</a></p>
<p>针对每一个节点建立权值线段树存救济粮种类，差分后转化成单点修改，最后使用线段树合并统计答案。</p>
<p>由于本题只有128MB，所以采用覆盖节点的离线做法。</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(i, j, k) for(register int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rf(i, j, k) for(register int i = j; i &gt;= k; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fre(i, now) for(int i = h[now]; i; i = nt[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> gc;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line"><span class="keyword">if</span>(!(ch ^ <span class="string">'-'</span>))f = <span class="number">-1</span>, gc;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line"><span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxt = <span class="number">6000010</span>;</span><br><span class="line"><span class="keyword">int</span> nt[maxn &lt;&lt; <span class="number">1</span>], to[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> h[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">nt[++tot] = h[a], to[tot] = b, h[a] = tot;</span><br><span class="line">nt[++tot] = h[b], to[tot] = a, h[b] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> siz[maxn], son[maxn], dep[maxn], fa[maxn], top[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> ff)</span></span>&#123;</span><br><span class="line">fa[now] = ff, siz[now] = <span class="number">1</span>, son[now] = <span class="number">0</span>, dep[now] = dep[ff] + <span class="number">1</span>;</span><br><span class="line">fre(i, now)&#123;</span><br><span class="line"><span class="keyword">int</span> nex = to[i];</span><br><span class="line"><span class="keyword">if</span>(nex == ff)<span class="keyword">continue</span>;</span><br><span class="line">dfs1(nex, now);</span><br><span class="line">siz[now] += siz[nex];</span><br><span class="line"><span class="keyword">if</span>(!son[now] || siz[nex] &gt; siz[son[now]])son[now] = nex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">top[now] = t;</span><br><span class="line"><span class="keyword">if</span>(!son[now])<span class="keyword">return</span>;</span><br><span class="line">dfs2(son[now], t);</span><br><span class="line">fre(i, now)&#123;</span><br><span class="line"><span class="keyword">int</span> nex = to[i];</span><br><span class="line"><span class="keyword">if</span>(nex == son[now] || nex == fa[now])<span class="keyword">continue</span>;</span><br><span class="line">dfs2(nex, nex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(top[x] != top[y])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])swap(x, y);</span><br><span class="line">x = fa[top[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[x] &gt; dep[y])<span class="keyword">return</span> y;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> rt[maxn], l[maxt], r[maxt], val[maxt], pos[maxt];</span><br><span class="line"><span class="keyword">int</span> ans[maxn], x[maxn], y[maxn], z[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, R, n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(val[l[a]] &gt;= val[r[a]])val[a] = val[l[a]], pos[a] = pos[l[a]];</span><br><span class="line"><span class="keyword">else</span> val[a] = val[r[a]], pos[a] = pos[r[a]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!a) a = ++cnt;</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;val[a] += v, pos[a] = x; <span class="keyword">return</span> a;&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (x + y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= mid)&#123;l[a] = change(l[a], x, mid, p, v);&#125;</span><br><span class="line"><span class="keyword">else</span> r[a] = change(r[a], mid + <span class="number">1</span>, y, p, v);</span><br><span class="line">push_up(a);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!a)<span class="keyword">return</span> b; <span class="keyword">if</span>(!b)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;val[a] += val[b];pos[a] = x; <span class="keyword">return</span> a;&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (x + y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">l[a] = merge(l[a], l[b], x, mid);</span><br><span class="line">r[a] = merge(r[a], r[b], mid + <span class="number">1</span>, y);</span><br><span class="line">push_up(a);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">fre(i, now)&#123;</span><br><span class="line"><span class="keyword">int</span> nex = to[i];</span><br><span class="line"><span class="keyword">if</span>(nex == fa[now])<span class="keyword">continue</span>;</span><br><span class="line">get_ans(nex);</span><br><span class="line">rt[now] = merge(rt[now], rt[nex], <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(val[rt[now]])ans[now] = pos[rt[now]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = read(), m = read();</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">fr(i, <span class="number">1</span>, n - <span class="number">1</span>)&#123;</span><br><span class="line">a = read(), b = read();</span><br><span class="line">adde(a, b);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">fr(i, <span class="number">1</span>, m)&#123;</span><br><span class="line">x[i] = read(), y[i] = read(), z[i] = read();</span><br><span class="line">R = max(R, z[i]);</span><br><span class="line">&#125;</span><br><span class="line">fr(i, <span class="number">1</span>, m)&#123;</span><br><span class="line"><span class="keyword">int</span> L = lca(x[i], y[i]);</span><br><span class="line">rt[x[i]] = change(rt[x[i]], <span class="number">1</span>, R, z[i], <span class="number">1</span>);</span><br><span class="line">rt[y[i]] = change(rt[y[i]], <span class="number">1</span>, R, z[i], <span class="number">1</span>);</span><br><span class="line">rt[L] = change(rt[L], <span class="number">1</span>, R, z[i], <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(fa[L])rt[fa[L]] = change(rt[fa[L]], <span class="number">1</span>, R, z[i], <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">get_ans(<span class="number">1</span>);</span><br><span class="line">fr(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>积性函数线性筛</title>
    <url>/2019/08/19/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有关积性函数的相关性质，请参考<a href="/2019/08/09/莫比乌斯反演/">莫比乌斯反演</a>。<br><br>与线性筛关系最大的便是以下性质：</p>
<blockquote>
<p>$gcd(a,b)=1$时，满足$f(ab)=f(a)f(b)$<br><a id="more"></a></p>
</blockquote>
<h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p>首先明确一点，所有的线性筛出积性函数的方法都是通过线性筛素数实现的。</p>
<h2 id="如何筛素数？"><a href="#如何筛素数？" class="headerlink" title="如何筛素数？"></a>如何筛素数？</h2><h3 id="朴素筛法（复杂度-O-n-2-O-n-sqrt-n-）"><a href="#朴素筛法（复杂度-O-n-2-O-n-sqrt-n-）" class="headerlink" title="朴素筛法（复杂度$O(n^2)$~$O(n\sqrt {n})$）"></a>朴素筛法（复杂度$O(n^2)$~$O(n\sqrt {n})$）</h3><p>枚举每一个数和它的因子，如果只有1与它本身是它的因子，那么它就是质数。<br><br>因为所有$&gt;\sqrt{n}$的因子都可以被小于$\sqrt{n}$的因子表示，所以可以只枚举到$\sqrt{n}$，但是复杂度还是不够优秀。</p>
<h3 id="埃氏筛（复杂度-O-nloglogn-）"><a href="#埃氏筛（复杂度-O-nloglogn-）" class="headerlink" title="埃氏筛（复杂度$O(nloglogn)$）"></a>埃氏筛（复杂度$O(nloglogn)$）</h3><p>思想就是从枚举因子转化为枚举倍数。<br><br>很明显质数的倍数都不是质数，所以对于每个质数，枚举其倍数，并将其标记成非质数。<br><br>很明显这样做的话会使得一些数被筛去好几次，比如6会被2和3筛去，造成了时间上的浪费。<br><br>虽然这种筛法在实际应用上有更好的代替，但是其将枚举因子转化为枚举倍数的思想却能够优化解决很多问题。</p>
<h3 id="欧拉筛（复杂度-O-n-）"><a href="#欧拉筛（复杂度-O-n-）" class="headerlink" title="欧拉筛（复杂度$O(n)$）"></a>欧拉筛（复杂度$O(n)$）</h3><p>为了解决埃氏筛反复筛去一个数多次的问题，我们规定，每一个数只能被其最小的质因子删去。<br><br>通过代码进行进一步讲解<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(i, j, k) for(register int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">40010</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn], tot;</span><br><span class="line"><span class="keyword">char</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">innt</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	fr(i, <span class="number">2</span>, maxn - <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])prime[++tot] = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= maxn; ++j)&#123;</span><br><span class="line">			vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//关键点！！！！！！</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中有一句：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>正是这句话保证了每个数只会被其最小的质因子删去。</p>
<h2 id="线性筛欧拉函数"><a href="#线性筛欧拉函数" class="headerlink" title="线性筛欧拉函数"></a>线性筛欧拉函数</h2><h3 id="欧拉函数定义"><a href="#欧拉函数定义" class="headerlink" title="欧拉函数定义"></a>欧拉函数定义</h3><p>欧拉函数是指小于x的整数中与x互质的数的个数，用$\varphi$表示，特殊的：$\varphi(1)=1$。</p>
<h3 id="欧拉函数性质"><a href="#欧拉函数性质" class="headerlink" title="欧拉函数性质"></a>欧拉函数性质</h3><p>1.对于质数$p$, $\varphi(p)=p-1$</p>
<blockquote>
<p>根据定义显然</p>
</blockquote>
<p>2.对于质数$p$,<br><br>若$p$是$x$的约数，则 $\varphi(x<em>p)=\varphi(x)</em>p$ 。<br><br>若p不是x的约数，则 $\varphi(x<em>p)=\varphi(x)</em>\varphi(p)=\varphi(x)*(p-1)$ 。<br><br>证明：</p>
<blockquote>
<p>1.若$x\%p==0$则$i<em>p$的最小素因子的个数多了1，其余无变化<br><br>2.若$x\%p!=0$，因为$\varphi$s是积性函数，所以当$x$与$p$互质时$\varphi(x</em>p)=\varphi(x)*\varphi(p)$。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(i, j, k) for(register int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">40010</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn], phi[maxn], tot;</span><br><span class="line"><span class="keyword">char</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">innt</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vis[<span class="number">1</span>] = <span class="number">1</span>, phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	fr(i, <span class="number">2</span>, maxn)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])&#123;prime[++tot] = i;phi[i] = i - <span class="number">1</span>;&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= maxn; ++j)&#123;</span><br><span class="line">			vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % prime[j])&#123;</span><br><span class="line">				phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			phi[i*prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性筛莫比乌斯函数"><a href="#线性筛莫比乌斯函数" class="headerlink" title="线性筛莫比乌斯函数"></a>线性筛莫比乌斯函数</h2><h3 id="莫比乌斯函数定义及性质"><a href="#莫比乌斯函数定义及性质" class="headerlink" title="莫比乌斯函数定义及性质"></a>莫比乌斯函数定义及性质</h3><p>请参考<a href="/2019/08/09/莫比乌斯反演/">莫比乌斯反演</a>。<br></p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(i, j, k) for(register int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">40010</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn], mu[maxn], tot;</span><br><span class="line"><span class="keyword">char</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">innt</span><span class="params">()</span></span>&#123;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	fr(i, <span class="number">2</span>, maxn)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])prime[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>, w; j &lt;= cnt &amp;&amp; (w = (i * prime[j])) &lt;= maxn; ++j)&#123;</span><br><span class="line">			vis[w] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!(i % prime[j]))&#123;mu[w] = <span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">else</span> mu[w]=-mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演</title>
    <url>/2019/08/09/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><del>这种神仙玩意儿一听就非常高端。</del>但是如果认真学习的话，还是比想象中的要简单的。<br><br><del>话说本来想拿去装13的却被初三小朋友痛斥过于娱乐…</del><br><a id="more"></a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>感谢：</p>
<blockquote>
<p><a href="https://panda2134.tk/%E7%AC%94%E8%AE%B0/2018/03/12/MobiusInversion/" target="_blank" rel="noopener">莫比乌斯反演学习笔记——by Panda2134</a><br><br><a href="https://dimensiontripper.github.io/2018/10/29/Mobius_Inversion/" target="_blank" rel="noopener">莫比乌斯反演学习笔记——by DimensionTripper</a><br><br><del>各种能百度到的资料</del></p>
</blockquote>
<h1 id="前置1：数论、积性函数"><a href="#前置1：数论、积性函数" class="headerlink" title="前置1：数论、积性函数"></a>前置1：数论、积性函数</h1><h2 id="什么叫数论函数？"><a href="#什么叫数论函数？" class="headerlink" title="什么叫数论函数？"></a>什么叫数论函数？</h2><blockquote>
<p>在数论上，算术函数（或称数论函数）指定义域为正整数、陪域为复数的函数<br><br>——来自百度百科</p>
</blockquote>
<p><del>无法识别的表达方式…</del><br><br>换句话说，数论函数就相当于<strong>定义域为$N^+$的函数</strong>。<br><br><strong>注1：</strong>陪域就相当于可以包含值域所有的集合。<br></p>
<p><fancybox><br><img src="https://s2.ax1x.com/2019/08/09/eqRVVs.png" alt="eqRVVs.png">
</fancybox><br>如图，如果A是$f(x)$的值域，那么B与C都可以是$f(x)$的陪域。<br><br><strong>注2：</strong>复数是指形如$z=a+bi$的数…为全部实数与虚数的集合。</p>
<h2 id="什么叫积性函数？"><a href="#什么叫积性函数？" class="headerlink" title="什么叫积性函数？"></a>什么叫积性函数？</h2><p>指当$gcd(a,b)=1$时满足$f(ab)=f(a)f(b)$的数论函数。<br><br>还有一种更加特殊的情况，即d对于任意$a,b \in Z$时都满足$f(ab)=f(a)f(b)$的函数，被称为完全积性函数。<br><br>由于完全积性函数相较于积性函数并没有什么更加<del>可爱</del>的性质，故下文仅对积性函数进行讨论。</p>
<h2 id="有哪些常见的积性函数？"><a href="#有哪些常见的积性函数？" class="headerlink" title="有哪些常见的积性函数？"></a>有哪些常见的积性函数？</h2><blockquote>
<p>$\mu(n)$：<strong>本文主角，莫比乌斯函数。</strong><br></p>
<script type="math/tex; mode=display">
\mu(n)=
\begin{cases}
\text{1}&&\text{(n==1)}\\
\text{$(-1)^k$}&&\text{(当$n=p_1*p_2*...*p_k$时)}\\
\text{0}&&\text{(当n存在平方因子时)}\\
\end{cases}</script><p>$1(n)$：<strong>不变的函数，恒定值为1</strong><br><br>$\epsilon(n)$：<strong>单位元，当且仅当$n=1$时$\epsilon(n)=1$，其他情况$\epsilon(n)=0$，即</strong></p>
<script type="math/tex; mode=display">
\epsilon(n)=
\begin{cases}
\text{1}&&\text{(n==1)}\\
\text{0}&&\text{otherwise}
\end{cases}</script><p>$id(n)$：<strong>就是$n$的大小，即$id[n]=n$</strong> <br><br>$\varphi(n)$：欧拉函数，指小于$n$的正整数中与$n$互质数的数目。<br><br>$gcd(n,k)$：当$k$固定时，$n$的最大公因子。<br><br>$d(n)$：$n$的正因子数目<br><br>$σ(n)$：$n$的所有正因子之和<br></p>
</blockquote>
<p>其中加粗的函数与莫比乌斯反演有比较重要的关系。</p>
<h2 id="积性函数的性质"><a href="#积性函数的性质" class="headerlink" title="积性函数的性质"></a>积性函数的性质</h2><p>1.对于任意积性函数$f$，$f(1)=1$。<br></p>
<blockquote>
<p>显然，$f(n)=f(n)f(1)\rightarrow f(1)=1$</p>
</blockquote>
<p>2.对于一个大于1的正整数$N$，设$N=\prod p_i ^ {a_i}$且$\forall p_i \not= p_j$（就是将$N$质因数分解，则对于一个积性函数$f$：</p>
<script type="math/tex; mode=display">
    f(n)=f(\prod p_i ^ {a_i})=\prod f(p_i ^ {a_i})</script><blockquote>
<p>根据定义显然。</p>
</blockquote>
<h1 id="前置2：狄利克雷卷积"><a href="#前置2：狄利克雷卷积" class="headerlink" title="前置2：狄利克雷卷积"></a>前置2：狄利克雷卷积</h1><p><del>又是一个听起来非常高端的玩意儿…</del><br><br>设$f(n), g(n), h(n)$为数论函数，且</p>
<script type="math/tex; mode=display">h(n)=f(n)*g(n)</script><p>，则</p>
<script type="math/tex; mode=display">
h(n)=\sum_{d|n}f(d)g(\frac{n}{d})</script><h2 id="几条性质"><a href="#几条性质" class="headerlink" title="几条性质"></a>几条性质</h2><p>1.交换律：<script type="math/tex">{(f*g)(n)=(g*f)(n)}</script>；<br><br>2.结合律：<script type="math/tex">((f*g)*h)(n)=(f*(g*h))(n)</script>；<br><br>3.分配律：定义两个数论函数<script type="math/tex">f(n),g(n)</script>的加法为逐项相加，即<script type="math/tex">(f+g)(n)=f(n)+g(n)</script>，那么<script type="math/tex">(f+g)*h=f*h+g*h</script>；<br><br>4.积性函数<script type="math/tex">*</script>积性函数<script type="math/tex">=</script>积性函数，即当<script type="math/tex">f(n),g(n)</script>为积性函数时，<script type="math/tex">h(n)=f(n)*g(n)</script>也为积性函数。<br><br>证明：</p>
<blockquote>
<p>设：$n=a*b$，且$gcd(a,b)=1$，则</p>
<script type="math/tex; mode=display">
\begin{split}
h(n)
&&=\sum_{d|n}f(d)g(\frac{n}{d})\\
&&=\sum_{d1|a}\sum_{d2|b}f(d1d2)g(\frac{a}{d1}\frac{b}{d2})\\
&&=\sum_{d1|a}\sum_{d2|b}f(d1)f(d2)g(\frac{a}{d1})g(\frac{b}{d2})\\
&&=\sum_{d1|a}f(d1)g(\frac{a}{d1})\sum_{d2|b}f(d2)g(\frac{b}{d2})\\
&&=h(a)*h(b)\\
\end{split}</script></blockquote>
<p>5.$(f*e)=f$ <br><br>证明：</p>
<blockquote>
<script type="math/tex; mode=display">
\begin{split}
(f*e)(n)&&=e*f(n)\\
&&=\sum_{d|n}e(d)*f(\frac{n}{d})\\
&&=f(n)\\
\end{split}</script></blockquote>
<p><strong>注：</strong>非积性函数亦可卷积。</p>
<h1 id="前置3：莫比乌斯函数"><a href="#前置3：莫比乌斯函数" class="headerlink" title="前置3：莫比乌斯函数"></a>前置3：莫比乌斯函数</h1><h2 id="几条性质-1"><a href="#几条性质-1" class="headerlink" title="几条性质"></a>几条性质</h2><p>1.$\mu(n)$是积性函数<br><br>证明：</p>
<blockquote>
<p>因为</p>
<script type="math/tex; mode=display">
\begin{split}
\begin{cases}
\mu(p_i^{a_i})=-1&&(a_i==-1)\\
\mu(p_i^{a_i})=0&&(a_i\ge 2)\\
\end{cases}
\end{split}</script><p>所以</p>
<script type="math/tex; mode=display">
\mu(n)=\prod p_i^{a_i}</script><p>由积性函数性质2得：$\mu$是积性函数。<br></p>
</blockquote>
<p>2.$\mu*1=\epsilon$ <br><br>证明：</p>
<blockquote>
<p>因为$\mu$、$1$、$\epsilon$均为积性函数<br><br>所以原命题转化为证明：</p>
<script type="math/tex; mode=display">
(\mu * 1)(p^k)=\epsilon(p^k)</script><p>其中</p>
<script type="math/tex; mode=display">
(\mu * 1)(p^k)=\sum_{j=0}^{k} \mu(p^j)1(p^{k-j})</script><p>而</p>
<script type="math/tex; mode=display">
\begin{split}
\mu(p^j)=
\begin{cases}
1 &&(j==0)\\
-1 &&(j==1)\\
0 &&(j\ge 2)\\
\end{cases}
\end{split}</script><p>所以</p>
<script type="math/tex; mode=display">
\begin{split}
\sum_{j=0}^{k} \mu(p^j)1(p^{k-j})=
\begin{cases}
1-1+0+0+0...&&(k>0)\\
1&&(k==0)
\end{cases}
\end{split}</script><p>即原命题成立</p>
</blockquote>
<p>该命题还有另一种表达方式：</p>
<script type="math/tex; mode=display">
\sum_{d|n} \mu(d)=[n==1]</script><p>因为：</p>
<script type="math/tex; mode=display">
\sum_{d|n}\mu(d)=\sum_{d|n}\mu(d)*1=(\mu*1)(n)=\epsilon(n)</script><p><strong>注：</strong>其中$[$ &nbsp; $]$ 表示<strong>艾佛森括号</strong>，方括号其中的条件满足则为1，不满足则为0，即：</p>
<script type="math/tex; mode=display">
\begin{aligned}\\
[P]&=1 &\text{(If P is true)}\\
[P]&=0 &\text{(Otherwise)}
\end{aligned}</script><h1 id="正题：莫比乌斯反演"><a href="#正题：莫比乌斯反演" class="headerlink" title="正题：莫比乌斯反演"></a>正题：莫比乌斯反演</h1><p><strong>形式一：</strong>已知$f(x),g(x)$为两个数论函数，如果</p>
<script type="math/tex; mode=display">
f(n)=\sum_{d|n}g(d)</script><p>则</p>
<script type="math/tex; mode=display">
g(n)=\sum_{d|n}f(d)*\mu(\frac{n}{d})</script><p>证明1：（狄利克雷卷积法）</p>
<blockquote>
<p>已知</p>
<script type="math/tex; mode=display">
f(n)=\sum_{d|n}g(d)</script><p>改写成卷积的形式</p>
<script type="math/tex; mode=display">
f(n)=g(n)*1</script><p>等式两侧同时$*\mu$</p>
<script type="math/tex; mode=display">
f*\mu=g*1*\mu</script><p>由莫比乌斯函数性质知：$\mu*1=\epsilon$，<br>即</p>
<script type="math/tex; mode=display">
f*\mu=g*\epsilon=g</script><p>根据狄利克雷卷积展开，则</p>
<script type="math/tex; mode=display">
g(n)=\sum_{d|n}f(d)*g(\frac{n}{d})</script></blockquote>
<p>证明2：(定义法)</p>
<blockquote>
<p>由$f(n)$的定义知：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{d|n}\mu(d)f(\frac{n}{d})=&\sum_{d|n}\mu(d)\sum_{i|\frac{n}{d}}g(i)\\
=&\sum_{d|n}\sum_{i|\frac{n}{d}}\mu(d)g(i)\\
=&\sum_{i|n}\sum_{d|\frac{n}{i}}\mu(d)g(i)\\
=&\sum_{i|n}g(i)\sum_{d|\frac{n}{i}}\mu(d)\\
\end{aligned}</script><p>根据莫比乌斯函数的性质：当且仅当$\frac{n}{i}==1$时，<br>$\sum_{d|\frac{n}{i}}\mu(d)=1$，所以：</p>
<script type="math/tex; mode=display">
\sum_{i|n}g(i)\sum_{d|\frac{n}{i}}\mu(d)=g(n)</script></blockquote>
<p><strong>形式二：</strong><br>如果</p>
<script type="math/tex; mode=display">
g(n)=\sum_{n|d}f(d)</script><p>那么</p>
<script type="math/tex; mode=display">
f(n)=\sum_{n|d}\mu(\frac{d}{n})g(d)</script><p>证明：</p>
<blockquote>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{n|d}\mu(\frac{d}{n})g(d)=&\sum_{k=1}^{+\infty}\mu(k)g(nk)\\
=&\sum_{k=1}^{+\infty}\mu(k)\sum_{nk|t}f(d)\\
=&\sum_{n|t}f(t)\sum_{k|(t|n)}\mu(k)\\
=&\sum_{n|t}f(t)[t==n]\\
=&f(n)
\end{aligned}</script></blockquote>
<hr>
<p><del>具体实现咕到下篇博客里…</del></p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀数组哪里难？</title>
    <url>/2019/08/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%93%AA%E9%87%8C%E9%9A%BE%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>感谢</p>
<blockquote>
<p>2009年国家集训队论文<br><br><a href="https://www.cnblogs.com/victorique/p/8480093.html" target="_blank" rel="noopener">后缀数组 最详细讲解</a><br><br><a href="https://www.luogu.org/problemnew/solution/P3809" target="_blank" rel="noopener">luoguP3809 【模板】后缀排序 题解</a> <br><br><a href="https://www.luogu.org/problemnew/solution/P2408" target="_blank" rel="noopener">luoguP2408 不同子串个数 题解</a><br></p>
</blockquote>
<p>以及</p>
<blockquote>
<p>来自<del>ZhengRuIOI</del>的课件</p>
</blockquote>
<p>让本蒟蒻<del>大概</del>明白了这种算法<br><a id="more"></a></p>
<h2 id="什么是后缀数组？"><a href="#什么是后缀数组？" class="headerlink" title="什么是后缀数组？"></a>什么是后缀数组？</h2><p>后缀数组指的是一个一维的数组，将一个给定的字符串的每一个后缀以其起始位置作为编号，按照字典序的大小排好序后放到一个数组中，我们便得到了一个后缀数组。</p>
<h2 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h2><blockquote>
<p>后缀数组——处理字符串的有力工具<br><br>——罗穗骞</p>
</blockquote>
<p>如上所述，后缀数组可以解决许多<del>花里胡哨</del>的字符串问题，尤其是子串相关问题。后缀数组相较后缀自动机更易实现，且有更优秀的空间复杂度，而且许多后缀自动机的操作后缀数组都能完成。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>一般通用的方法有倍增法与DC3法，倍增法的时间复杂度为$O(logn)$，而DC3法则以思维难度的提升与代码实现方式的复杂化使时间复杂度提升为$O(n)$。<br><br>由于本人过于菜(<del>懒</del>)，在本文章中暂时只介绍倍增法。</p>
<h2 id="配套食用"><a href="#配套食用" class="headerlink" title="配套食用"></a>配套食用</h2><p>单纯的后缀数组虽然<del>看上去</del>非常牛，但是我们一般不仅仅要需要后缀的信息，更希望知道子串的相关信息，这时，就要用到LCP（最长公共前缀）这种奇妙的东西和$height$数组了。</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="数组设定"><a href="#数组设定" class="headerlink" title="数组设定"></a>数组设定</h2><p>后缀数组相交于以前学过的其他算法，有着更加复杂的数组设定，下面加以综述。</p>
<blockquote>
<p>$sa[i]$：排好序的后缀数组第$i$位的后缀开头位置<br><br>$rk[i]$：开头位置为$i$的后缀在后缀数组中的位置<br><br>$x[i]$：基数排序时的第一关键字排名（待会会讲）<br><br>$y[i]$：基数排序的第二关键字排名，同时也是在$sa$数组计算过程中存储的暂时排名<br><br>$c[i]$：基数排序所用的桶<br><br>$height[i]$：$sa[i]$与$sa[i-1]$的<strong>最长公共前缀</strong></p>
</blockquote>
<p>很明显$sa[i]$与$rk[i]$互为逆运算。</p>
<h2 id="前置：基数排序"><a href="#前置：基数排序" class="headerlink" title="前置：基数排序"></a>前置：基数排序</h2><p>一种奇妙的可以实现$O(n)$ 排序的方法<br><br>与桶排类似，不过是将每一个数拆分成个位、十位…<br><br>先按照个位插入桶中，再逐个放入答案数组中，这样的一次操作可以保证个位有序。再按照十位插入桶中，放入答案数组中，这一次操作后会使十位有序，因为个位已经有序了，那么前两位就全部有序了。<br><br>值得注意的一点，在从桶中弹出的时候，应该倒序枚举($n \rightarrow 1$)，这样才能保证之前排好的顺序不会乱掉。<br><br>举个例子吧：</p>
<blockquote>
<p>21 18 12 42 56 66 22 46</p>
</blockquote>
<p>先按个位排</p>
<blockquote>
<p>21<br>12 42 22<br>56 66 46<br>18<br></p>
</blockquote>
<p>然后</p>
<blockquote>
<p>21 12 42 22 56 66 46 18<br></p>
</blockquote>
<p>再按十位排</p>
<blockquote>
<p>12 18<br> 21 22<br>42 46<br>56<br>66<br></p>
</blockquote>
<p>得到答案</p>
<blockquote>
<p>12 18 21 22 42 46 56 66<br></p>
</blockquote>
<h2 id="求后缀数组的倍增法（-SA-）"><a href="#求后缀数组的倍增法（-SA-）" class="headerlink" title="求后缀数组的倍增法（$SA()$）"></a>求后缀数组的倍增法（$SA()$）</h2><p>我们要判断两个后缀的字典序，当然可以$O(n)$的去扫一遍，不过面对全部后缀，使用快速排序的话，$O(n^2 logn)$显然无法接受。这时，提出一种新的方法——倍增法，其做法是这样的：<br>首先针对每一位上的子串获得一个排名。</p>
<p><fancybox><br><img src="https://s2.ax1x.com/2019/08/09/eb831U.png" alt="eb831U.png"></fancybox></p>
<p>然后我们将第$i$位的排名与$i+1$位合并</p>
<p><fancybox><br><img src="https://s2.ax1x.com/2019/08/09/ebtarD.png" alt="ebtarD.png"></fancybox></p>
<p>在这个<del>可爱</del>的例子中，我们已经完成了排序，如果两次没有完成，那么就不断沿着当前点往后的$2^k$合并，很明显，如果每一个后缀的排名都不同的话，算法就可以停止了。<br><br>代码长这样<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(i, j, k) for(register int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rf(i, j, k) for(register int i = j; i &gt;= k; --i)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fr(i, <span class="number">1</span>, n)c[x[i] = a[i]]++;<span class="comment">//塞到桶里</span></span><br><span class="line">	fr(i, <span class="number">2</span>, m)c[i] += c[i - <span class="number">1</span>];<span class="comment">//做个前缀和</span></span><br><span class="line">	rf(i, n, <span class="number">1</span>)sa[c[x[i]]--] = i;<span class="comment">//第一次的排名</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>)&#123;<span class="comment">//枚举2的k次</span></span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">		fr(i, n - k + <span class="number">1</span>, n)y[++num] = i;<span class="comment">//最后的k个数很明显没有第二关键字，所以它们在y数组的最前面</span></span><br><span class="line">		fr(i, <span class="number">1</span>, n)<span class="keyword">if</span>(sa[i] &gt; k)y[++num] = sa[i] - k;<span class="comment">//如果当前的排名大于k，就可以作为别人的第二关键字，塞到第二关键字中</span></span><br><span class="line">		fr(i, <span class="number">1</span>, m)c[i] = <span class="number">0</span>;</span><br><span class="line">		fr(i, <span class="number">1</span>, n)c[x[i]]++;</span><br><span class="line">		fr(i, <span class="number">2</span>, m)c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">		rf(i, n, <span class="number">1</span>)sa[c[x[y[i]]]--] = y[i], y[i] = <span class="number">0</span>;<span class="comment">//基数排序</span></span><br><span class="line">		swap(x, y);<span class="comment">//准备通过旧的x生成新的x</span></span><br><span class="line">		x[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">		num = <span class="number">1</span>;</span><br><span class="line">		fr(i, <span class="number">2</span>, n)&#123;</span><br><span class="line">			x[sa[i]] = (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) ? num : ++num; <span class="comment">//通过排好序的sa[i]生成新的第一关键字</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(num == n)<span class="keyword">break</span>;<span class="comment">//排名全都不一样就可以退出了</span></span><br><span class="line">		m = num;<span class="comment">//数据的范围变成只有num个</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最大公共前缀（LCP）"><a href="#最大公共前缀（LCP）" class="headerlink" title="最大公共前缀（LCP）"></a>最大公共前缀（LCP）</h2><p>其实后缀数组本身能解决的问题有限，我们很多时候都要与$LCP$和$height$数组配套使用。<br></p>
<h3 id="怎么求-height-？"><a href="#怎么求-height-？" class="headerlink" title="怎么求$height$？"></a>怎么求$height$？</h3><p>直接暴力$O(n)$求解每个$height[i]$显然不可行，但是某些极其牛的人证出了一条不那么显然的结论：</p>
<script type="math/tex; mode=display">height[i] \ge height[i - 1] - 1</script><p>下面我来尝试以一种更加浅显的方式来证明。<br><br>首先考虑$i$在原串中的前一位$i-1$，再考虑$i-1$在后缀数组中的前一位$k$。<br>很明显分一下两种情况：<br>第一种情况$k$与$i-1$没有公共前缀，即$height[i-1] == 0$，此时结论显然成立。</p>
<p><fancybox><br><img src="https://s2.ax1x.com/2019/08/09/equOvd.png" alt="equOvd.png"></fancybox></p>
<p>第二种情况如上图，$k$与$i-1$有公共前缀，即$height[i] \not= 0$。此时考虑k在原串中的后一位$k+1$与$i$之间的公共前缀，可以明显地得到以下结论：</p>
<blockquote>
<p>1.在排好序的后缀数组中，$k+1$在$i$的前面。(因为$k+1$是$k$的后缀，$i$是$i-1$的后缀)<br><br>2.$k+1$与$i$之间的最长公共前缀为$height[i-1]-1$</p>
</blockquote>
<p><fancybox><br><a href="https://imgchr.com/i/eqMc6J" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/08/09/eqMc6J.png" alt="eqMc6J.png"></a></fancybox></p>
<p>那么也就说明了，$height[i]$的大小至少为$height[i-1]-1$，因为如果有一个后缀插在$k+1$与$i$中间的话，它与$i$的最长公共公共前缀不可能会比$k+1$与$i$的最长公共前缀小。就这样，我们得到了一个$O(n)$的解法来求解$height$数组。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_height</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">	fr(i, <span class="number">1</span>, n)rk[sa[i]] = i;<span class="comment">//获取排名</span></span><br><span class="line">	fr(i, <span class="number">1</span>, n)&#123;</span><br><span class="line">		j = sa[rk[i] - <span class="number">1</span>];<span class="comment">//j是i在sa数组中的前一位</span></span><br><span class="line">		<span class="keyword">if</span>(k) k--;<span class="comment">//因为是&gt;= height[i-1] - 1，所以要-1</span></span><br><span class="line">		<span class="keyword">while</span>(a[i + k] == a[j + k])k++;</span><br><span class="line">		height[rk[i]] = k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一道模版题"><a href="#一道模版题" class="headerlink" title="一道模版题"></a>一道模版题</h1><p><a href="https://www.luogu.org/problem/P3809" target="_blank" rel="noopener">luoguP3809 【模板】后缀排序</a><br><br><br>直接求出$sa$数组即可</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(i, j, k) for(register int i = j; i &lt;= k; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rf(i, j, k) for(register int i = j; i &gt;= k; --i)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn], c[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> sa[maxn], rk[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fr(i, <span class="number">1</span>, n)c[x[i] = s[i]]++;</span><br><span class="line">	fr(i, <span class="number">2</span>, m)c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">	rf(i, n, <span class="number">1</span>)sa[c[x[i]]--] = i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">		fr(i, n - k + <span class="number">1</span>, n)y[++num] = i;</span><br><span class="line">		fr(i, <span class="number">1</span>, n)<span class="keyword">if</span>(sa[i] &gt; k)y[++num] = sa[i] - k;</span><br><span class="line">		fr(i, <span class="number">1</span>, m)c[i] = <span class="number">0</span>;</span><br><span class="line">		fr(i, <span class="number">1</span>, n)c[x[i]]++;</span><br><span class="line">		fr(i, <span class="number">2</span>, m)c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">		rf(i, n, <span class="number">1</span>)sa[c[x[y[i]]]--] = y[i], y[i] = <span class="number">0</span>;</span><br><span class="line">		swap(x, y);</span><br><span class="line">		x[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">		num = <span class="number">1</span>;</span><br><span class="line">		fr(i, <span class="number">2</span>, n)&#123;</span><br><span class="line">			x[sa[i]] = (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) ? num : ++num;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(num == n)<span class="keyword">break</span>;</span><br><span class="line">		m = num;</span><br><span class="line">	&#125;</span><br><span class="line">	fr(i, <span class="number">1</span>, n)<span class="built_in">printf</span>(<span class="string">"%d "</span>, sa[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	gets(s+<span class="number">1</span>);</span><br><span class="line">	n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	m = <span class="number">122</span>;</span><br><span class="line">	SA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>评论的使用方法</title>
    <url>/2019/08/06/%E8%AF%84%E8%AE%BA%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>评论系统来自<a href="https://valine.js.org/" target="_blank" rel="noopener">valine</a><br><a id="more"></a></p>
<p><fancybox><br><img src="https://s2.ax1x.com/2019/08/06/ehlXX8.png" alt="ehlXX8.png"></fancybox></p>
<h3 id="1-昵称"><a href="#1-昵称" class="headerlink" title="1. 昵称"></a>1. 昵称</h3><p>顾名思义就是你评论之后显示的名称啦</p>
<h3 id="2-邮箱"><a href="#2-邮箱" class="headerlink" title="2. 邮箱"></a>2. 邮箱</h3><p>获取头像用的</p>
<p>请自行登录或注册<a href="https://cn.gravatar.com/" target="_blank" rel="noopener">Gravatar</a>，然后修改自己的头像。（详情请咨询度娘）</p>
<p>评论的时候，留下在<a href="https://cn.gravatar.com/" target="_blank" rel="noopener">Gravatar</a>注册时所使用的邮箱即可。</p>
<h3 id="3-链接"><a href="#3-链接" class="headerlink" title="3. 链接"></a>3. 链接</h3><p>可选项，填写后会在你的评论上自动生成一个链接（<del>记得加  https://</del>），效果如图：</p>
<p><fancybox><br><img src="https://s2.ax1x.com/2019/08/06/eh8CQ0.png" alt="eh8CQ0.png"></fancybox></p>
<h3 id="4-内容"><a href="#4-内容" class="headerlink" title="4. 内容"></a>4. 内容</h3><p>支持emoji与markdown</p>
<hr>
<p><strong>全部完成后点击发布即可！</strong></p>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-7题解综合2——DP</title>
    <url>/2019/08/04/2019-7-29%E9%A2%98%E8%A7%A3%E7%BB%BC%E5%90%88/</url>
    <content><![CDATA[<h1 id="7-29-“简单”DP"><a href="#7-29-“简单”DP" class="headerlink" title="7.29 “简单”DP"></a>7.29 “简单”DP</h1><a id="more"></a>
<h2 id="luogu-P2467-SDOI2010-地精部落"><a href="#luogu-P2467-SDOI2010-地精部落" class="headerlink" title="luogu P2467 [SDOI2010]地精部落"></a>luogu P2467 [SDOI2010]地精部落</h2><p><a href="https://www.luogu.org/problem/P2467" target="_blank" rel="noopener">题目传送门</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>一个序列符合要求，当且仅当其是一个$1 \sim n$的排列，且每一个$a[i]$ <br><br>满足$a[i-1]\le a[i]$且$a[i]\ge a[i+1]$ <br><br>或者满足$a[i-1]\ge a[i]$且$a[i]\le a[i+1]$ <br><br>求长度为$n$的合法序列方案数</p>
<h3 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h3><p>神仙题。。。。<br><br><del>显然</del>有以下性质：</p>
<blockquote>
<p>1.当$i$与$i+1$不相邻时，交换$i$与$i+1$仍会得到一个合法的解<br><br>如:$3 2 4 1 5 \rightarrow 3 1 4 2 5$ <br><br>2.一串序列$a[i]$，$i\in [1,n]$满足条件时，则$(i+1)-a[i]$亦满足条件<br><br>如:$3 2 4 1 5 \rightarrow 3 4 2 5 1$ <br><br>3.满足条件的序列具有对称性 <br><br>如:$3 2 4 1 5 \rightarrow 5 1 4 2 3$ <br></p>
</blockquote>
<p>则设$dp[i][j]$表示当前为前$i$个数的<strong>排列</strong>，且首位是$j$且为<strong>山峰</strong>的方案数。<br></p>
<script type="math/tex; mode=display">
\!
\begin{split}
& 由性质1可知:
\!\begin{cases}
\text{当$j$与$j-1$不相邻时，$dp[i][j]=dp[i][j-1]$}\\
\end{cases}\\
& 由性质2可知:
\!\begin{cases}
\text{首位做山峰的方案数=首位做山谷的方案数}\\
\downarrow \\
\text{(也就是说最后的答案是$2*\sum_{i=1}^n dp[n][i]$)}\\
\\
\text{当$j$与$j-1$相邻时，}\\
\text{方案数即为$i-1$个数，$j-1$为首位且为山谷的方案数}\\
\text{$\downarrow$}\\
\text{即$dp[i][j]=dp[i-1][(i-1+1)-(j-1)]$}
\end{cases}
\end{split}</script><p>综上，$dp[i][j]=dp[i][j-1]+dp[i-1][i-j+1]$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, p;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">2</span>][<span class="number">4300</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;p);</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">			dp[i &amp; <span class="number">1</span>][j] = (dp[i &amp; <span class="number">1</span>][j - <span class="number">1</span>] + dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][i - j + <span class="number">1</span>]) % p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		ans = ans + dp[n &amp; <span class="number">1</span>][i] % p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans &lt;&lt; <span class="number">1</span>) % p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="luogu-P2519-HAOI2011-problem-a"><a href="#luogu-P2519-HAOI2011-problem-a" class="headerlink" title="luogu P2519 [HAOI2011]problem a"></a>luogu P2519 [HAOI2011]problem a</h2><p><a href="https://www.luogu.org/problem/P2519" target="_blank" rel="noopener">题目传送门</a></p>
<h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>一次考试共有$n$个人参加，第$i$个人说：“有$ai$个人分数比我高，$bi$个人分数比我低。”问最少有几个人没有说真话(可能有相同的分数)</p>
<h3 id="大体思路-1"><a href="#大体思路-1" class="headerlink" title="大体思路"></a>大体思路</h3><p>先进行补集转化，目标变成求说真话的人数。<br>有$ai$个人分数比我低，$bi$个人分数比我高，就意味着$[ai+1,n-bi-1]$是相同的数。<br><br>问题转化为使$k$段区间不重叠且权值和最大。按照右端点排序之后dp即可。<br>几点细节:</p>
<blockquote>
<p>1.合法解可以有完全重合的区间，但是一段区间最多只能有<strong>区间长度</strong>个说真话的人。<br><br>2.要特判$ai \ge bi$的情况</p>
</blockquote>
<p>设$f[i]$表示当前为第$i$位的区间最大值，则</p>
<script type="math/tex; mode=display">
f[i]=max(f[i-1],f[L[j]-1]+w[j])  (R[j]==i)</script><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> gc;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line">	<span class="keyword">if</span>(!(ch ^ <span class="string">'-'</span>))f = <span class="number">-1</span>, gc;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line">	<span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> r == a.r ? l &lt; a.l : r &lt; a.r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;p[maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn], L[maxn], R[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">int</span> a, b, tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		a = read(), b = read();</span><br><span class="line">		<span class="comment">// cout&lt;&lt;a&lt;&lt; " "&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line">		p[i].l = a + <span class="number">1</span>, p[i].r = n - b;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p[i].l &gt; p[i].r)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;p[i].l&lt;&lt; " "&lt;&lt;p[i].r&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">if</span>(p[i].l != p[i - <span class="number">1</span>].l || p[i].r != p[i - <span class="number">1</span>].r)tot++;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;tot&lt;&lt;endl;</span></span><br><span class="line">		w[tot] = min(w[tot] + <span class="number">1</span>, p[i].r - p[i].l + <span class="number">1</span>);</span><br><span class="line">		L[tot] = p[i].l, R[tot] = p[i].r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// for(int i = 1; i &lt;= tot; ++i)&#123;</span></span><br><span class="line">	<span class="comment">// 	cout&lt;&lt;w[i]&lt;&lt; " "&lt;&lt;L[i]&lt;&lt; " "&lt;&lt;R[i]&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		<span class="comment">// int j = 1;</span></span><br><span class="line">		f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// cout&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">while</span>(j &lt;= tot &amp;&amp; R[j] == i)&#123;</span><br><span class="line">			<span class="comment">// cout&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">			<span class="comment">// cout&lt;&lt;L[j]&lt;&lt;endl;</span></span><br><span class="line">			f[i] = max(f[i], f[L[j] - <span class="number">1</span>] + w[j]);</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - f[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CF1016C-Vasya-And-The-Mushrooms"><a href="#CF1016C-Vasya-And-The-Mushrooms" class="headerlink" title="CF1016C Vasya And The Mushrooms"></a>CF1016C Vasya And The Mushrooms</h2><p><a href="https://www.luogu.org/problem/CF1016C" target="_blank" rel="noopener">题目传送门</a></p>
<h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个$2<em>n$的方格阵，经过一个格子获得的价值为$ai</em>$进入时间,求从左上角出发遍历一次全部格子获得的价值最大值。</p>
<h3 id="大体思路-2"><a href="#大体思路-2" class="headerlink" title="大体思路"></a>大体思路</h3><p>很明显的一道dp题。。。<br><br>稍加思考便能发现能够遍历整个方阵的方案可能是长这样的</p>
<p><fancybox><br><img src="https://s2.ax1x.com/2019/08/05/e2CXDg.png" alt="e2CXDg.png"></fancybox></p>
<p>或者是长这样的</p>
<p><fancybox><br><img src="https://s2.ax1x.com/2019/08/05/e2PZVJ.png" alt="e2PZVJ.png"></fancybox></p>
<p>总之就是先是一个蛇形结构，然后接一个U形结构，很明显这两个部分都是可以预处理的。</p>
<p><br><br>设$f[i][0/1]$表示蛇形部分进行到第$i$列，第$0/1$行的权值<br><br>则</p>
<script type="math/tex; mode=display">
\begin{split}
&f[i][0]=
\begin{cases}
\text{f[i-1][0]+(2*(i-1))*val[i][0]       (i&1==0)}\\
\text{f[i][1]+(2*(i-1)+1)*val[i][0]     (i&1!=0)}\\
\end{cases}\\
&f[i][1]=
\begin{cases}
\text{f[i][0]+(2*(i-1)+1)*val[i][1]     (i&1==0)}\\
\text{f[i-1][1]+(2*(i-1))*val[i][1]       (i&1!=0)}\\
\end{cases}
\end{split}</script><p><br><br>U形部分的计算方法：</p>
<script type="math/tex; mode=display">
\begin{split}
&\text{自左向右的部分}\\
&\sum_{i=k}^n vi*[T+(i-k)]\\ 
&\downarrow\\
&\sum_{i=k}^n vi*i+\sum_{i=k}^n vi*(T-k)\\
\\
&\text{自右向左的部分}\\
&\sum_{i=k}^n vi*[T+(n-k)+(n-k-i+1)]\\
&\downarrow\\
&\sum_{i=k}^n vi*(T+2*n-2*k+1)-\sum_{i=k}^n vi*i\\
\end{split}</script><p>$k$为U形部分开始的位置<br><br>设$g[i][0/1]$表示U形部分<strong>从0/1列， i行开始</strong>的权值，$sum[i][0/1]$表示本行<strong>距离结尾</strong>的权值和$nxt[i][0/1]$表示<strong>距离结尾</strong>的<strong>权值与列数乘积之和</strong><br><br>则</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(i &amp; <span class="number">1</span>))&#123;</span><br><span class="line">	g[i][<span class="number">1</span>] = nxt[i][<span class="number">1</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) - i) * sum[i][<span class="number">1</span>];</span><br><span class="line">	g[i][<span class="number">1</span>] += (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">2</span> * n - i + <span class="number">1</span>) * sum[i][<span class="number">0</span>] - nxt[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	g[i][<span class="number">0</span>] = nxt[i][<span class="number">0</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) - i) * sum[i][<span class="number">0</span>];</span><br><span class="line">	g[i][<span class="number">0</span>] += (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">2</span> * n - i + <span class="number">1</span>) * sum[i][<span class="number">1</span>] - nxt[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的答案就是每一种合法的蛇形与U形组合取$max$。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> gc;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line">	<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>, gc;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line">	<span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">readll</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll ret = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> gc;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line">	<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>, gc;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line">	<span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3</span> * <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line">ll val[maxn][<span class="number">2</span>];</span><br><span class="line">ll sum[maxn][<span class="number">2</span>], nxt[maxn][<span class="number">2</span>];</span><br><span class="line">ll f[maxn][<span class="number">2</span>], g[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		val[i][<span class="number">0</span>] = readll();</span><br><span class="line">		<span class="comment">// cnt[i][0] = val[i][0] * i;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		val[i][<span class="number">1</span>] = readll();</span><br><span class="line">		<span class="comment">// cnt[i][1] = val[i][1] * i;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">		sum[i][<span class="number">0</span>] = sum[i + <span class="number">1</span>][<span class="number">0</span>] + val[i][<span class="number">0</span>];</span><br><span class="line">		sum[i][<span class="number">1</span>] = sum[i + <span class="number">1</span>][<span class="number">1</span>] + val[i][<span class="number">1</span>];</span><br><span class="line">		nxt[i][<span class="number">0</span>] = nxt[i + <span class="number">1</span>][<span class="number">0</span>] + val[i][<span class="number">0</span>] * i;</span><br><span class="line">		nxt[i][<span class="number">1</span>] = nxt[i + <span class="number">1</span>][<span class="number">1</span>] + val[i][<span class="number">1</span>] * i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">			f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>)) * val[i][<span class="number">0</span>];</span><br><span class="line">			f[i][<span class="number">1</span>] = f[i][<span class="number">0</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">1</span>) * val[i][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>)) * val[i][<span class="number">1</span>];</span><br><span class="line">			f[i][<span class="number">0</span>] = f[i][<span class="number">1</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">1</span>) * val[i][<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// for(int i = 1; i &lt;= n; ++i)&#123;</span></span><br><span class="line">	<span class="comment">// 	cout&lt;&lt;"sum"&lt;&lt;sum[i][0]&lt;&lt; " "&lt;&lt;sum[i][1]&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// 	cout&lt;&lt;"nxt"&lt;&lt;nxt[i][0]&lt;&lt; " "&lt;&lt;nxt[i][1]&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(i &amp; <span class="number">1</span>))&#123;</span><br><span class="line">			g[i][<span class="number">1</span>] = nxt[i][<span class="number">1</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) - i) * sum[i][<span class="number">1</span>];</span><br><span class="line">			g[i][<span class="number">1</span>] += (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">2</span> * n - i + <span class="number">1</span>) * sum[i][<span class="number">0</span>] - nxt[i][<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			g[i][<span class="number">0</span>] = nxt[i][<span class="number">0</span>] + (<span class="number">2</span> * (i - <span class="number">1</span>) - i) * sum[i][<span class="number">0</span>];</span><br><span class="line">			g[i][<span class="number">0</span>] += (<span class="number">2</span> * (i - <span class="number">1</span>) + <span class="number">2</span> * n - i + <span class="number">1</span>) * sum[i][<span class="number">1</span>] - nxt[i][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// for(int i = 1; i &lt;= n; ++i)&#123;</span></span><br><span class="line">	<span class="comment">// 	cout&lt;&lt;"!!"&lt;&lt;f[i][0]&lt;&lt; " "&lt;&lt;f[i][1]&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// 	cout&lt;&lt;g[i][0]&lt;&lt; " "&lt;&lt;g[i][1]&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;f[i][1]&lt;&lt; " "&lt;&lt;g[i + 1][1]&lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">// cout&lt;&lt;f[i][0]&lt;&lt; " "&lt;&lt;g[i + 1][0]&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">if</span>(i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">			ans = max(ans, f[i][<span class="number">1</span>] + g[i + <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ans = max(ans, f[i][<span class="number">0</span>] + g[i + <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CF467C-George-and-Job"><a href="#CF467C-George-and-Job" class="headerlink" title="CF467C George and Job"></a>CF467C George and Job</h2><p><a href="https://www.luogu.org/problem/CF467C" target="_blank" rel="noopener">题目传送门</a></p>
<h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一组有$n$个整数的数列$p_1,p_2,…,p_n$，你需要挑出$k$组长度为$m$的数，要求这些数互不重叠，即：$[l_1,r_1],[l_2,r_2],…,<a href="1 \le l_1 \le r_1 &lt; l_2 \le r_2 &lt; ... &lt; l_k \le r_k \le n; r_i-l_i+1=m">l_k,r_k</a>$ 且使选出的数和值最大</p>
<h3 id="大体思路-3"><a href="#大体思路-3" class="headerlink" title="大体思路"></a>大体思路</h3><p>直接依照题意dp即可。<br><br>设$f[i][j]$为当前在第$i$位，选了$j$个区间时的最大值，$s[i]$为以$i$为起始点的长度为$m$的权值之和 <br><br>转移为：$f[i][j]=max(f[i-1][j],f[i-m][j-1]+s[i])$</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5010</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>;<span class="keyword">char</span> gc;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line">	<span class="keyword">if</span>(!(ch ^<span class="string">'-'</span>))f = <span class="number">-1</span>, gc;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line">	<span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">readll</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>, f = <span class="number">1</span>;<span class="keyword">char</span> gc;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line">	<span class="keyword">if</span>(!(ch ^<span class="string">'-'</span>))f = <span class="number">-1</span>, gc;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line">	<span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> p[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[maxn][maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	n = read(), m = read(), k = read();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		p[i] = readll();</span><br><span class="line">		sum[i] = sum[i - <span class="number">1</span>] + p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt;= n; ++i)&#123;</span><br><span class="line">		s[i] = sum[i] - sum[i - m];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt;= n; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k &amp;&amp; j * m &lt;= i; ++j)&#123;</span><br><span class="line">			f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">			f[i][j] = max(f[i][j], f[i - m][j - <span class="number">1</span>] + s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[n][k]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.7题解综合1 —— 并查集与分治</title>
    <url>/2019/08/01/2019-7%E9%A2%98%E8%A7%A3%E7%BB%BC%E5%90%88/</url>
    <content><![CDATA[<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>第一次在外面参加这么长时间的集训… 被各路大佬摧残…<br><a id="more"></a></p>
<h1 id="7-25-并查集相关"><a href="#7-25-并查集相关" class="headerlink" title="7.25 并查集相关"></a>7.25 并查集相关</h1><h2 id="CF468b-TWOSETS"><a href="#CF468b-TWOSETS" class="headerlink" title="CF468b TWOSETS"></a>CF468b TWOSETS</h2><p><a href="https://www.luogu.org/problem/CF468B" target="_blank" rel="noopener">题目传送门</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出 $n$ 个各不相同的数字，将它们分别放入 $A$ 和 $B$ 两个集合中，使它们满足：</p>
<blockquote>
<p>若数字 $x$ 在集合 $A$ 中，那么数字 $a-x$ 也在集合 $A$ 中；<br><br>若数字 $x$ 在集合 $B$ 中，那么数字 $b-x$ 也在集合 $B$ 中。<br></p>
</blockquote>
<h3 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h3><p>分为以下几种情况</p>
<blockquote>
<p>1.$a-x$与$b-x$有一个存在<br><br>$a-x$与$b-x$都不存在<br><br>$a-x$与$b-x$都存在<br></p>
</blockquote>
<p>很显然，$a-(a-x)=x$,因此如果$a-x(b-x)$不在给定的集合中，则$x$就只能在$B(A)$中（注意顺序）。而如果$a-x$与$b-x$都不存在，便会无解。<br><br>重点在于情况三，如果$a-x$与$b-x$都存在，那么$x$在哪个集合都可以，这时候决定$x$在哪里的并不是$x$本身，而是与$a-x$与$b-x$有关的数。<br><br>综合以上情况，考虑用并查集维护。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>;<span class="keyword">char</span> gc;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="string">'-'</span>))gc;</span><br><span class="line">	<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>,gc;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret = (ret &lt;&lt; <span class="number">3</span>) + (ret &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), gc;&#125;</span><br><span class="line">	<span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> pos[maxn];</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findx</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = findx(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fi = findx(x), fj = findx(y);</span><br><span class="line">	<span class="keyword">if</span>(fi != fj)</span><br><span class="line">		fa[fi] = fj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n = read(), a = read(), b = read();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		pos[i] = read();</span><br><span class="line">		mp[pos[i]] = i;</span><br><span class="line">		fa[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	x = n + <span class="number">1</span>, y = n + <span class="number">2</span>;</span><br><span class="line">	fa[x] = x, fa[y] = y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;pos[i]&lt;&lt;"  "&lt;&lt;a-pos[i]&lt;&lt; " "&lt;&lt;b-pos[i]&lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">// cout&lt;&lt;"!!"&lt;&lt;mp[a - pos[i]]&lt;&lt; " "&lt;&lt;mp[b - pos[i]]&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">if</span>(!mp[a - pos[i]])&#123;</span><br><span class="line">			merge(i, y);</span><br><span class="line">			<span class="comment">// merge(mp[])</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; </span><br><span class="line">			merge(mp[a - pos[i]], i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!mp[b - pos[i]])&#123;</span><br><span class="line">			merge(i, x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			merge(mp[b - pos[i]], i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;findx(i)&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x1 = findx(x), x2 = findx(y);</span><br><span class="line">	<span class="keyword">if</span>(x1 == x2)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;findx(i)&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">if</span>(findx(i) == x1)<span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"1"</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="luogu-P3295-SCOI2016-萌萌哒"><a href="#luogu-P3295-SCOI2016-萌萌哒" class="headerlink" title="luogu P3295 [SCOI2016]萌萌哒"></a>luogu P3295 [SCOI2016]萌萌哒</h2><p><a href="https://www.luogu.org/problem/P3295" target="_blank" rel="noopener">题目传送门</a></p>
<h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个序列$S$的长度为$n$以及$m$对区间$(l_1,r_1,l_2,r_2)$知每一对区间中的每个数都相同，求最终序列的方案数。</p>
<h3 id="大体思路-1"><a href="#大体思路-1" class="headerlink" title="大体思路"></a>大体思路</h3><p>有$m$对区间，每对区间中的每个数都相同。因为最终要求的是方案数，不用考虑单独的一种方案，考虑使用并查集维护，将每一对区间中的每一对数塞到一个并查集内部，最终答案就是$10^x＊９$($ｘ$为并查集的总数)。<br><br>此时合并的复杂度最差为$O(n^2)$，但是查询的复杂度仅为$O(n)$，无法接受。<br><br>然后通过细（<del>看</del>）致（<del>了</del>）思（<del>题</del>）考（<del>解</del>），发现可以使用类似ST表的倍增进行解决。设$id[j][i]$表示以$i$为左端点，长度为$2^j$的区间的编号，在合并时，直接合并代表两段区间的$(logn)$个区间即可。查询时，因为查询的是原始的$n$个节点，所以需要针对一段区间，将其合并下放。（实现方式与st表类似）。此时合并$O(logn)$，查询$O(logn)$，可以通过。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> tot, l1, r1, l2, r2;</span><br><span class="line"><span class="keyword">int</span> id[<span class="number">30</span>][maxn], num[maxn * <span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> fa[maxn * <span class="number">30</span>], h[maxn * <span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> bin[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findx</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = findx(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fi = findx(x), fj = findx(y);</span><br><span class="line">	<span class="keyword">if</span>(h[fi] &gt; h[fj])&#123;</span><br><span class="line">		swap(fi, fj);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(h[fi] == h[fj])h[fj] ++;</span><br><span class="line">	fa[fi] = fj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll now, ll a)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>, base = now;</span><br><span class="line">	<span class="keyword">while</span>(a)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a &amp; <span class="number">1</span>)</span><br><span class="line">			res = (<span class="number">1l</span>l * res * base) % mod;</span><br><span class="line">		base = (<span class="number">1l</span>l * base * base) % mod;</span><br><span class="line">		a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	bin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= <span class="number">20</span>; ++p)&#123;</span><br><span class="line">		bin[p] = (bin[p - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">20</span>; ++j)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">			id[j][i] = ++tot, num[tot] = i;</span><br><span class="line">			fa[tot] = tot, h[tot] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">20</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(l1 + bin[j] - <span class="number">1</span> &lt;= r1)&#123;</span><br><span class="line">				merge(id[j][l1], id[j][l2]);</span><br><span class="line">				l1 += bin[j], l2 += bin[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;1&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">20</span>; j; --j)&#123;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;j&lt;&lt; " ";</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + bin[j] - <span class="number">1</span> &lt;= n; ++i)&#123;</span><br><span class="line">			<span class="keyword">int</span> x = findx(id[j][i]), a = num[x];</span><br><span class="line">			merge(id[j - <span class="number">1</span>][a], id[j - <span class="number">1</span>][i]);</span><br><span class="line">			merge(id[j - <span class="number">1</span>][a + bin[j - <span class="number">1</span>]], id[j - <span class="number">1</span>][i + bin[j - <span class="number">1</span>]]);</span><br><span class="line">			<span class="comment">// cout&lt;&lt;"j"&lt;&lt;j&lt;&lt; " "&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;1&lt;&lt;endl;</span></span><br><span class="line">	ll cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(findx(id[<span class="number">0</span>][i]) == id[<span class="number">0</span>][i])cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;(<span class="number">9l</span>l * ksm(<span class="number">10</span>, cnt - <span class="number">1</span>)) % mod;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-25-分治相关"><a href="#7-25-分治相关" class="headerlink" title="7.25 分治相关"></a>7.25 分治相关</h1><h2 id="luogu-P1429-平面最近点对（加强版）"><a href="#luogu-P1429-平面最近点对（加强版）" class="headerlink" title="luogu P1429 平面最近点对（加强版）"></a>luogu P1429 平面最近点对（加强版）</h2><p><a href="https://www.luogu.org/problem/P1429" target="_blank" rel="noopener">题目传送门</a></p>
<h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>平面上有$n$个点$(2≤n≤200000)$，求距离最近的点对</p>
<h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h3><p>考虑直接枚举$n$个点，$O(n^2)$显然不可做。。。。<br><br>考虑分治，将平面沿$x$坐标的中位数裁开，这样要求的解被分成三类。</p>
<blockquote>
<p>1.在左侧的解<br><br>2.在右侧的解<br><br>3.横跨分割线的解<br></p>
</blockquote>
<p>解1与解2分开递归计算即可，重点考虑解3如何处理。<br><br>然后发现了一种优美的性质。<strong>对于一个点来说，其要想和横跨分治边界的另一个点更新最优解，最多只有$6$个点符合要求。</strong><br><br>设左侧的递归答案为$d1$，右侧的递归答案为$d2$，则当前最优解为$\delta=min(d1,d2)$,如果要想使$dis(x,y) &lt; \delta$，很明显另一个点的取值只能是一个$[\delta,2<em>\delta]$的矩形，又因为$\delta=min(d1,d2)$，则右侧每两个点之间的距离$dis\le\delta$，也就是说，最多只能有$6$个点被选择。<br><br>先按$x$轴第一关键字，$y$轴第二关键字排序,<br>每一层分治的复杂度为$O(6</em>n)$，总复杂度$O(logn)$。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">2</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">double</span> x, y;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">int</span> tmp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(node &amp;a, node &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">int</span> &amp;i, <span class="keyword">int</span> &amp;j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a[i].y &lt; a[j].y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> d = inf;</span><br><span class="line">	<span class="keyword">if</span>(l == r)<span class="keyword">return</span> d;</span><br><span class="line">	<span class="keyword">if</span>(l + <span class="number">1</span> == r)<span class="keyword">return</span> dist(l, r);</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">double</span> d1 = merge(l, mid);</span><br><span class="line">	<span class="keyword">double</span> d2 = merge(mid + <span class="number">1</span>, r);</span><br><span class="line">	d = min(d1, d2);</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(a[mid].x - a[i].x) &lt; d)&#123;</span><br><span class="line">			tmp[++cnt] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(tmp + <span class="number">1</span>, tmp + cnt + <span class="number">1</span>, cmp2);</span><br><span class="line">	<span class="keyword">double</span> d3;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">fabs</span>(a[tmp[j]].y - a[tmp[i]].y) &lt; d; j++)&#123;</span><br><span class="line">			d3 = dist(tmp[i], tmp[j]);</span><br><span class="line">			<span class="keyword">if</span>(d &gt; d3)d = d3;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">	sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.4lf"</span>, merge(<span class="number">1</span>, n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>新式骗分——模拟退火</title>
    <url>/2019/06/14/%E6%96%B0%E5%BC%8F%E9%AA%97%E5%88%86%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/</url>
    <content><![CDATA[<p>博客咕咕咕的时间有点长(似乎是太长了)</p>
<p>今天写一下模拟退火吧。。。发现了骗分的新大陆</p>
<!-- （!--似乎是太长了--!） -->
<a id="more"></a>
<h1 id="一：背景"><a href="#一：背景" class="headerlink" title="一：背景"></a>一：背景</h1><h3 id="模拟退火解决的是一种什么样的问题呢？"><a href="#模拟退火解决的是一种什么样的问题呢？" class="headerlink" title="模拟退火解决的是一种什么样的问题呢？"></a>模拟退火解决的是一种什么样的问题呢？</h3><blockquote>
<p>模拟退火算法（Simulate Anneal，SA）是一种通用概率演算法， <strong>用来在一个大的搜寻空间内找寻命题的最优解。</strong> 模拟退火是由S.Kirkpatrick, C.D.Gelatt和&gt;M.P.Vecchi在1983年所发明的。V.Čern&yacute;在1985年也独立发明此演算法。模&gt;拟退火算法是解决TSP问题的有效方法之一。<br>—— 来自百度百科</p>
</blockquote>
<p>照例引用百度百科。</p>
<p> 其实模拟退火就是一种解决问题的普遍方法。</p>
<h1 id="二：爬山算法及其优化"><a href="#二：爬山算法及其优化" class="headerlink" title="二：爬山算法及其优化"></a>二：爬山算法及其优化</h1><p> 针对一个求最值的问题，我们可以采用一种贪心的方法，被称作“爬山算法”。爬山算法指的就是每一步都将当前节点的值与其邻居节点比较，如果有更优值就取，否则就维持当前的解。很明显，这个算法可以找到一个局部最优解。但是其有一个致命的缺陷，那就是只能找到局部最优解，但是并不能保证找到的解是一个全局最优解。</p>
<p> <img src="https://s2.ax1x.com/2019/07/26/euJztA.png" alt="euJztA.png"></p>
<p> 就比如说上面这个图，当我们在D点出发，使用爬山算法，即可到达B点，很明显这既是局部最优解，又是全局最优解。但是如果从C点或E点出发，我们最后会到达A点，（<del>然后愉快的WA</del>）<br> 这种做法很明显是不行的，那么怎么使其变的正确 或者说大约正确呢？<br> 上文提到的三位大佬想出来了一个绝妙的解决方案：<br> 使用随机算法，使得每一次搜索到比当前解差的解时，都有一定概率接受这个解。但是光随机也是不行的，所以随着循环次数的增加，会不断降低接受更劣解的概率。这就是模拟退火的主要思想。</p>
<h1 id="三：具体实现"><a href="#三：具体实现" class="headerlink" title="三：具体实现"></a>三：具体实现</h1><p> 先定义一下变量及数组</p>
<blockquote>
<p>t: 温度 决定了接受更劣解的概率 与down一起决定了退火的时长 更高的初始温度意味着更精确的答案， 但也意味着需要更多的时间<br><br>down: 每一次循环降低t的系数，一般是 0.9 ~ 1 的一个实数<br><br>delta: 当前解与最优解的差<br><br>now_w: 目前得到的最优解<br><br>ew：当前解</p>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><p>1.透过最优解计算出当前解。<br><br>2.如果获得了更优解 直接接受<br>3.更劣解有概率接受<br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">sa</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> t = <span class="number">3000</span>;</span><br><span class="line">	<span class="keyword">while</span>(t &gt; <span class="number">1e-15</span>)&#123;</span><br><span class="line">		<span class="keyword">double</span> ex = ans_x + (rand() * <span class="number">2</span> - RAND_MAX) * t;</span><br><span class="line">		<span class="keyword">double</span> ey = ans_y + (rand() * <span class="number">2</span> - RAND_MAX) * t;</span><br><span class="line">		<span class="keyword">double</span> ew = get_eng(ex, ey);<span class="comment">//构造解的函数</span></span><br><span class="line">		<span class="keyword">double</span> delta = ew - ans_w;</span><br><span class="line">		<span class="keyword">if</span>(delta &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			ans_x = ex;</span><br><span class="line">			ans_y = ey;</span><br><span class="line">			ans_w = ew;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>(-delta / t) * RAND_MAX &gt; rand())&#123;</span><br><span class="line">			ans_x = ex;</span><br><span class="line">			ans_y = ey;</span><br><span class="line">		&#125;</span><br><span class="line">		t *= down;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>来自luoguP1337 [JSOI2004]平衡点 / 吊打XXX</p>
</blockquote>
<p> 值得注意的几个点：</p>
<blockquote>
<p>(rand() <em> 2 - RAND_MAX) </em> t : 求新解的方法<br><br>exp(-delta / t) * RAND_MAX &gt; rand()  : 来自前人的玄学判断</p>
</blockquote>
<p> <img src="https://s2.ax1x.com/2019/07/26/eu1JDH.png" alt="eu1JDH.png"></p>
<blockquote>
<p>模拟退火流程图</p>
</blockquote>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>可爱的数据结构——线段树</title>
    <url>/2019/03/30/%E5%8F%AF%E7%88%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h1 id="可爱的数据结构——线段树"><a href="#可爱的数据结构——线段树" class="headerlink" title="可爱的数据结构——线段树"></a>可爱的数据结构——线段树</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是数据结构呢？"><a href="#什么是数据结构呢？" class="headerlink" title="什么是数据结构呢？"></a>什么是数据结构呢？</h3><blockquote>
<p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关 </p>
<p>—-来自百度百科<br><a id="more"></a><br>简单来说，数据结构就是通过合理的方式在计算机中存储数据，来达到修改、查询的目的。</p>
</blockquote>
<p><strong>几个例子</strong><br>（纯个人看法）</p>
<p>朴素的数据结构</p>
<pre><code>数组（-_-）
链表
队列
栈
</code></pre><p>看起来高端一些的数据结构</p>
<pre><code>矩阵
哈希表（hash）
堆
树状数组
</code></pre><p>更高级的数据结构    </p>
<pre><code>线段树
各种平衡树
主席树
</code></pre><h3 id="什么是线段树呢？"><a href="#什么是线段树呢？" class="headerlink" title="什么是线段树呢？"></a>什么是线段树呢？</h3><blockquote>
<p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p>
<p>—-依然来自百度百科</p>
</blockquote>
<p>换句话说，就是把一个区间变成一个多层的树形结构，以一种二分与递归的思想实现高效的区间操作</p>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>写一个数据结构，要求支持在O(logn)的时间复杂度内支持区间加与区间和。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流初识———EK</title>
    <url>/2018/12/16/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%88%9D%E8%AF%86%E2%80%94%E2%80%94EK/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当初刚开始学OI的时候，对各种奇怪的中高级算法抱有极大的兴趣（结果自然是看不懂-_-），网络流则是排在前列的几大算法之一（话说我是如何在连建图和SPFA都搞不明白的情况下看进去的…）。</p>
<p>如今过了一年（技术还是没有什么长进，该不会的还是不会），重新看了一篇网络流与费用流，似乎。。。有那么一点理解了，谨以此文，来表达我对网络流的一点看法。</p>
<h1 id="什么是网络流？"><a href="#什么是网络流？" class="headerlink" title="什么是网络流？"></a>什么是网络流？</h1><p>“网络流(network-flows)是一种类比水流的解决问题方法，与线性规划密切相关。”（来自百度百科）</p>
<p>举个例子，从某地要向某地输水，中间有许多粗细不同的管子，网络流算法解决的就是利用这些管子怎样使单位时间总输送量最大化的问题。 </p>
<a id="more"></a>
<h1 id="如何解决网络流问题？"><a href="#如何解决网络流问题？" class="headerlink" title="如何解决网络流问题？"></a>如何解决网络流问题？</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>会建图，会dfs、bfs（似乎只需要这些。。。）</p>
<h2 id="在开始之前…"><a href="#在开始之前…" class="headerlink" title="在开始之前…"></a>在开始之前…</h2><p>我们先来明晰几个概念：</p>
<p><strong>点的属性：</strong></p>
<pre><code>  源点(s): 一切的开始，入度为0

  汇点(t): 一切的结束，出度为0
</code></pre><p><strong>边的属性：</strong></p>
<pre><code>首先很明显图应该是DAG
流量(flow)：每条边能通过的最大值
</code></pre><h2 id="如何建图？"><a href="#如何建图？" class="headerlink" title="如何建图？"></a>如何建图？</h2><p>先不负责任的提出解决方案：对于每一条有向边，建一条与之方向相反（出入点相反），流量为0的边。</p>
<p><strong>为什么？</strong></p>
<p>我们先来明确一下网络流的工作原理：</p>
<p>每一次搜索结束后，便会找到一条从源点到汇点的路径（这条路径叫增广路），且该路径上的边的流量均大于0，通过这条路可以增加的流量便是这条路径中的最小流量（自行理解一下）。然后在每次搜索结束时，将这条路径上的边的流量减去可以增加的流量。重复此过程直到找不出路径为止。</p>
<p>这种看起来就像是贪心的算法很明显是错的… 你搜索到的流量会与你搜索的路径的顺序有关，这怎么行！</p>
<p>所以在建图时，要采用上文所述的方式，建一条反向边，并且在搜索完毕后减去增加流量的同时，在反向边加上增加的流量，这样在下一次搜索增广路时可以沿着反向边把流量回退，从而实现发现真正意义上的最大流的目的。</p>
<h1 id="上代码！"><a href="#上代码！" class="headerlink" title="上代码！"></a>上代码！</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">51000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p, m, f, u, v;</span><br><span class="line"><span class="keyword">int</span> s, t;</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nt, to, flow, val;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">        nt = n, to = t, flow = f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> h[maxn], c[maxn], tot = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;e[++tot].<span class="built_in">set</span>(h[a], b, c), h[a] = tot; e[++tot].<span class="built_in">set</span>(h[b], a, <span class="number">0</span>), h[b] = tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> dis[maxn], vis[maxn], pre[maxn], last[maxn], flow[maxn]; <span class="comment">//存路径和更新的流量</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)pre[i] = <span class="number">-1</span>, vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(last, <span class="number">-1</span>, <span class="keyword">sizeof</span>(last));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">    q.push(s);</span><br><span class="line">    pre[s] = inf;</span><br><span class="line">    flow[s] = inf;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[now]; i != <span class="number">-1</span>; i = e[i].nt)&#123;</span><br><span class="line">            <span class="keyword">int</span> nex = e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(e[i].flow &gt; <span class="number">0</span> &amp;&amp; vis[nex] == <span class="number">0</span>)&#123;</span><br><span class="line">                pre[nex] = now;</span><br><span class="line">                last[nex] = i;</span><br><span class="line">                <span class="keyword">if</span>(e[i].flow &lt; flow[now])</span><br><span class="line">                    flow[nex] = e[i].flow;</span><br><span class="line">                <span class="keyword">else</span> flow[nex] = flow[now];</span><br><span class="line">                <span class="keyword">if</span>(!vis[nex])&#123;</span><br><span class="line">                    vis[nex] = <span class="number">1</span>;</span><br><span class="line">                    q.push(nex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[t] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ek</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s, t))&#123;</span><br><span class="line">        maxflow += flow[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pre[i])&#123;</span><br><span class="line">            e[last[i]].flow -= flow[t];</span><br><span class="line">            e[last[i] ^ <span class="number">1</span>].flow += flow[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) h[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> u, v, f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u,&amp;v,&amp;f);</span><br><span class="line">        adde(u, v, f);</span><br><span class="line">    &#125;</span><br><span class="line">    ek(s, t);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxflow&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
</search>
