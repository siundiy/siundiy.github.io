<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[莫比乌斯反演]]></title>
    <url>%2F2019%2F08%2F09%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[前言这种神仙玩意儿一听就非常高端。但是如果认真学习的话，还是比想象中的要简单的。话说本来想拿去装13的却被初三小朋友痛斥过于娱乐… 参考资料感谢： 莫比乌斯反演学习笔记——by Panda2134莫比乌斯反演学习笔记——by DimensionTripper各种能百度到的资料 前置1：数论、积性函数什么叫数论函数？ 在数论上，算术函数（或称数论函数）指定义域为正整数、陪域为复数的函数——来自百度百科 无法识别的表达方式…换句话说，数论函数就相当于定义域为$N^+$的函数。注1：陪域就相当于可以包含值域所有的集合。 如图，如果A是$f(x)$的值域，那么B与C都可以是$f(x)$的陪域。注2：复数是指形如$z=a+bi$的数…为全部实数与虚数的集合。 什么叫积性函数？指当$gcd(a,b)=1$时满足$f(ab)=f(a)f(b)$的数论函数。还有一种更加特殊的情况，即d对于任意$a,b \in Z$时都满足$f(ab)=f(a)f(b)$的函数，被称为完全积性函数。由于完全积性函数相较于积性函数并没有什么更加可爱的性质，故下文仅对积性函数进行讨论。 有哪些常见的积性函数？ $\mu(n)$：本文主角，莫比乌斯函数。 \mu(n)= \begin{cases} \text{1}&&\text{(n==1)}\\ \text{$(-1)^k$}&&\text{(当$n=p_1*p_2*...*p_k$时)}\\ \text{0}&&\text{(当n存在平方因子时)}\\ \end{cases}$1(n)$：不变的函数，恒定值为1$\epsilon(n)$：单位元，当且仅当$n=1$时$\epsilon(n)=1$，其他情况$\epsilon(n)=0$，即 \epsilon(n)= \begin{cases} \text{1}&&\text{(n==1)}\\ \text{0}&&\text{otherwise} \end{cases}$id(n)$：就是$n$的大小，即$id[n]=n$ $\varphi(n)$：欧拉函数，指小于$n$的正整数中与$n$互质数的数目。$gcd(n,k)$：当$k$固定时，$n$的最大公因子。$d(n)$：$n$的正因子数目$σ(n)$：$n$的所有正因子之和 其中加粗的函数与莫比乌斯反演有比较重要的关系。 积性函数的性质1.对于任意积性函数$f$，$f(1)=1$。 显然，$f(n)=f(n)f(1)\rightarrow f(1)=1$ 2.对于一个大于1的正整数$N$，设$N=\prod p_i ^ {a_i}$且$\forall p_i \not= p_j$（就是将$N$质因数分解，则对于一个积性函数$f$： f(n)=f(\prod p_i ^ {a_i})=\prod f(p_i ^ {a_i}) 根据定义显然。 前置2：狄利克雷卷积又是一个听起来非常高端的玩意儿…设$f(n), g(n), h(n)$为数论函数，且 h(n)=f(n)*g(n)，则 h(n)=\sum_{d|n}f(d)g(\frac{n}{d})几条性质1.交换律：{(f*g)(n)=(g*f)(n)}；2.结合律：((f*g)*h)(n)=(f*(g*h))(n)；3.分配律：定义两个数论函数f(n),g(n)的加法为逐项相加，即(f+g)(n)=f(n)+g(n)，那么(f+g)*h=f*h+g*h；4.积性函数*积性函数=积性函数，即当f(n),g(n)为积性函数时，h(n)=f(n)*g(n)也为积性函数。证明： 设：$n=a*b$，且$gcd(a,b)=1$，则 \begin{split} h(n) &&=\sum_{d|n}f(d)g(\frac{n}{d})\\ &&=\sum_{d1|a}\sum_{d2|b}f(d1d2)g(\frac{a}{d1}\frac{b}{d2})\\ &&=\sum_{d1|a}\sum_{d2|b}f(d1)f(d2)g(\frac{a}{d1})g(\frac{b}{d2})\\ &&=\sum_{d1|a}f(d1)g(\frac{a}{d1})\sum_{d2|b}f(d2)g(\frac{b}{d2})\\ &&=h(a)*h(b)\\ \end{split} 5.$(f*e)=f$ 证明： \begin{split} (f*e)(n)&&=e*f(n)\\ &&=\sum_{d|n}e(d)*f(\frac{n}{d})\\ &&=f(n)\\ \end{split} 注：非积性函数亦可卷积。 前置3：莫比乌斯函数几条性质1.$\mu(n)$是积性函数证明： 因为 \begin{split} \begin{cases} \mu(p_i^{a_i})=-1&&(a_i==-1)\\ \mu(p_i^{a_i})=0&&(a_i\ge 2)\\ \end{cases} \end{split}所以 \mu(n)=\prod p_i^{a_i}由积性函数性质2得：$\mu$是积性函数。 2.$\mu*1=\epsilon$ 证明： 因为$\mu$、$1$、$\epsilon$均为积性函数所以原命题转化为证明： (\mu * 1)(p^k)=\epsilon(p^k)其中 (\mu * 1)(p^k)=\sum_{j=0}^{k} \mu(p^j)1(p^{k-j})而 \begin{split} \mu(p^j)= \begin{cases} 1 &&(j==0)\\ -1 &&(j==1)\\ 0 &&(j\ge 2)\\ \end{cases} \end{split}所以 \begin{split} \sum_{j=0}^{k} \mu(p^j)1(p^{k-j})= \begin{cases} 1-1+0+0+0...&&(k>0)\\ 1&&(k==0) \end{cases} \end{split}即原命题成立 该命题还有另一种表达方式： \sum_{d|n} \mu(d)=[n==1]因为： \sum_{d|n}\mu(d)=\sum_{d|n}\mu(d)*1=(\mu*1)(n)=\epsilon(n)注：其中$[$ &nbsp; $]$ 表示艾佛森括号，方括号其中的条件满足则为1，不满足则为0，即： \begin{aligned}\\ [P]&=1 &\text{(If P is true)}\\ [P]&=0 &\text{(Otherwise)} \end{aligned}正题：莫比乌斯反演形式一：已知$f(x),g(x)$为两个数论函数，如果 f(n)=\sum_{d|n}g(d)则 g(n)=\sum_{d|n}f(d)*\mu(\frac{n}{d})证明1：（狄利克雷卷积法） 已知 f(n)=\sum_{d|n}g(d)改写成卷积的形式 f(n)=g(n)*1等式两侧同时$*\mu$ f*\mu=g*1*\mu由莫比乌斯函数性质知：$\mu*1=\epsilon$，即 f*\mu=g*\epsilon=g根据狄利克雷卷积展开，则 g(n)=\sum_{d|n}f(d)*g(\frac{n}{d}) 证明2：(定义法) 由$f(n)$的定义知： \begin{aligned} \sum_{d|n}\mu(d)f(\frac{n}{d})=&\sum_{d|n}\mu(d)\sum_{i|\frac{n}{d}}g(i)\\ =&\sum_{d|n}\sum_{i|\frac{n}{d}}\mu(d)g(i)\\ =&\sum_{i|n}\sum_{d|\frac{n}{i}}\mu(d)g(i)\\ =&\sum_{i|n}g(i)\sum_{d|\frac{n}{i}}\mu(d)\\ \end{aligned}根据莫比乌斯函数的性质：当且仅当$\frac{n}{i}==1$时，$\sum_{d|\frac{n}{i}}\mu(d)=1$，所以： \sum_{i|n}g(i)\sum_{d|\frac{n}{i}}\mu(d)=g(n) 形式二：如果 g(n)=\sum_{n|d}f(d)那么 f(n)=\sum_{n|d}\mu(\frac{d}{n})g(d)证明： \begin{aligned} \sum_{n|d}\mu(\frac{d}{n})g(d)=&\sum_{k=1}^{+\infty}\mu(k)g(nk)\\ =&\sum_{k=1}^{+\infty}\mu(k)\sum_{nk|t}f(d)\\ =&\sum_{n|t}f(t)\sum_{k|(t|n)}\mu(k)\\ =&\sum_{n|t}f(t)[t==n]\\ =&f(n) \end{aligned} 具体实现咕到下篇博客里…]]></content>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组哪里难？]]></title>
    <url>%2F2019%2F08%2F08%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%93%AA%E9%87%8C%E9%9A%BE%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言杂谈感谢 2009年国家集训队论文后缀数组 最详细讲解luoguP3809 【模板】后缀排序 题解 luoguP2408 不同子串个数 题解 以及 来自ZhengRuIOI的课件 让本蒟蒻大概明白了这种算法 什么是后缀数组？后缀数组指的是一个一维的数组，将一个给定的字符串的每一个后缀以其起始位置作为编号，按照字典序的大小排好序后放到一个数组中，我们便得到了一个后缀数组。 有什么用？ 后缀数组——处理字符串的有力工具——罗穗骞 如上所述，后缀数组可以解决许多花里胡哨的字符串问题，尤其是子串相关问题。后缀数组相较后缀自动机更易实现，且有更优秀的空间复杂度，而且许多后缀自动机的操作后缀数组都能完成。 实现方法一般通用的方法有倍增法与DC3法，倍增法的时间复杂度为$O(logn)$，而DC3法则以思维难度的提升与代码实现方式的复杂化使时间复杂度提升为$O(n)$。由于本人过于菜(懒)，在本文章中暂时只介绍倍增法。 配套食用单纯的后缀数组虽然看上去非常牛，但是我们一般不仅仅要需要后缀的信息，更希望知道子串的相关信息，这时，就要用到LCP（最长公共前缀）这种奇妙的东西和$height$数组了。 具体实现数组设定后缀数组相交于以前学过的其他算法，有着更加复杂的数组设定，下面加以综述。 $sa[i]$：排好序的后缀数组第$i$位的后缀开头位置$rk[i]$：开头位置为$i$的后缀在后缀数组中的位置$x[i]$：基数排序时的第一关键字排名（待会会讲）$y[i]$：基数排序的第二关键字排名，同时也是在$sa$数组计算过程中存储的暂时排名$c[i]$：基数排序所用的桶$height[i]$：$sa[i]$与$sa[i-1]$的最长公共前缀 很明显$sa[i]$与$rk[i]$互为逆运算。 前置：基数排序一种奇妙的可以实现$O(n)$ 排序的方法与桶排类似，不过是将每一个数拆分成个位、十位…先按照个位插入桶中，再逐个放入答案数组中，这样的一次操作可以保证个位有序。再按照十位插入桶中，放入答案数组中，这一次操作后会使十位有序，因为个位已经有序了，那么前两位就全部有序了。值得注意的一点，在从桶中弹出的时候，应该倒序枚举($n \rightarrow 1$)，这样才能保证之前排好的顺序不会乱掉。举个例子吧： 21 18 12 42 56 66 22 46 先按个位排 2112 42 2256 66 4618 然后 21 12 42 22 56 66 46 18 再按十位排 12 18 21 2242 465666 得到答案 12 18 21 22 42 46 56 66 求后缀数组的倍增法（$SA()$）我们要判断两个后缀的字典序，当然可以$O(n)$的去扫一遍，不过面对全部后缀，使用快速排序的话，$O(n^2 logn)$显然无法接受。这时，提出一种新的方法——倍增法，其做法是这样的：首先针对每一位上的子串获得一个排名。 然后我们将第$i$位的排名与$i+1$位合并 在这个可爱的例子中，我们已经完成了排序，如果两次没有完成，那么就不断沿着当前点往后的$2^k$合并，很明显，如果每一个后缀的排名都不同的话，算法就可以停止了。代码长这样123456789101112131415161718192021222324#define fr(i, j, k) for(register int i = j; i &lt;= k; ++i)#define rf(i, j, k) for(register int i = j; i &gt;= k; --i)void SA()&#123; fr(i, 1, n)c[x[i] = a[i]]++;//塞到桶里 fr(i, 2, m)c[i] += c[i - 1];//做个前缀和 rf(i, n, 1)sa[c[x[i]]--] = i;//第一次的排名 for(int k = 1; k &lt;= n; k &lt;&lt;= 1)&#123;//枚举2的k次 int num = 0; fr(i, n - k + 1, n)y[++num] = i;//最后的k个数很明显没有第二关键字，所以它们在y数组的最前面 fr(i, 1, n)if(sa[i] &gt; k)y[++num] = sa[i] - k;//如果当前的排名大于k，就可以作为别人的第二关键字，塞到第二关键字中 fr(i, 1, m)c[i] = 0; fr(i, 1, n)c[x[i]]++; fr(i, 2, m)c[i] += c[i - 1]; rf(i, n, 1)sa[c[x[y[i]]]--] = y[i], y[i] = 0;//基数排序 swap(x, y);//准备通过旧的x生成新的x x[sa[1]] = 1; num = 1; fr(i, 2, n)&#123; x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++num; //通过排好序的sa[i]生成新的第一关键字 &#125; if(num == n)break;//排名全都不一样就可以退出了 m = num;//数据的范围变成只有num个 &#125;&#125; 最大公共前缀（LCP）其实后缀数组本身能解决的问题有限，我们很多时候都要与$LCP$和$height$数组配套使用。 怎么求$height$？直接暴力$O(n)$求解每个$height[i]$显然不可行，但是某些极其牛的人证出了一条不那么显然的结论： height[i] \ge height[i - 1] - 1下面我来尝试以一种更加浅显的方式来证明。首先考虑$i$在原串中的前一位$i-1$，再考虑$i-1$在后缀数组中的前一位$k$。很明显分一下两种情况：第一种情况$k$与$i-1$没有公共前缀，即$height[i-1] == 0$，此时结论显然成立。 第二种情况如上图，$k$与$i-1$有公共前缀，即$height[i] \not= 0$。此时考虑k在原串中的后一位$k+1$与$i$之间的公共前缀，可以明显地得到以下结论： 1.在排好序的后缀数组中，$k+1$在$i$的前面。(因为$k+1$是$k$的后缀，$i$是$i-1$的后缀)2.$k+1$与$i$之间的最长公共前缀为$height[i-1]-1$ 那么也就说明了，$height[i]$的大小至少为$height[i-1]-1$，因为如果有一个后缀插在$k+1$与$i$中间的话，它与$i$的最长公共公共前缀不可能会比$k+1$与$i$的最长公共前缀小。就这样，我们得到了一个$O(n)$的解法来求解$height$数组。 代码12345678910void get_height()&#123; int k = 0, j; fr(i, 1, n)rk[sa[i]] = i;//获取排名 fr(i, 1, n)&#123; j = sa[rk[i] - 1];//j是i在sa数组中的前一位 if(k) k--;//因为是&gt;= height[i-1] - 1，所以要-1 while(a[i + k] == a[j + k])k++; height[rk[i]] = k; &#125;&#125; 一道模版题luoguP3809 【模板】后缀排序直接求出$sa$数组即可 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;#define fr(i, j, k) for(register int i = j; i &lt;= k; ++i)#define rf(i, j, k) for(register int i = j; i &gt;= k; --i)const int maxn = 1e6 + 10;int m, n;int x[maxn], y[maxn], c[maxn];char s[maxn];int sa[maxn], rk[maxn];void SA()&#123; fr(i, 1, n)c[x[i] = s[i]]++; fr(i, 2, m)c[i] += c[i - 1]; rf(i, n, 1)sa[c[x[i]]--] = i; for(int k = 1; k &lt;= n; k &lt;&lt;= 1)&#123; int num = 0; fr(i, n - k + 1, n)y[++num] = i; fr(i, 1, n)if(sa[i] &gt; k)y[++num] = sa[i] - k; fr(i, 1, m)c[i] = 0; fr(i, 1, n)c[x[i]]++; fr(i, 2, m)c[i] += c[i - 1]; rf(i, n, 1)sa[c[x[y[i]]]--] = y[i], y[i] = 0; swap(x, y); x[sa[1]] = 1; num = 1; fr(i, 2, n)&#123; x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++num; &#125; if(num == n)break; m = num; &#125; fr(i, 1, n)printf("%d ", sa[i]);&#125;int main()&#123; gets(s+1); n = strlen(s + 1); m = 122; SA();&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[评论的使用方法]]></title>
    <url>%2F2019%2F08%2F06%2F%E8%AF%84%E8%AE%BA%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[评论系统来自valine 1. 昵称顾名思义就是你评论之后显示的名称啦 2. 邮箱获取头像用的 请自行登录或注册Gravatar，然后修改自己的头像。（详情请咨询度娘） 评论的时候，留下在Gravatar注册时所使用的邮箱即可。 3. 链接可选项，填写后会在你的评论上自动生成一个链接（记得加 https://），效果如图： 4. 内容支持emoji与markdown 全部完成后点击发布即可！]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-7题解综合2——DP]]></title>
    <url>%2F2019%2F08%2F04%2F2019-7-29%E9%A2%98%E8%A7%A3%E7%BB%BC%E5%90%88%2F</url>
    <content type="text"><![CDATA[7.29 “简单”DP luogu P2467 [SDOI2010]地精部落题目传送门 题目大意一个序列符合要求，当且仅当其是一个$1 \sim n$的排列，且每一个$a[i]$ 满足$a[i-1]\le a[i]$且$a[i]\ge a[i+1]$ 或者满足$a[i-1]\ge a[i]$且$a[i]\le a[i+1]$ 求长度为$n$的合法序列方案数 大体思路神仙题。。。。显然有以下性质： 1.当$i$与$i+1$不相邻时，交换$i$与$i+1$仍会得到一个合法的解如:$3 2 4 1 5 \rightarrow 3 1 4 2 5$ 2.一串序列$a[i]$，$i\in [1,n]$满足条件时，则$(i+1)-a[i]$亦满足条件如:$3 2 4 1 5 \rightarrow 3 4 2 5 1$ 3.满足条件的序列具有对称性 如:$3 2 4 1 5 \rightarrow 5 1 4 2 3$ 则设$dp[i][j]$表示当前为前$i$个数的排列，且首位是$j$且为山峰的方案数。 \! \begin{split} & 由性质1可知: \!\begin{cases} \text{当$j$与$j-1$不相邻时，$dp[i][j]=dp[i][j-1]$}\\ \end{cases}\\ & 由性质2可知: \!\begin{cases} \text{首位做山峰的方案数=首位做山谷的方案数}\\ \downarrow \\ \text{(也就是说最后的答案是$2*\sum_{i=1}^n dp[n][i]$)}\\ \\ \text{当$j$与$j-1$相邻时，}\\ \text{方案数即为$i-1$个数，$j-1$为首位且为山谷的方案数}\\ \text{$\downarrow$}\\ \text{即$dp[i][j]=dp[i-1][(i-1+1)-(j-1)]$} \end{cases} \end{split}综上，$dp[i][j]=dp[i][j-1]+dp[i-1][i-j+1]$ 代码12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int n, p;long long ans;long long dp[2][4300];int main()&#123; scanf("%d%d", &amp;n, &amp;p); dp[0][2] = 1; for(int i = 3; i &lt;= n; ++i)&#123; for(int j = 2; j &lt;= i; ++j)&#123; dp[i &amp; 1][j] = (dp[i &amp; 1][j - 1] + dp[(i - 1) &amp; 1][i - j + 1]) % p; &#125; &#125; for(int i = 1; i &lt;= n; ++i)&#123; ans = ans + dp[n &amp; 1][i] % p; &#125; printf("%lld\n", (ans &lt;&lt; 1) % p); return 0;&#125; luogu P2519 [HAOI2011]problem a题目传送门 题目大意一次考试共有$n$个人参加，第$i$个人说：“有$ai$个人分数比我高，$bi$个人分数比我低。”问最少有几个人没有说真话(可能有相同的分数) 大体思路先进行补集转化，目标变成求说真话的人数。有$ai$个人分数比我低，$bi$个人分数比我高，就意味着$[ai+1,n-bi-1]$是相同的数。问题转化为使$k$段区间不重叠且权值和最大。按照右端点排序之后dp即可。几点细节: 1.合法解可以有完全重合的区间，但是一段区间最多只能有区间长度个说真话的人。2.要特判$ai \ge bi$的情况 设$f[i]$表示当前为第$i$位的区间最大值，则 f[i]=max(f[i-1],f[L[j]-1]+w[j]) (R[j]==i)代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;#define gc ch = getchar()int read()&#123; int ret = 0, f = 1; char gc; while(!isdigit(ch) &amp;&amp; (ch ^ '-'))gc; if(!(ch ^ '-'))f = -1, gc; while(isdigit(ch))&#123;ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'), gc;&#125; return ret * f;&#125;#undef gcconst int maxn = 1e5 + 10;int n;struct node&#123; int l, r; bool operator &lt; (const node &amp;a)const&#123; return r == a.r ? l &lt; a.l : r &lt; a.r; &#125;&#125;p[maxn];int w[maxn], L[maxn], R[maxn];int f[maxn];int a, b, tot = 0;int main()&#123; #ifndef ONLINE_JUDGE freopen("test.in", "r", stdin); #endif n = read(); for(int i = 1; i &lt;= n; ++i)&#123; a = read(), b = read(); // cout&lt;&lt;a&lt;&lt; " "&lt;&lt;b&lt;&lt;endl; p[i].l = a + 1, p[i].r = n - b; &#125; sort(p + 1, p + n + 1); for(int i = 1; i &lt;= n; ++i)&#123; if(p[i].l &gt; p[i].r)continue; // cout&lt;&lt;p[i].l&lt;&lt; " "&lt;&lt;p[i].r&lt;&lt;endl; if(p[i].l != p[i - 1].l || p[i].r != p[i - 1].r)tot++; // cout&lt;&lt;tot&lt;&lt;endl; w[tot] = min(w[tot] + 1, p[i].r - p[i].l + 1); L[tot] = p[i].l, R[tot] = p[i].r; &#125; // for(int i = 1; i &lt;= tot; ++i)&#123; // cout&lt;&lt;w[i]&lt;&lt; " "&lt;&lt;L[i]&lt;&lt; " "&lt;&lt;R[i]&lt;&lt;endl; // &#125; int j = 1; for(int i = 1; i &lt;= n; ++i)&#123; // int j = 1; f[i] = f[i - 1]; // cout&lt;&lt;f[i]&lt;&lt;endl; while(j &lt;= tot &amp;&amp; R[j] == i)&#123; // cout&lt;&lt;j&lt;&lt;endl; // cout&lt;&lt;L[j]&lt;&lt;endl; f[i] = max(f[i], f[L[j] - 1] + w[j]); j++; &#125; &#125; printf("%d\n", n - f[n]); return 0;&#125; CF1016C Vasya And The Mushrooms题目传送门 题目大意给定一个$2n$的方格阵，经过一个格子获得的价值为$ai$进入时间,求从左上角出发遍历一次全部格子获得的价值最大值。 大体思路很明显的一道dp题。。。稍加思考便能发现能够遍历整个方阵的方案可能是长这样的 或者是长这样的 总之就是先是一个蛇形结构，然后接一个U形结构，很明显这两个部分都是可以预处理的。 设$f[i][0/1]$表示蛇形部分进行到第$i$列，第$0/1$行的权值则 \begin{split} &f[i][0]= \begin{cases} \text{f[i-1][0]+(2*(i-1))*val[i][0] (i&1==0)}\\ \text{f[i][1]+(2*(i-1)+1)*val[i][0] (i&1!=0)}\\ \end{cases}\\ &f[i][1]= \begin{cases} \text{f[i][0]+(2*(i-1)+1)*val[i][1] (i&1==0)}\\ \text{f[i-1][1]+(2*(i-1))*val[i][1] (i&1!=0)}\\ \end{cases} \end{split}U形部分的计算方法： \begin{split} &\text{自左向右的部分}\\ &\sum_{i=k}^n vi*[T+(i-k)]\\ &\downarrow\\ &\sum_{i=k}^n vi*i+\sum_{i=k}^n vi*(T-k)\\ \\ &\text{自右向左的部分}\\ &\sum_{i=k}^n vi*[T+(n-k)+(n-k-i+1)]\\ &\downarrow\\ &\sum_{i=k}^n vi*(T+2*n-2*k+1)-\sum_{i=k}^n vi*i\\ \end{split}$k$为U形部分开始的位置设$g[i][0/1]$表示U形部分从0/1列， i行开始的权值，$sum[i][0/1]$表示本行距离结尾的权值和$nxt[i][0/1]$表示距离结尾的权值与列数乘积之和则 12345678if(!(i &amp; 1))&#123; g[i][1] = nxt[i][1] + (2 * (i - 1) - i) * sum[i][1]; g[i][1] += (2 * (i - 1) + 2 * n - i + 1) * sum[i][0] - nxt[i][0];&#125;else &#123; g[i][0] = nxt[i][0] + (2 * (i - 1) - i) * sum[i][0]; g[i][0] += (2 * (i - 1) + 2 * n - i + 1) * sum[i][1] - nxt[i][1];&#125; 最后的答案就是每一种合法的蛇形与U形组合取$max$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;#define gc ch = getchar()int read()&#123; int ret = 0, f = 1; char gc; while(!isdigit(ch) &amp;&amp; (ch ^ '-'))gc; if(ch == '-')f = -1, gc; while(isdigit(ch))&#123;ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'), gc;&#125; return ret * f;&#125;ll readll()&#123; ll ret = 0, f = 1; char gc; while(!isdigit(ch) &amp;&amp; (ch ^ '-'))gc; if(ch == '-')f = -1, gc; while(isdigit(ch))&#123;ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'), gc;&#125; return ret * f;&#125;#undef gcconst int maxn = 3 * 1e5 + 10;int n;ll ans;ll val[maxn][2];ll sum[maxn][2], nxt[maxn][2];ll f[maxn][2], g[maxn][2];int main()&#123; #ifndef ONLINE_JUDGE freopen("test.in", "r", stdin); #endif n = read(); for(int i = 1; i &lt;= n; ++i)&#123; val[i][0] = readll(); // cnt[i][0] = val[i][0] * i; &#125; for(int i = 1; i &lt;= n; ++i)&#123; val[i][1] = readll(); // cnt[i][1] = val[i][1] * i; &#125; for(int i = n; i &gt;= 1; --i)&#123; sum[i][0] = sum[i + 1][0] + val[i][0]; sum[i][1] = sum[i + 1][1] + val[i][1]; nxt[i][0] = nxt[i + 1][0] + val[i][0] * i; nxt[i][1] = nxt[i + 1][1] + val[i][1] * i; &#125; for(int i = 1; i &lt;= n; ++i)&#123; if(i &amp; 1)&#123; f[i][0] = f[i - 1][0] + (2 * (i - 1)) * val[i][0]; f[i][1] = f[i][0] + (2 * (i - 1) + 1) * val[i][1]; &#125; else&#123; f[i][1] = f[i - 1][1] + (2 * (i - 1)) * val[i][1]; f[i][0] = f[i][1] + (2 * (i - 1) + 1) * val[i][0]; &#125; &#125; // for(int i = 1; i &lt;= n; ++i)&#123; // cout&lt;&lt;"sum"&lt;&lt;sum[i][0]&lt;&lt; " "&lt;&lt;sum[i][1]&lt;&lt;endl; // cout&lt;&lt;"nxt"&lt;&lt;nxt[i][0]&lt;&lt; " "&lt;&lt;nxt[i][1]&lt;&lt;endl; // &#125; for(int i = 1; i &lt;= n; ++i)&#123; if(!(i &amp; 1))&#123; g[i][1] = nxt[i][1] + (2 * (i - 1) - i) * sum[i][1]; g[i][1] += (2 * (i - 1) + 2 * n - i + 1) * sum[i][0] - nxt[i][0]; &#125; else &#123; g[i][0] = nxt[i][0] + (2 * (i - 1) - i) * sum[i][0]; g[i][0] += (2 * (i - 1) + 2 * n - i + 1) * sum[i][1] - nxt[i][1]; &#125; &#125; // for(int i = 1; i &lt;= n; ++i)&#123; // cout&lt;&lt;"!!"&lt;&lt;f[i][0]&lt;&lt; " "&lt;&lt;f[i][1]&lt;&lt;endl; // cout&lt;&lt;g[i][0]&lt;&lt; " "&lt;&lt;g[i][1]&lt;&lt;endl; // &#125; for(int i = 0; i &lt;= n; ++i)&#123; // cout&lt;&lt;f[i][1]&lt;&lt; " "&lt;&lt;g[i + 1][1]&lt;&lt;endl; // cout&lt;&lt;f[i][0]&lt;&lt; " "&lt;&lt;g[i + 1][0]&lt;&lt;endl; if(i &amp; 1)&#123; ans = max(ans, f[i][1] + g[i + 1][1]); &#125; else &#123; ans = max(ans, f[i][0] + g[i + 1][0]); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; CF467C George and Job题目传送门 题目大意给出一组有$n$个整数的数列$p_1,p_2,…,p_n$，你需要挑出$k$组长度为$m$的数，要求这些数互不重叠，即：$[l_1,r_1],[l_2,r_2],…,l_k,r_k$ 且使选出的数和值最大 大体思路直接依照题意dp即可。设$f[i][j]$为当前在第$i$位，选了$j$个区间时的最大值，$s[i]$为以$i$为起始点的长度为$m$的权值之和 转移为：$f[i][j]=max(f[i-1][j],f[i-m][j-1]+s[i])$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;const int maxn = 5010;#define gc ch = getchar()int read()&#123; int ret = 0, f = 1;char gc; while(!isdigit(ch) &amp;&amp; (ch ^ '-'))gc; if(!(ch ^'-'))f = -1, gc; while(isdigit(ch))&#123;ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'), gc;&#125; return ret * f;&#125;long long readll()&#123; long long ret = 0, f = 1;char gc; while(!isdigit(ch) &amp;&amp; (ch ^ '-'))gc; if(!(ch ^'-'))f = -1, gc; while(isdigit(ch))&#123;ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'), gc;&#125; return ret * f;&#125;#undef gcint n, m, k;long long p[maxn];long long f[maxn][maxn];long long sum[maxn];long long s[maxn];int main()&#123; #ifndef ONLINE_JUDGE freopen("test.in", "r", stdin); #endif n = read(), m = read(), k = read(); for(int i = 1; i &lt;= n; ++i)&#123; p[i] = readll(); sum[i] = sum[i - 1] + p[i]; &#125; for(int i = m; i &lt;= n; ++i)&#123; s[i] = sum[i] - sum[i - m]; &#125; for(int i = m; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= k &amp;&amp; j * m &lt;= i; ++j)&#123; f[i][j] = f[i - 1][j]; f[i][j] = max(f[i][j], f[i - m][j - 1] + s[i]); &#125; &#125; cout&lt;&lt;f[n][k]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.7题解综合1 —— 并查集与分治]]></title>
    <url>%2F2019%2F08%2F01%2F2019-7%E9%A2%98%E8%A7%A3%E7%BB%BC%E5%90%88%2F</url>
    <content type="text"><![CDATA[杂谈第一次在外面参加这么长时间的集训… 被各路大佬摧残… 7.25 并查集相关CF468b TWOSETS题目传送门 题目大意给出 $n$ 个各不相同的数字，将它们分别放入 $A$ 和 $B$ 两个集合中，使它们满足： 若数字 $x$ 在集合 $A$ 中，那么数字 $a-x$ 也在集合 $A$ 中；若数字 $x$ 在集合 $B$ 中，那么数字 $b-x$ 也在集合 $B$ 中。 大体思路分为以下几种情况 1.$a-x$与$b-x$有一个存在$a-x$与$b-x$都不存在$a-x$与$b-x$都存在 很显然，$a-(a-x)=x$,因此如果$a-x(b-x)$不在给定的集合中，则$x$就只能在$B(A)$中（注意顺序）。而如果$a-x$与$b-x$都不存在，便会无解。重点在于情况三，如果$a-x$与$b-x$都存在，那么$x$在哪个集合都可以，这时候决定$x$在哪里的并不是$x$本身，而是与$a-x$与$b-x$有关的数。综合以上情况，考虑用并查集维护。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt;using namespace std;#define gc ch = getchar()int read()&#123; int ret = 0, f = 1;char gc; while(!isdigit(ch) &amp;&amp; (ch ^ '-'))gc; if(ch == '-')f = -1,gc; while(isdigit(ch))&#123;ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'), gc;&#125; return ret * f;&#125;#undef gcconst int maxn = 100010;map&lt;int, int&gt;mp;int n, a, b;int x, y;int pos[maxn];int fa[maxn];int findx(int x)&#123;return fa[x] == x ? x : fa[x] = findx(fa[x]);&#125;void merge(int x, int y)&#123; int fi = findx(x), fj = findx(y); if(fi != fj) fa[fi] = fj;&#125;int main()&#123; n = read(), a = read(), b = read(); for(int i = 1; i &lt;= n; ++i)&#123; pos[i] = read(); mp[pos[i]] = i; fa[i] = i; &#125; x = n + 1, y = n + 2; fa[x] = x, fa[y] = y; for(int i = 1; i &lt;= n; ++i)&#123; // cout&lt;&lt;pos[i]&lt;&lt;" "&lt;&lt;a-pos[i]&lt;&lt; " "&lt;&lt;b-pos[i]&lt;&lt;endl; // cout&lt;&lt;"!!"&lt;&lt;mp[a - pos[i]]&lt;&lt; " "&lt;&lt;mp[b - pos[i]]&lt;&lt;endl; if(!mp[a - pos[i]])&#123; merge(i, y); // merge(mp[]) &#125; else &#123; merge(mp[a - pos[i]], i); &#125; if(!mp[b - pos[i]])&#123; merge(i, x); &#125; else &#123; merge(mp[b - pos[i]], i); &#125; // cout&lt;&lt;findx(i)&lt;&lt;endl; &#125; int x1 = findx(x), x2 = findx(y); if(x1 == x2)&#123;cout&lt;&lt;"NO"&lt;&lt;endl;return 0;&#125; cout&lt;&lt;"YES"&lt;&lt;endl; for(int i = 1; i &lt;= n; ++i)&#123; // cout&lt;&lt;findx(i)&lt;&lt;endl; if(findx(i) == x1)cout&lt;&lt;"0"&lt;&lt; " "; else cout&lt;&lt;"1"&lt;&lt;" "; &#125;&#125; luogu P3295 [SCOI2016]萌萌哒题目传送门 题目大意给定一个序列$S$的长度为$n$以及$m$对区间$(l_1,r_1,l_2,r_2)$知每一对区间中的每个数都相同，求最终序列的方案数。 大体思路有$m$对区间，每对区间中的每个数都相同。因为最终要求的是方案数，不用考虑单独的一种方案，考虑使用并查集维护，将每一对区间中的每一对数塞到一个并查集内部，最终答案就是$10^x＊９$($ｘ$为并查集的总数)。此时合并的复杂度最差为$O(n^2)$，但是查询的复杂度仅为$O(n)$，无法接受。然后通过细（看）致（了）思（题）考（解），发现可以使用类似ST表的倍增进行解决。设$id[j][i]$表示以$i$为左端点，长度为$2^j$的区间的编号，在合并时，直接合并代表两段区间的$(logn)$个区间即可。查询时，因为查询的是原始的$n$个节点，所以需要针对一段区间，将其合并下放。（实现方式与st表类似）。此时合并$O(logn)$，查询$O(logn)$，可以通过。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;const int maxn = 100010;const ll mod = 1e9 + 7;int n, m;int tot, l1, r1, l2, r2;int id[30][maxn], num[maxn * 30];int fa[maxn * 30], h[maxn * 30];int bin[30];int findx(int x)&#123;return fa[x] == x ? x : fa[x] = findx(fa[x]);&#125;void merge(int x, int y)&#123; int fi = findx(x), fj = findx(y); if(h[fi] &gt; h[fj])&#123; swap(fi, fj); &#125; if(h[fi] == h[fj])h[fj] ++; fa[fi] = fj;&#125;ll ksm(ll now, ll a)&#123; ll res = 1, base = now; while(a)&#123; if(a &amp; 1) res = (1ll * res * base) % mod; base = (1ll * base * base) % mod; a &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("test.in", "r", stdin); #endif scanf("%d%d", &amp;n, &amp;m); bin[0] = 1; for(int p = 1; p &lt;= 20; ++p)&#123; bin[p] = (bin[p - 1] &lt;&lt; 1) % mod; &#125; for(int j = 0; j &lt;= 20; ++j)&#123; for(int i = 1; i &lt;= n; ++i)&#123; id[j][i] = ++tot, num[tot] = i; fa[tot] = tot, h[tot] = 1; &#125; &#125; for(int i = 1; i &lt;= m; ++i)&#123; scanf("%d%d%d%d", &amp;l1, &amp;r1, &amp;l2, &amp;r2); for(int j = 20; j &gt;= 0; --j)&#123; if(l1 + bin[j] - 1 &lt;= r1)&#123; merge(id[j][l1], id[j][l2]); l1 += bin[j], l2 += bin[j]; &#125; &#125; &#125; // cout&lt;&lt;1&lt;&lt;endl; for(int j = 20; j; --j)&#123; // cout&lt;&lt;j&lt;&lt; " "; for(int i = 1; i + bin[j] - 1 &lt;= n; ++i)&#123; int x = findx(id[j][i]), a = num[x]; merge(id[j - 1][a], id[j - 1][i]); merge(id[j - 1][a + bin[j - 1]], id[j - 1][i + bin[j - 1]]); // cout&lt;&lt;"j"&lt;&lt;j&lt;&lt; " "&lt;&lt;i&lt;&lt;endl; &#125; &#125; // cout&lt;&lt;1&lt;&lt;endl; ll cnt = 0; for(int i = 1; i &lt;= n; ++i)&#123; if(findx(id[0][i]) == id[0][i])cnt++; &#125; // cout&lt;&lt;cnt&lt;&lt;endl; cout&lt;&lt;(9ll * ksm(10, cnt - 1)) % mod; return 0;&#125; 7.25 分治相关luogu P1429 平面最近点对（加强版）题目传送门 题目大意平面上有$n$个点$(2≤n≤200000)$，求距离最近的点对 主要思路考虑直接枚举$n$个点，$O(n^2)$显然不可做。。。。考虑分治，将平面沿$x$坐标的中位数裁开，这样要求的解被分成三类。 1.在左侧的解2.在右侧的解3.横跨分割线的解 解1与解2分开递归计算即可，重点考虑解3如何处理。然后发现了一种优美的性质。对于一个点来说，其要想和横跨分治边界的另一个点更新最优解，最多只有$6$个点符合要求。设左侧的递归答案为$d1$，右侧的递归答案为$d2$，则当前最优解为$\delta=min(d1,d2)$,如果要想使$dis(x,y) &lt; \delta$，很明显另一个点的取值只能是一个$[\delta,2\delta]$的矩形，又因为$\delta=min(d1,d2)$，则右侧每两个点之间的距离$dis\le\delta$，也就是说，最多只能有$6$个点被选择。先按$x$轴第一关键字，$y$轴第二关键字排序,每一层分治的复杂度为$O(6n)$，总复杂度$O(logn)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;using namespace std;const int maxn = 200010;const int inf = 2 &lt;&lt; 20;int n;struct node &#123; double x, y;&#125;a[maxn];int tmp[maxn];bool cmp1(node &amp;a, node &amp;b)&#123; return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;&#125;bool cmp2(int &amp;i, int &amp;j)&#123; return a[i].y &lt; a[j].y;&#125;double dist(int i, int j)&#123; return sqrt((a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y));&#125;double merge(int l, int r)&#123; double d = inf; if(l == r)return d; if(l + 1 == r)return dist(l, r); int mid = (l + r) &gt;&gt; 1; double d1 = merge(l, mid); double d2 = merge(mid + 1, r); d = min(d1, d2); int cnt = 0; for(int i = l; i &lt;= r; ++i)&#123; if(fabs(a[mid].x - a[i].x) &lt; d)&#123; tmp[++cnt] = i; &#125; &#125; sort(tmp + 1, tmp + cnt + 1, cmp2); double d3; for(int i = 1; i &lt;= cnt; ++i)&#123; for(int j = i + 1; j &lt;= cnt &amp;&amp; fabs(a[tmp[j]].y - a[tmp[i]].y) &lt; d; j++)&#123; d3 = dist(tmp[i], tmp[j]); if(d &gt; d3)d = d3; &#125; &#125; return d;&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i)scanf("%lf%lf", &amp;a[i].x, &amp;a[i].y); sort(a + 1, a + n + 1, cmp1); printf("%.4lf", merge(1, n)); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新式骗分——模拟退火]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%96%B0%E5%BC%8F%E9%AA%97%E5%88%86%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%2F</url>
    <content type="text"><![CDATA[博客咕咕咕的时间有点长(似乎是太长了) 今天写一下模拟退火吧。。。发现了骗分的新大陆 一：背景模拟退火解决的是一种什么样的问题呢？ 模拟退火算法（Simulate Anneal，SA）是一种通用概率演算法， 用来在一个大的搜寻空间内找寻命题的最优解。 模拟退火是由S.Kirkpatrick, C.D.Gelatt和&gt;M.P.Vecchi在1983年所发明的。V.Čern&yacute;在1985年也独立发明此演算法。模&gt;拟退火算法是解决TSP问题的有效方法之一。—— 来自百度百科 照例引用百度百科。 其实模拟退火就是一种解决问题的普遍方法。 二：爬山算法及其优化 针对一个求最值的问题，我们可以采用一种贪心的方法，被称作“爬山算法”。爬山算法指的就是每一步都将当前节点的值与其邻居节点比较，如果有更优值就取，否则就维持当前的解。很明显，这个算法可以找到一个局部最优解。但是其有一个致命的缺陷，那就是只能找到局部最优解，但是并不能保证找到的解是一个全局最优解。 就比如说上面这个图，当我们在D点出发，使用爬山算法，即可到达B点，很明显这既是局部最优解，又是全局最优解。但是如果从C点或E点出发，我们最后会到达A点，（然后愉快的WA） 这种做法很明显是不行的，那么怎么使其变的正确 或者说大约正确呢？ 上文提到的三位大佬想出来了一个绝妙的解决方案： 使用随机算法，使得每一次搜索到比当前解差的解时，都有一定概率接受这个解。但是光随机也是不行的，所以随着循环次数的增加，会不断降低接受更劣解的概率。这就是模拟退火的主要思想。 三：具体实现 先定义一下变量及数组 t: 温度 决定了接受更劣解的概率 与down一起决定了退火的时长 更高的初始温度意味着更精确的答案， 但也意味着需要更多的时间down: 每一次循环降低t的系数，一般是 0.9 ~ 1 的一个实数delta: 当前解与最优解的差now_w: 目前得到的最优解ew：当前解 步骤：1.透过最优解计算出当前解。2.如果获得了更优解 直接接受3.更劣解有概率接受 12345678910111213141516171819 void sa()&#123; double t = 3000; while(t &gt; 1e-15)&#123; double ex = ans_x + (rand() * 2 - RAND_MAX) * t; double ey = ans_y + (rand() * 2 - RAND_MAX) * t; double ew = get_eng(ex, ey);//构造解的函数 double delta = ew - ans_w; if(delta &lt; 0)&#123; ans_x = ex; ans_y = ey; ans_w = ew; &#125; else if(exp(-delta / t) * RAND_MAX &gt; rand())&#123; ans_x = ex; ans_y = ey; &#125; t *= down; &#125;&#125; 来自luoguP1337 [JSOI2004]平衡点 / 吊打XXX 值得注意的几个点： (rand() 2 - RAND_MAX) t : 求新解的方法exp(-delta / t) * RAND_MAX &gt; rand() : 来自前人的玄学判断 模拟退火流程图]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可爱的数据结构——线段树]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%8F%AF%E7%88%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[可爱的数据结构——线段树前言什么是数据结构呢？ 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关 —-来自百度百科简单来说，数据结构就是通过合理的方式在计算机中存储数据，来达到修改、查询的目的。 几个例子（纯个人看法） 朴素的数据结构 数组（-_-） 链表 队列 栈 看起来高端一些的数据结构 矩阵 哈希表（hash） 堆 树状数组 更高级的数据结构 线段树 各种平衡树 主席树 什么是线段树呢？ 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 —-依然来自百度百科 换句话说，就是把一个区间变成一个多层的树形结构，以一种二分与递归的思想实现高效的区间操作 一个例子写一个数据结构，要求支持在O(logn)的时间复杂度内支持区间加与区间和。]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流初识———EK]]></title>
    <url>%2F2018%2F12%2F16%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E5%88%9D%E8%AF%86%E2%80%94%E2%80%94EK%2F</url>
    <content type="text"><![CDATA[前言当初刚开始学OI的时候，对各种奇怪的中高级算法抱有极大的兴趣（结果自然是看不懂-_-），网络流则是排在前列的几大算法之一（话说我是如何在连建图和SPFA都搞不明白的情况下看进去的…）。 如今过了一年（技术还是没有什么长进，该不会的还是不会），重新看了一篇网络流与费用流，似乎。。。有那么一点理解了，谨以此文，来表达我对网络流的一点看法。 什么是网络流？“网络流(network-flows)是一种类比水流的解决问题方法，与线性规划密切相关。”（来自百度百科） 举个例子，从某地要向某地输水，中间有许多粗细不同的管子，网络流算法解决的就是利用这些管子怎样使单位时间总输送量最大化的问题。 如何解决网络流问题？前置知识会建图，会dfs、bfs（似乎只需要这些。。。） 在开始之前…我们先来明晰几个概念： 点的属性： 源点(s): 一切的开始，入度为0 汇点(t): 一切的结束，出度为0 边的属性： 首先很明显图应该是DAG 流量(flow)：每条边能通过的最大值 如何建图？先不负责任的提出解决方案：对于每一条有向边，建一条与之方向相反（出入点相反），流量为0的边。 为什么？ 我们先来明确一下网络流的工作原理： 每一次搜索结束后，便会找到一条从源点到汇点的路径（这条路径叫增广路），且该路径上的边的流量均大于0，通过这条路可以增加的流量便是这条路径中的最小流量（自行理解一下）。然后在每次搜索结束时，将这条路径上的边的流量减去可以增加的流量。重复此过程直到找不出路径为止。 这种看起来就像是贪心的算法很明显是错的… 你搜索到的流量会与你搜索的路径的顺序有关，这怎么行！ 所以在建图时，要采用上文所述的方式，建一条反向边，并且在搜索完毕后减去增加流量的同时，在反向边加上增加的流量，这样在下一次搜索增广路时可以沿着反向边把流量回退，从而实现发现真正意义上的最大流的目的。 上代码！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 51000;const int inf = 1e9 + 7;int n;int p, m, f, u, v;int s, t;int num[maxn];struct edge&#123; int nt, to, flow, val; inline void set(int n, int t, int f)&#123; nt = n, to = t, flow = f; &#125;&#125;e[maxn &lt;&lt; 2];int h[maxn], c[maxn], tot = -1;void adde(int a, int b, int c)&#123;e[++tot].set(h[a], b, c), h[a] = tot; e[++tot].set(h[b], a, 0), h[b] = tot;&#125;queue &lt;int&gt; q;int dis[maxn], vis[maxn], pre[maxn], last[maxn], flow[maxn]; //存路径和更新的流量bool bfs(int s, int t)&#123; for(int i = 0; i &lt;= n; ++i)pre[i] = -1, vis[i] = 0; memset(last, -1, sizeof(last)); while(!q.empty())q.pop(); q.push(s); pre[s] = inf; flow[s] = inf; vis[s] = 1; while(!q.empty())&#123; int now = q.front(); q.pop(); for(int i = h[now]; i != -1; i = e[i].nt)&#123; int nex = e[i].to; if(e[i].flow &gt; 0 &amp;&amp; vis[nex] == 0)&#123; pre[nex] = now; last[nex] = i; if(e[i].flow &lt; flow[now]) flow[nex] = e[i].flow; else flow[nex] = flow[now]; if(!vis[nex])&#123; vis[nex] = 1; q.push(nex); &#125; &#125; &#125; &#125; return pre[t] != -1;&#125;int maxflow = 0;void ek(int s, int t)&#123; while(bfs(s, t))&#123; maxflow += flow[t]; for(int i = t; i != s; i = pre[i])&#123; e[last[i]].flow -= flow[t]; e[last[i] ^ 1].flow += flow[t]; &#125; &#125;&#125;int main()&#123; int s, t; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t); for(int i = 0; i &lt;= n; ++i) h[i] = -1; int u, v, f; for(int i = 1; i &lt;= m; ++i)&#123; scanf("%d%d%d", &amp;u,&amp;v,&amp;f); adde(u, v, f); &#125; ek(s, t); cout&lt;&lt;maxflow&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
</search>
