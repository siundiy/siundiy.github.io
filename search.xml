<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[新式骗分——模拟退火]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%96%B0%E5%BC%8F%E9%AA%97%E5%88%86%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%2F</url>
    <content type="text"><![CDATA[博客咕咕咕的时间有点长(似乎是太长了) 今天写一下模拟退火吧。。。发现了骗分的新大陆 一：背景模拟退火解决的是一种什么样的问题呢？ 模拟退火算法（Simulate Anneal，SA）是一种通用概率演算法， 用来在一个大的搜寻空间内找寻命题的最优解。 模拟退火是由S.Kirkpatrick, C.D.Gelatt和&gt;M.P.Vecchi在1983年所发明的。V.Čern&yacute;在1985年也独立发明此演算法。模&gt;拟退火算法是解决TSP问题的有效方法之一。—— 来自百度百科 照例引用百度百科。 其实模拟退火就是一种解决问题的普遍方法。 二：爬山算法及其优化 针对一个求最值的问题，我们可以采用一种贪心的方法，被称作“爬山算法”。爬山算法指的就是每一步都将当前节点的值与其邻居节点比较，如果有更优值就取，否则就维持当前的解。很明显，这个算法可以找到一个局部最优解。但是其有一个致命的缺陷，那就是只能找到局部最优解，但是并不能保证找到的解是一个全局最优解。 就比如说上面这个图，当我们在D点出发，使用爬山算法，即可到达B点，很明显这既是局部最优解，又是全局最优解。但是如果从C点或E点出发，我们最后会到达A点，（然后愉快的WA） 这种做法很明显是不行的，那么怎么使其变的正确 或者说大约正确呢？ 上文提到的三位大佬想出来了一个绝妙的解决方案： 使用随机算法，使得每一次搜索到比当前解差的解时，都有一定概率接受这个解。但是光随机也是不行的，所以随着循环次数的增加，会不断降低接受更劣解的概率。这就是模拟退火的主要思想。 三：具体实现 先定义一下变量及数组 t: 温度 决定了接受更劣解的概率 与down一起决定了退火的时长 更高的初始温度意味着更精确的答案， 但也意味着需要更多的时间down: 每一次循环降低t的系数，一般是 0.9 ~ 1 的一个实数delta: 当前解与最优解的差now_w: 目前得到的最优解ew：当前解 步骤：1.透过最优解计算出当前解。2.如果获得了更优解 直接接受3.更劣解有概率接受 12345678910111213141516171819 void sa()&#123; double t = 3000; while(t &gt; 1e-15)&#123; double ex = ans_x + (rand() * 2 - RAND_MAX) * t; double ey = ans_y + (rand() * 2 - RAND_MAX) * t; double ew = get_eng(ex, ey);//构造解的函数 double delta = ew - ans_w; if(delta &lt; 0)&#123; ans_x = ex; ans_y = ey; ans_w = ew; &#125; else if(exp(-delta / t) * RAND_MAX &gt; rand())&#123; ans_x = ex; ans_y = ey; &#125; t *= down; &#125;&#125; 来自luoguP1337 [JSOI2004]平衡点 / 吊打XXX 值得注意的几个点： (rand() 2 - RAND_MAX) t : 求新解的方法exp(-delta / t) * RAND_MAX &gt; rand() : 来自前人的玄学判断 模拟退火流程图]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可爱的数据结构——线段树]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%8F%AF%E7%88%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[可爱的数据结构——线段树前言什么是数据结构呢？ 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关 —来自百度百科 简单来说，数据结构就是通过合理的方式在计算机中存储数据，来达到修改、查询的目的。 几个例子（纯个人看法） 朴素的数据结构 数组（-_-） 链表 队列 栈 看起来高端一些的数据结构 矩阵 哈希表（hash） 堆 树状数组 更高级的数据结构 线段树 各种平衡树 主席树 什么是线段树呢？ 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 —依然来自百度百科 换句话说，就是把一个区间变成一个多层的树形结构，以一种二分与递归的思想实现高效的区间操作 一个例子写一个数据结构，要求支持在O(logn)的时间复杂度内支持区间加与区间和。]]></content>
      <tags>
        <tag>数据结构 线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流初识———EK]]></title>
    <url>%2F2018%2F12%2F16%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E5%88%9D%E8%AF%86%E2%80%94%E2%80%94EK%2F</url>
    <content type="text"><![CDATA[前言当初刚开始学OI的时候，对各种奇怪的中高级算法抱有极大的兴趣（结果自然是看不懂-_-），网络流则是排在前列的几大算法之一（话说我是如何在连建图和SPFA都搞不明白的情况下看进去的…）。 如今过了一年（技术还是没有什么长进，该不会的还是不会），重新看了一篇网络流与费用流，似乎。。。有那么一点理解了，谨以此文，来表达我对网络流的一点看法。 什么是网络流？“网络流(network-flows)是一种类比水流的解决问题方法，与线性规划密切相关。”（来自百度百科） 举个例子，从某地要向某地输水，中间有许多粗细不同的管子，网络流算法解决的就是利用这些管子怎样使单位时间总输送量最大化的问题。 如何解决网络流问题？前置知识会建图，会dfs、bfs（似乎只需要这些。。。） 在开始之前…我们先来明晰几个概念： 点的属性： 源点(s): 一切的开始，入度为0 汇点(t): 一切的结束，出度为0 边的属性： 首先很明显图应该是DAG 流量(flow)：每条边能通过的最大值 如何建图？先不负责任的提出解决方案：对于每一条有向边，建一条与之方向相反（出入点相反），流量为0的边。 为什么？ 我们先来明确一下网络流的工作原理： 每一次搜索结束后，便会找到一条从源点到汇点的路径（这条路径叫增广路），且该路径上的边的流量均大于0，通过这条路可以增加的流量便是这条路径中的最小流量（自行理解一下）。然后在每次搜索结束时，将这条路径上的边的流量减去可以增加的流量。重复此过程直到找不出路径为止。 这种看起来就像是贪心的算法很明显是错的… 你搜索到的流量会与你搜索的路径的顺序有关，这怎么行！ 所以在建图时，要采用上文所述的方式，建一条反向边，并且在搜索完毕后减去增加流量的同时，在反向边加上增加的流量，这样在下一次搜索增广路时可以沿着反向边把流量回退，从而实现发现真正意义上的最大流的目的。 上代码！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 51000;const int inf = 1e9 + 7;int n;int p, m, f, u, v;int s, t;int num[maxn];struct edge&#123; int nt, to, flow, val; inline void set(int n, int t, int f)&#123; nt = n, to = t, flow = f; &#125;&#125;e[maxn &lt;&lt; 2];int h[maxn], c[maxn], tot = -1;void adde(int a, int b, int c)&#123;e[++tot].set(h[a], b, c), h[a] = tot; e[++tot].set(h[b], a, 0), h[b] = tot;&#125;queue &lt;int&gt; q;int dis[maxn], vis[maxn], pre[maxn], last[maxn], flow[maxn]; //存路径和更新的流量bool bfs(int s, int t)&#123; for(int i = 0; i &lt;= n; ++i)pre[i] = -1, vis[i] = 0; memset(last, -1, sizeof(last)); while(!q.empty())q.pop(); q.push(s); pre[s] = inf; flow[s] = inf; vis[s] = 1; while(!q.empty())&#123; int now = q.front(); q.pop(); for(int i = h[now]; i != -1; i = e[i].nt)&#123; int nex = e[i].to; if(e[i].flow &gt; 0 &amp;&amp; vis[nex] == 0)&#123; pre[nex] = now; last[nex] = i; if(e[i].flow &lt; flow[now]) flow[nex] = e[i].flow; else flow[nex] = flow[now]; if(!vis[nex])&#123; vis[nex] = 1; q.push(nex); &#125; &#125; &#125; &#125; return pre[t] != -1;&#125;int maxflow = 0;void ek(int s, int t)&#123; while(bfs(s, t))&#123; maxflow += flow[t]; for(int i = t; i != s; i = pre[i])&#123; e[last[i]].flow -= flow[t]; e[last[i] ^ 1].flow += flow[t]; &#125; &#125;&#125;int main()&#123; int s, t; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t); for(int i = 0; i &lt;= n; ++i) h[i] = -1; int u, v, f; for(int i = 1; i &lt;= m; ++i)&#123; scanf("%d%d%d", &amp;u,&amp;v,&amp;f); adde(u, v, f); &#125; ek(s, t); cout&lt;&lt;maxflow&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
</search>
