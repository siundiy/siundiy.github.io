<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019-7题解综合2——DP]]></title>
    <url>%2F2019%2F08%2F04%2F2019-7-29%E9%A2%98%E8%A7%A3%E7%BB%BC%E5%90%88%2F</url>
    <content type="text"><![CDATA[7.29 “简单”DPluogu P2467 [SDOI2010]地精部落题目传送门 题目大意一个序列符合要求，当且仅当其是一个$1~n$的排列，且每一个$a[i]$ 满足$a[i-1]\le a[i]$且$a[i]\ge a[i+1]$ 或者满足$a[i-1]\ge a[i]$且$a[i]\le a[i+1]$ 求长度为$n$的合法序列方案数 大体思路神仙题。。。。显然有以下性质： 1.当$i$与$i+1$不相邻时，交换$i$与$i+1$仍会得到一个合法的解如:$3 2 4 1 5 \rightarrow 3 1 4 2 5$ 2.一串序列$a[i]$，$i\in [1,n]$满足条件时，则$(i+1)-a[i]$亦满足条件如:$3 2 4 1 5 \rightarrow 3 4 2 5 1$ 3.满足条件的序列具有对称性 如:$3 2 4 1 5 \rightarrow 5 1 4 2 3$ 则设$dp[i][j]$表示当前为前$i$个数的排列，且首位是$j$且为山峰的方案数。 \! \begin{split} & 由性质1可知: \!\begin{cases} \text{当$j$与$j-1$不相邻时，$dp[i][j]=dp[i][j-1]$}\\ \end{cases}\\ & 由性质2可知: \!\begin{cases} \text{首位做山峰的方案数=首位做山谷的方案数}\\ \downarrow \\ \text{(也就是说最后的答案是$2*\sum_{i=1}^n dp[n][i]$)}\\ \\ \text{当$j$与$j-1$相邻时，方案数即为$i-1$个数，$j-1$为首位且为山谷的方案数}\\ \end{cases} \end{split}]]></content>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.7题解综合1 —— 并查集与分治]]></title>
    <url>%2F2019%2F08%2F01%2F2019-7%E9%A2%98%E8%A7%A3%E7%BB%BC%E5%90%88%2F</url>
    <content type="text"><![CDATA[杂谈第一次在外面参加这么长时间的集训… 被各路大佬摧残… 7.25 并查集相关CF468b TWOSETS题目传送门 题目大意给出 $n$ 个各不相同的数字，将它们分别放入 $A$ 和 $B$ 两个集合中，使它们满足： 若数字 $x$ 在集合 $A$ 中，那么数字 $a-x$ 也在集合 $A$ 中；若数字 $x$ 在集合 $B$ 中，那么数字 $b-x$ 也在集合 $B$ 中。 大体思路分为以下几种情况 1.$a-x$与$b-x$有一个存在$a-x$与$b-x$都不存在$a-x$与$b-x$都存在 很显然，$a-(a-x)=x$,因此如果$a-x(b-x)$不在给定的集合中，则$x$就只能在$B(A)$中（注意顺序）。而如果$a-x$与$b-x$都不存在，便会无解。重点在于情况三，如果$a-x$与$b-x$都存在，那么$x$在哪个集合都可以，这时候决定$x$在哪里的并不是$x$本身，而是与$a-x$与$b-x$有关的数。综合以上情况，考虑用并查集维护。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt;using namespace std;#define gc ch = getchar()int read()&#123; int ret = 0, f = 1;char gc; while(!isdigit(ch) &amp;&amp; (ch ^ '-'))gc; if(ch == '-')f = -1,gc; while(isdigit(ch))&#123;ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'), gc;&#125; return ret * f;&#125;#undef gcconst int maxn = 100010;map&lt;int, int&gt;mp;int n, a, b;int x, y;int pos[maxn];int fa[maxn];int findx(int x)&#123;return fa[x] == x ? x : fa[x] = findx(fa[x]);&#125;void merge(int x, int y)&#123; int fi = findx(x), fj = findx(y); if(fi != fj) fa[fi] = fj;&#125;int main()&#123; n = read(), a = read(), b = read(); for(int i = 1; i &lt;= n; ++i)&#123; pos[i] = read(); mp[pos[i]] = i; fa[i] = i; &#125; x = n + 1, y = n + 2; fa[x] = x, fa[y] = y; for(int i = 1; i &lt;= n; ++i)&#123; // cout&lt;&lt;pos[i]&lt;&lt;" "&lt;&lt;a-pos[i]&lt;&lt; " "&lt;&lt;b-pos[i]&lt;&lt;endl; // cout&lt;&lt;"!!"&lt;&lt;mp[a - pos[i]]&lt;&lt; " "&lt;&lt;mp[b - pos[i]]&lt;&lt;endl; if(!mp[a - pos[i]])&#123; merge(i, y); // merge(mp[]) &#125; else &#123; merge(mp[a - pos[i]], i); &#125; if(!mp[b - pos[i]])&#123; merge(i, x); &#125; else &#123; merge(mp[b - pos[i]], i); &#125; // cout&lt;&lt;findx(i)&lt;&lt;endl; &#125; int x1 = findx(x), x2 = findx(y); if(x1 == x2)&#123;cout&lt;&lt;"NO"&lt;&lt;endl;return 0;&#125; cout&lt;&lt;"YES"&lt;&lt;endl; for(int i = 1; i &lt;= n; ++i)&#123; // cout&lt;&lt;findx(i)&lt;&lt;endl; if(findx(i) == x1)cout&lt;&lt;"0"&lt;&lt; " "; else cout&lt;&lt;"1"&lt;&lt;" "; &#125;&#125; luogu P3295 [SCOI2016]萌萌哒题目传送门 题目大意给定一个序列$S$的长度为$n$以及$m$对区间$(l_1,r_1,l_2,r_2)$知每一对区间中的每个数都相同，求最终序列的方案数。 大体思路有$m$对区间，每对区间中的每个数都相同。因为最终要求的是方案数，不用考虑单独的一种方案，考虑使用并查集维护，将每一对区间中的每一对数塞到一个并查集内部，最终答案就是$10^x＊９$($ｘ$为并查集的总数)。此时合并的复杂度最差为$O(n^2)$，但是查询的复杂度仅为$O(n)$，无法接受。然后通过细（看）致（了）思（题）考（解），发现可以使用类似ST表的倍增进行解决。设$id[j][i]$表示以$i$为左端点，长度为$2^j$的区间的编号，在合并时，直接合并代表两段区间的$(logn)$个区间即可。查询时，因为查询的是原始的$n$个节点，所以需要针对一段区间，将其合并下放。（实现方式与st表类似）。此时合并$O(logn)$，查询$O(logn)$，可以通过。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;const int maxn = 100010;const ll mod = 1e9 + 7;int n, m;int tot, l1, r1, l2, r2;int id[30][maxn], num[maxn * 30];int fa[maxn * 30], h[maxn * 30];int bin[30];int findx(int x)&#123;return fa[x] == x ? x : fa[x] = findx(fa[x]);&#125;void merge(int x, int y)&#123; int fi = findx(x), fj = findx(y); if(h[fi] &gt; h[fj])&#123; swap(fi, fj); &#125; if(h[fi] == h[fj])h[fj] ++; fa[fi] = fj;&#125;ll ksm(ll now, ll a)&#123; ll res = 1, base = now; while(a)&#123; if(a &amp; 1) res = (1ll * res * base) % mod; base = (1ll * base * base) % mod; a &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("test.in", "r", stdin); #endif scanf("%d%d", &amp;n, &amp;m); bin[0] = 1; for(int p = 1; p &lt;= 20; ++p)&#123; bin[p] = (bin[p - 1] &lt;&lt; 1) % mod; &#125; for(int j = 0; j &lt;= 20; ++j)&#123; for(int i = 1; i &lt;= n; ++i)&#123; id[j][i] = ++tot, num[tot] = i; fa[tot] = tot, h[tot] = 1; &#125; &#125; for(int i = 1; i &lt;= m; ++i)&#123; scanf("%d%d%d%d", &amp;l1, &amp;r1, &amp;l2, &amp;r2); for(int j = 20; j &gt;= 0; --j)&#123; if(l1 + bin[j] - 1 &lt;= r1)&#123; merge(id[j][l1], id[j][l2]); l1 += bin[j], l2 += bin[j]; &#125; &#125; &#125; // cout&lt;&lt;1&lt;&lt;endl; for(int j = 20; j; --j)&#123; // cout&lt;&lt;j&lt;&lt; " "; for(int i = 1; i + bin[j] - 1 &lt;= n; ++i)&#123; int x = findx(id[j][i]), a = num[x]; merge(id[j - 1][a], id[j - 1][i]); merge(id[j - 1][a + bin[j - 1]], id[j - 1][i + bin[j - 1]]); // cout&lt;&lt;"j"&lt;&lt;j&lt;&lt; " "&lt;&lt;i&lt;&lt;endl; &#125; &#125; // cout&lt;&lt;1&lt;&lt;endl; ll cnt = 0; for(int i = 1; i &lt;= n; ++i)&#123; if(findx(id[0][i]) == id[0][i])cnt++; &#125; // cout&lt;&lt;cnt&lt;&lt;endl; cout&lt;&lt;(9ll * ksm(10, cnt - 1)) % mod; return 0;&#125; 7.25 分治相关luogu P1429 平面最近点对（加强版）题目传送门 题目大意平面上有$n$个点$(2≤n≤200000)$，求距离最近的点对 主要思路考虑直接枚举$n$个点，$O(n^2)$显然不可做。。。。考虑分治，将平面沿$x$坐标的中位数裁开，这样要求的解被分成三类。 1.在左侧的解2.在右侧的解3.横跨分割线的解 解1与解2分开递归计算即可，重点考虑解3如何处理。然后发现了一种优美的性质。对于一个点来说，其要想和横跨分治边界的另一个点更新最优解，最多只有$6$个点符合要求。设左侧的递归答案为$d1$，右侧的递归答案为$d2$，则当前最优解为$\delta=min(d1,d2)$,如果要想使$dis(x,y) &lt; \delta$，很明显另一个点的取值只能是一个$[\delta,2\delta]$的矩形，又因为$\delta=min(d1,d2)$，则右侧每两个点之间的距离$dis\le\delta$，也就是说，最多只能有$6$个点被选择。先按$x$轴第一关键字，$y$轴第二关键字排序,每一层分治的复杂度为$O(6n)$，总复杂度$O(logn)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;using namespace std;const int maxn = 200010;const int inf = 2 &lt;&lt; 20;int n;struct node &#123; double x, y;&#125;a[maxn];int tmp[maxn];bool cmp1(node &amp;a, node &amp;b)&#123; return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;&#125;bool cmp2(int &amp;i, int &amp;j)&#123; return a[i].y &lt; a[j].y;&#125;double dist(int i, int j)&#123; return sqrt((a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y));&#125;double merge(int l, int r)&#123; double d = inf; if(l == r)return d; if(l + 1 == r)return dist(l, r); int mid = (l + r) &gt;&gt; 1; double d1 = merge(l, mid); double d2 = merge(mid + 1, r); d = min(d1, d2); int cnt = 0; for(int i = l; i &lt;= r; ++i)&#123; if(fabs(a[mid].x - a[i].x) &lt; d)&#123; tmp[++cnt] = i; &#125; &#125; sort(tmp + 1, tmp + cnt + 1, cmp2); double d3; for(int i = 1; i &lt;= cnt; ++i)&#123; for(int j = i + 1; j &lt;= cnt &amp;&amp; fabs(a[tmp[j]].y - a[tmp[i]].y) &lt; d; j++)&#123; d3 = dist(tmp[i], tmp[j]); if(d &gt; d3)d = d3; &#125; &#125; return d;&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i)scanf("%lf%lf", &amp;a[i].x, &amp;a[i].y); sort(a + 1, a + n + 1, cmp1); printf("%.4lf", merge(1, n)); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新式骗分——模拟退火]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%96%B0%E5%BC%8F%E9%AA%97%E5%88%86%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%2F</url>
    <content type="text"><![CDATA[博客咕咕咕的时间有点长(似乎是太长了) 今天写一下模拟退火吧。。。发现了骗分的新大陆 一：背景模拟退火解决的是一种什么样的问题呢？ 模拟退火算法（Simulate Anneal，SA）是一种通用概率演算法， 用来在一个大的搜寻空间内找寻命题的最优解。 模拟退火是由S.Kirkpatrick, C.D.Gelatt和&gt;M.P.Vecchi在1983年所发明的。V.Čern&yacute;在1985年也独立发明此演算法。模&gt;拟退火算法是解决TSP问题的有效方法之一。—— 来自百度百科 照例引用百度百科。 其实模拟退火就是一种解决问题的普遍方法。 二：爬山算法及其优化 针对一个求最值的问题，我们可以采用一种贪心的方法，被称作“爬山算法”。爬山算法指的就是每一步都将当前节点的值与其邻居节点比较，如果有更优值就取，否则就维持当前的解。很明显，这个算法可以找到一个局部最优解。但是其有一个致命的缺陷，那就是只能找到局部最优解，但是并不能保证找到的解是一个全局最优解。 就比如说上面这个图，当我们在D点出发，使用爬山算法，即可到达B点，很明显这既是局部最优解，又是全局最优解。但是如果从C点或E点出发，我们最后会到达A点，（然后愉快的WA） 这种做法很明显是不行的，那么怎么使其变的正确 或者说大约正确呢？ 上文提到的三位大佬想出来了一个绝妙的解决方案： 使用随机算法，使得每一次搜索到比当前解差的解时，都有一定概率接受这个解。但是光随机也是不行的，所以随着循环次数的增加，会不断降低接受更劣解的概率。这就是模拟退火的主要思想。 三：具体实现 先定义一下变量及数组 t: 温度 决定了接受更劣解的概率 与down一起决定了退火的时长 更高的初始温度意味着更精确的答案， 但也意味着需要更多的时间down: 每一次循环降低t的系数，一般是 0.9 ~ 1 的一个实数delta: 当前解与最优解的差now_w: 目前得到的最优解ew：当前解 步骤：1.透过最优解计算出当前解。2.如果获得了更优解 直接接受3.更劣解有概率接受 12345678910111213141516171819 void sa()&#123; double t = 3000; while(t &gt; 1e-15)&#123; double ex = ans_x + (rand() * 2 - RAND_MAX) * t; double ey = ans_y + (rand() * 2 - RAND_MAX) * t; double ew = get_eng(ex, ey);//构造解的函数 double delta = ew - ans_w; if(delta &lt; 0)&#123; ans_x = ex; ans_y = ey; ans_w = ew; &#125; else if(exp(-delta / t) * RAND_MAX &gt; rand())&#123; ans_x = ex; ans_y = ey; &#125; t *= down; &#125;&#125; 来自luoguP1337 [JSOI2004]平衡点 / 吊打XXX 值得注意的几个点： (rand() 2 - RAND_MAX) t : 求新解的方法exp(-delta / t) * RAND_MAX &gt; rand() : 来自前人的玄学判断 模拟退火流程图]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可爱的数据结构——线段树]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%8F%AF%E7%88%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[可爱的数据结构——线段树前言什么是数据结构呢？ 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关 —-来自百度百科 简单来说，数据结构就是通过合理的方式在计算机中存储数据，来达到修改、查询的目的。 几个例子（纯个人看法） 朴素的数据结构 数组（-_-） 链表 队列 栈 看起来高端一些的数据结构 矩阵 哈希表（hash） 堆 树状数组 更高级的数据结构 线段树 各种平衡树 主席树 什么是线段树呢？ 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 —-依然来自百度百科 换句话说，就是把一个区间变成一个多层的树形结构，以一种二分与递归的思想实现高效的区间操作 一个例子写一个数据结构，要求支持在O(logn)的时间复杂度内支持区间加与区间和。]]></content>
      <tags>
        <tag>数据结构 线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流初识———EK]]></title>
    <url>%2F2018%2F12%2F16%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E5%88%9D%E8%AF%86%E2%80%94%E2%80%94EK%2F</url>
    <content type="text"><![CDATA[前言当初刚开始学OI的时候，对各种奇怪的中高级算法抱有极大的兴趣（结果自然是看不懂-_-），网络流则是排在前列的几大算法之一（话说我是如何在连建图和SPFA都搞不明白的情况下看进去的…）。 如今过了一年（技术还是没有什么长进，该不会的还是不会），重新看了一篇网络流与费用流，似乎。。。有那么一点理解了，谨以此文，来表达我对网络流的一点看法。 什么是网络流？“网络流(network-flows)是一种类比水流的解决问题方法，与线性规划密切相关。”（来自百度百科） 举个例子，从某地要向某地输水，中间有许多粗细不同的管子，网络流算法解决的就是利用这些管子怎样使单位时间总输送量最大化的问题。 如何解决网络流问题？前置知识会建图，会dfs、bfs（似乎只需要这些。。。） 在开始之前…我们先来明晰几个概念： 点的属性： 源点(s): 一切的开始，入度为0 汇点(t): 一切的结束，出度为0 边的属性： 首先很明显图应该是DAG 流量(flow)：每条边能通过的最大值 如何建图？先不负责任的提出解决方案：对于每一条有向边，建一条与之方向相反（出入点相反），流量为0的边。 为什么？ 我们先来明确一下网络流的工作原理： 每一次搜索结束后，便会找到一条从源点到汇点的路径（这条路径叫增广路），且该路径上的边的流量均大于0，通过这条路可以增加的流量便是这条路径中的最小流量（自行理解一下）。然后在每次搜索结束时，将这条路径上的边的流量减去可以增加的流量。重复此过程直到找不出路径为止。 这种看起来就像是贪心的算法很明显是错的… 你搜索到的流量会与你搜索的路径的顺序有关，这怎么行！ 所以在建图时，要采用上文所述的方式，建一条反向边，并且在搜索完毕后减去增加流量的同时，在反向边加上增加的流量，这样在下一次搜索增广路时可以沿着反向边把流量回退，从而实现发现真正意义上的最大流的目的。 上代码！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 51000;const int inf = 1e9 + 7;int n;int p, m, f, u, v;int s, t;int num[maxn];struct edge&#123; int nt, to, flow, val; inline void set(int n, int t, int f)&#123; nt = n, to = t, flow = f; &#125;&#125;e[maxn &lt;&lt; 2];int h[maxn], c[maxn], tot = -1;void adde(int a, int b, int c)&#123;e[++tot].set(h[a], b, c), h[a] = tot; e[++tot].set(h[b], a, 0), h[b] = tot;&#125;queue &lt;int&gt; q;int dis[maxn], vis[maxn], pre[maxn], last[maxn], flow[maxn]; //存路径和更新的流量bool bfs(int s, int t)&#123; for(int i = 0; i &lt;= n; ++i)pre[i] = -1, vis[i] = 0; memset(last, -1, sizeof(last)); while(!q.empty())q.pop(); q.push(s); pre[s] = inf; flow[s] = inf; vis[s] = 1; while(!q.empty())&#123; int now = q.front(); q.pop(); for(int i = h[now]; i != -1; i = e[i].nt)&#123; int nex = e[i].to; if(e[i].flow &gt; 0 &amp;&amp; vis[nex] == 0)&#123; pre[nex] = now; last[nex] = i; if(e[i].flow &lt; flow[now]) flow[nex] = e[i].flow; else flow[nex] = flow[now]; if(!vis[nex])&#123; vis[nex] = 1; q.push(nex); &#125; &#125; &#125; &#125; return pre[t] != -1;&#125;int maxflow = 0;void ek(int s, int t)&#123; while(bfs(s, t))&#123; maxflow += flow[t]; for(int i = t; i != s; i = pre[i])&#123; e[last[i]].flow -= flow[t]; e[last[i] ^ 1].flow += flow[t]; &#125; &#125;&#125;int main()&#123; int s, t; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t); for(int i = 0; i &lt;= n; ++i) h[i] = -1; int u, v, f; for(int i = 1; i &lt;= m; ++i)&#123; scanf("%d%d%d", &amp;u,&amp;v,&amp;f); adde(u, v, f); &#125; ek(s, t); cout&lt;&lt;maxflow&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
</search>
