{"meta":{"title":"巨大的滑稽","subtitle":"哇哦","description":"一个博客","author":"siundiy","url":"http://siundiy.com","root":"/"},"pages":[{"title":"我的朋友们","date":"2019-08-06T12:31:35.944Z","updated":"2019-08-06T12:31:35.944Z","comments":true,"path":"friends/index.html","permalink":"http://siundiy.com/friends/index.html","excerpt":"","text":""},{"title":"我的项目","date":"2019-08-06T10:56:38.892Z","updated":"2019-08-06T10:56:38.892Z","comments":true,"path":"projects/index.html","permalink":"http://siundiy.com/projects/index.html","excerpt":"","text":""},{"title":"全部标签","date":"2019-08-06T12:40:51.565Z","updated":"2019-08-06T11:41:50.564Z","comments":true,"path":"blog/tags/index.html","permalink":"http://siundiy.com/blog/tags/index.html","excerpt":"","text":"DP数据结构算法线段树网络流题解杂项"},{"title":"全部文章","date":"2019-08-06T10:34:00.707Z","updated":"2019-08-06T10:34:00.707Z","comments":true,"path":"blog/archives/index.html","permalink":"http://siundiy.com/blog/archives/index.html","excerpt":"","text":"2019-7题解综合2——DP2019.7题解综合1 —— 并查集与分治新式骗分——模拟退火可爱的数据结构——线段树网络流初识——EK"},{"title":"关于我","date":"2019-08-06T11:24:47.358Z","updated":"2019-08-06T11:24:47.358Z","comments":true,"path":"about/index.html","permalink":"http://siundiy.com/about/index.html","excerpt":"","text":"这里是一只信竟蒟蒻，喜爱游戏，编程以及咕咕咕。"}],"posts":[{"title":"评论的使用方法","slug":"评论的使用方法","date":"2019-08-06T11:42:33.000Z","updated":"2019-08-06T12:13:13.778Z","comments":true,"path":"2019/08/06/评论的使用方法/","link":"","permalink":"http://siundiy.com/2019/08/06/评论的使用方法/","excerpt":"评论系统来自valine","text":"评论系统来自valine 1. 昵称顾名思义就是你评论之后显示的名称啦 2. 邮箱获取头像用的 请自行登录或注册Gravatar，然后修改自己的头像。（详情请咨询度娘） 评论的时候，留下在Gravatar注册时所使用的邮箱即可。 3. 链接可选项，填写后会在你的评论上自动生成一个链接（记得加 https://），效果如图： 4. 内容支持emoji与markdown 全部完成后点击发布即可！","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://siundiy.com/tags/杂项/"}]},{"title":"2019-7题解综合2——DP","slug":"2019-7-29题解综合","date":"2019-08-04T08:36:43.000Z","updated":"2019-08-06T11:18:02.751Z","comments":true,"path":"2019/08/04/2019-7-29题解综合/","link":"","permalink":"http://siundiy.com/2019/08/04/2019-7-29题解综合/","excerpt":"7.29 “简单”DP","text":"7.29 “简单”DP luogu P2467 [SDOI2010]地精部落题目传送门 题目大意一个序列符合要求，当且仅当其是一个$1 \\sim n$的排列，且每一个$a[i]$ 满足$a[i-1]\\le a[i]$且$a[i]\\ge a[i+1]$ 或者满足$a[i-1]\\ge a[i]$且$a[i]\\le a[i+1]$ 求长度为$n$的合法序列方案数 大体思路神仙题。。。。显然有以下性质： 1.当$i$与$i+1$不相邻时，交换$i$与$i+1$仍会得到一个合法的解如:$3 2 4 1 5 \\rightarrow 3 1 4 2 5$ 2.一串序列$a[i]$，$i\\in [1,n]$满足条件时，则$(i+1)-a[i]$亦满足条件如:$3 2 4 1 5 \\rightarrow 3 4 2 5 1$ 3.满足条件的序列具有对称性 如:$3 2 4 1 5 \\rightarrow 5 1 4 2 3$ 则设$dp[i][j]$表示当前为前$i$个数的排列，且首位是$j$且为山峰的方案数。 \\! \\begin{split} & 由性质1可知: \\!\\begin{cases} \\text{当$j$与$j-1$不相邻时，$dp[i][j]=dp[i][j-1]$}\\\\ \\end{cases}\\\\ & 由性质2可知: \\!\\begin{cases} \\text{首位做山峰的方案数=首位做山谷的方案数}\\\\ \\downarrow \\\\ \\text{(也就是说最后的答案是$2*\\sum_{i=1}^n dp[n][i]$)}\\\\ \\\\ \\text{当$j$与$j-1$相邻时，}\\\\ \\text{方案数即为$i-1$个数，$j-1$为首位且为山谷的方案数}\\\\ \\text{$\\downarrow$}\\\\ \\text{即$dp[i][j]=dp[i-1][(i-1+1)-(j-1)]$} \\end{cases} \\end{split}综上，$dp[i][j]=dp[i][j-1]+dp[i-1][i-j+1]$ 代码12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int n, p;long long ans;long long dp[2][4300];int main()&#123; scanf(\"%d%d\", &amp;n, &amp;p); dp[0][2] = 1; for(int i = 3; i &lt;= n; ++i)&#123; for(int j = 2; j &lt;= i; ++j)&#123; dp[i &amp; 1][j] = (dp[i &amp; 1][j - 1] + dp[(i - 1) &amp; 1][i - j + 1]) % p; &#125; &#125; for(int i = 1; i &lt;= n; ++i)&#123; ans = ans + dp[n &amp; 1][i] % p; &#125; printf(\"%lld\\n\", (ans &lt;&lt; 1) % p); return 0;&#125; luogu P2519 [HAOI2011]problem a题目传送门 题目大意一次考试共有$n$个人参加，第$i$个人说：“有$ai$个人分数比我高，$bi$个人分数比我低。”问最少有几个人没有说真话(可能有相同的分数) 大体思路先进行补集转化，目标变成求说真话的人数。有$ai$个人分数比我低，$bi$个人分数比我高，就意味着$[ai+1,n-bi-1]$是相同的数。问题转化为使$k$段区间不重叠且权值和最大。按照右端点排序之后dp即可。几点细节: 1.合法解可以有完全重合的区间，但是一段区间最多只能有区间长度个说真话的人。2.要特判$ai \\ge bi$的情况 设$f[i]$表示当前为第$i$位的区间最大值，则 f[i]=max(f[i-1],f[L[j]-1]+w[j]) (R[j]==i)代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;#define gc ch = getchar()int read()&#123; int ret = 0, f = 1; char gc; while(!isdigit(ch) &amp;&amp; (ch ^ '-'))gc; if(!(ch ^ '-'))f = -1, gc; while(isdigit(ch))&#123;ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'), gc;&#125; return ret * f;&#125;#undef gcconst int maxn = 1e5 + 10;int n;struct node&#123; int l, r; bool operator &lt; (const node &amp;a)const&#123; return r == a.r ? l &lt; a.l : r &lt; a.r; &#125;&#125;p[maxn];int w[maxn], L[maxn], R[maxn];int f[maxn];int a, b, tot = 0;int main()&#123; #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); #endif n = read(); for(int i = 1; i &lt;= n; ++i)&#123; a = read(), b = read(); // cout&lt;&lt;a&lt;&lt; \" \"&lt;&lt;b&lt;&lt;endl; p[i].l = a + 1, p[i].r = n - b; &#125; sort(p + 1, p + n + 1); for(int i = 1; i &lt;= n; ++i)&#123; if(p[i].l &gt; p[i].r)continue; // cout&lt;&lt;p[i].l&lt;&lt; \" \"&lt;&lt;p[i].r&lt;&lt;endl; if(p[i].l != p[i - 1].l || p[i].r != p[i - 1].r)tot++; // cout&lt;&lt;tot&lt;&lt;endl; w[tot] = min(w[tot] + 1, p[i].r - p[i].l + 1); L[tot] = p[i].l, R[tot] = p[i].r; &#125; // for(int i = 1; i &lt;= tot; ++i)&#123; // cout&lt;&lt;w[i]&lt;&lt; \" \"&lt;&lt;L[i]&lt;&lt; \" \"&lt;&lt;R[i]&lt;&lt;endl; // &#125; int j = 1; for(int i = 1; i &lt;= n; ++i)&#123; // int j = 1; f[i] = f[i - 1]; // cout&lt;&lt;f[i]&lt;&lt;endl; while(j &lt;= tot &amp;&amp; R[j] == i)&#123; // cout&lt;&lt;j&lt;&lt;endl; // cout&lt;&lt;L[j]&lt;&lt;endl; f[i] = max(f[i], f[L[j] - 1] + w[j]); j++; &#125; &#125; printf(\"%d\\n\", n - f[n]); return 0;&#125; CF1016C Vasya And The Mushrooms题目传送门 题目大意给定一个$2n$的方格阵，经过一个格子获得的价值为$ai$进入时间,求从左上角出发遍历一次全部格子获得的价值最大值。 大体思路很明显的一道dp题。。。稍加思考便能发现能够遍历整个方阵的方案可能是长这样的 或者是长这样的 总之就是先是一个蛇形结构，然后接一个U形结构，很明显这两个部分都是可以预处理的。 设$f[i][0/1]$表示蛇形部分进行到第$i$列，第$0/1$行的权值则 \\begin{split} &f[i][0]= \\begin{cases} \\text{f[i-1][0]+(2*(i-1))*val[i][0] (i&1==0)}\\\\ \\text{f[i][1]+(2*(i-1)+1)*val[i][0] (i&1!=0)}\\\\ \\end{cases}\\\\ &f[i][1]= \\begin{cases} \\text{f[i][0]+(2*(i-1)+1)*val[i][1] (i&1==0)}\\\\ \\text{f[i-1][1]+(2*(i-1))*val[i][1] (i&1!=0)}\\\\ \\end{cases} \\end{split}U形部分的计算方法： \\begin{split} &\\text{自左向右的部分}\\\\ &\\sum_{i=k}^n vi*[T+(i-k)]\\\\ &\\downarrow\\\\ &\\sum_{i=k}^n vi*i+\\sum_{i=k}^n vi*(T-k)\\\\ \\\\ &\\text{自右向左的部分}\\\\ &\\sum_{i=k}^n vi*[T+(n-k)+(n-k-i+1)]\\\\ &\\downarrow\\\\ &\\sum_{i=k}^n vi*(T+2*n-2*k+1)-\\sum_{i=k}^n vi*i\\\\ \\end{split}$k$为U形部分开始的位置设$g[i][0/1]$表示U形部分从0/1列， i行开始的权值，$sum[i][0/1]$表示本行距离结尾的权值和$nxt[i][0/1]$表示距离结尾的权值与列数乘积之和则 12345678if(!(i &amp; 1))&#123; g[i][1] = nxt[i][1] + (2 * (i - 1) - i) * sum[i][1]; g[i][1] += (2 * (i - 1) + 2 * n - i + 1) * sum[i][0] - nxt[i][0];&#125;else &#123; g[i][0] = nxt[i][0] + (2 * (i - 1) - i) * sum[i][0]; g[i][0] += (2 * (i - 1) + 2 * n - i + 1) * sum[i][1] - nxt[i][1];&#125; 最后的答案就是每一种合法的蛇形与U形组合取$max$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;#define gc ch = getchar()int read()&#123; int ret = 0, f = 1; char gc; while(!isdigit(ch) &amp;&amp; (ch ^ '-'))gc; if(ch == '-')f = -1, gc; while(isdigit(ch))&#123;ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'), gc;&#125; return ret * f;&#125;ll readll()&#123; ll ret = 0, f = 1; char gc; while(!isdigit(ch) &amp;&amp; (ch ^ '-'))gc; if(ch == '-')f = -1, gc; while(isdigit(ch))&#123;ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'), gc;&#125; return ret * f;&#125;#undef gcconst int maxn = 3 * 1e5 + 10;int n;ll ans;ll val[maxn][2];ll sum[maxn][2], nxt[maxn][2];ll f[maxn][2], g[maxn][2];int main()&#123; #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); #endif n = read(); for(int i = 1; i &lt;= n; ++i)&#123; val[i][0] = readll(); // cnt[i][0] = val[i][0] * i; &#125; for(int i = 1; i &lt;= n; ++i)&#123; val[i][1] = readll(); // cnt[i][1] = val[i][1] * i; &#125; for(int i = n; i &gt;= 1; --i)&#123; sum[i][0] = sum[i + 1][0] + val[i][0]; sum[i][1] = sum[i + 1][1] + val[i][1]; nxt[i][0] = nxt[i + 1][0] + val[i][0] * i; nxt[i][1] = nxt[i + 1][1] + val[i][1] * i; &#125; for(int i = 1; i &lt;= n; ++i)&#123; if(i &amp; 1)&#123; f[i][0] = f[i - 1][0] + (2 * (i - 1)) * val[i][0]; f[i][1] = f[i][0] + (2 * (i - 1) + 1) * val[i][1]; &#125; else&#123; f[i][1] = f[i - 1][1] + (2 * (i - 1)) * val[i][1]; f[i][0] = f[i][1] + (2 * (i - 1) + 1) * val[i][0]; &#125; &#125; // for(int i = 1; i &lt;= n; ++i)&#123; // cout&lt;&lt;\"sum\"&lt;&lt;sum[i][0]&lt;&lt; \" \"&lt;&lt;sum[i][1]&lt;&lt;endl; // cout&lt;&lt;\"nxt\"&lt;&lt;nxt[i][0]&lt;&lt; \" \"&lt;&lt;nxt[i][1]&lt;&lt;endl; // &#125; for(int i = 1; i &lt;= n; ++i)&#123; if(!(i &amp; 1))&#123; g[i][1] = nxt[i][1] + (2 * (i - 1) - i) * sum[i][1]; g[i][1] += (2 * (i - 1) + 2 * n - i + 1) * sum[i][0] - nxt[i][0]; &#125; else &#123; g[i][0] = nxt[i][0] + (2 * (i - 1) - i) * sum[i][0]; g[i][0] += (2 * (i - 1) + 2 * n - i + 1) * sum[i][1] - nxt[i][1]; &#125; &#125; // for(int i = 1; i &lt;= n; ++i)&#123; // cout&lt;&lt;\"!!\"&lt;&lt;f[i][0]&lt;&lt; \" \"&lt;&lt;f[i][1]&lt;&lt;endl; // cout&lt;&lt;g[i][0]&lt;&lt; \" \"&lt;&lt;g[i][1]&lt;&lt;endl; // &#125; for(int i = 0; i &lt;= n; ++i)&#123; // cout&lt;&lt;f[i][1]&lt;&lt; \" \"&lt;&lt;g[i + 1][1]&lt;&lt;endl; // cout&lt;&lt;f[i][0]&lt;&lt; \" \"&lt;&lt;g[i + 1][0]&lt;&lt;endl; if(i &amp; 1)&#123; ans = max(ans, f[i][1] + g[i + 1][1]); &#125; else &#123; ans = max(ans, f[i][0] + g[i + 1][0]); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; CF467C George and Job题目传送门 题目大意给出一组有$n$个整数的数列$p_1,p_2,…,p_n$，你需要挑出$k$组长度为$m$的数，要求这些数互不重叠，即：$[l_1,r_1],[l_2,r_2],…,l_k,r_k$ 且使选出的数和值最大 大体思路直接依照题意dp即可。设$f[i][j]$为当前在第$i$位，选了$j$个区间时的最大值，$s[i]$为以$i$为起始点的长度为$m$的权值之和 转移为：$f[i][j]=max(f[i-1][j],f[i-m][j-1]+s[i])$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;const int maxn = 5010;#define gc ch = getchar()int read()&#123; int ret = 0, f = 1;char gc; while(!isdigit(ch) &amp;&amp; (ch ^ '-'))gc; if(!(ch ^'-'))f = -1, gc; while(isdigit(ch))&#123;ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'), gc;&#125; return ret * f;&#125;long long readll()&#123; long long ret = 0, f = 1;char gc; while(!isdigit(ch) &amp;&amp; (ch ^ '-'))gc; if(!(ch ^'-'))f = -1, gc; while(isdigit(ch))&#123;ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'), gc;&#125; return ret * f;&#125;#undef gcint n, m, k;long long p[maxn];long long f[maxn][maxn];long long sum[maxn];long long s[maxn];int main()&#123; #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); #endif n = read(), m = read(), k = read(); for(int i = 1; i &lt;= n; ++i)&#123; p[i] = readll(); sum[i] = sum[i - 1] + p[i]; &#125; for(int i = m; i &lt;= n; ++i)&#123; s[i] = sum[i] - sum[i - m]; &#125; for(int i = m; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= k &amp;&amp; j * m &lt;= i; ++j)&#123; f[i][j] = f[i - 1][j]; f[i][j] = max(f[i][j], f[i - m][j - 1] + s[i]); &#125; &#125; cout&lt;&lt;f[n][k]&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://siundiy.com/tags/题解/"},{"name":"DP","slug":"DP","permalink":"http://siundiy.com/tags/DP/"}]},{"title":"2019.7题解综合1 —— 并查集与分治","slug":"2019-7题解综合","date":"2019-08-01T00:32:34.000Z","updated":"2019-08-04T08:33:26.630Z","comments":true,"path":"2019/08/01/2019-7题解综合/","link":"","permalink":"http://siundiy.com/2019/08/01/2019-7题解综合/","excerpt":"杂谈第一次在外面参加这么长时间的集训… 被各路大佬摧残…","text":"杂谈第一次在外面参加这么长时间的集训… 被各路大佬摧残… 7.25 并查集相关CF468b TWOSETS题目传送门 题目大意给出 $n$ 个各不相同的数字，将它们分别放入 $A$ 和 $B$ 两个集合中，使它们满足： 若数字 $x$ 在集合 $A$ 中，那么数字 $a-x$ 也在集合 $A$ 中；若数字 $x$ 在集合 $B$ 中，那么数字 $b-x$ 也在集合 $B$ 中。 大体思路分为以下几种情况 1.$a-x$与$b-x$有一个存在$a-x$与$b-x$都不存在$a-x$与$b-x$都存在 很显然，$a-(a-x)=x$,因此如果$a-x(b-x)$不在给定的集合中，则$x$就只能在$B(A)$中（注意顺序）。而如果$a-x$与$b-x$都不存在，便会无解。重点在于情况三，如果$a-x$与$b-x$都存在，那么$x$在哪个集合都可以，这时候决定$x$在哪里的并不是$x$本身，而是与$a-x$与$b-x$有关的数。综合以上情况，考虑用并查集维护。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt;using namespace std;#define gc ch = getchar()int read()&#123; int ret = 0, f = 1;char gc; while(!isdigit(ch) &amp;&amp; (ch ^ '-'))gc; if(ch == '-')f = -1,gc; while(isdigit(ch))&#123;ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'), gc;&#125; return ret * f;&#125;#undef gcconst int maxn = 100010;map&lt;int, int&gt;mp;int n, a, b;int x, y;int pos[maxn];int fa[maxn];int findx(int x)&#123;return fa[x] == x ? x : fa[x] = findx(fa[x]);&#125;void merge(int x, int y)&#123; int fi = findx(x), fj = findx(y); if(fi != fj) fa[fi] = fj;&#125;int main()&#123; n = read(), a = read(), b = read(); for(int i = 1; i &lt;= n; ++i)&#123; pos[i] = read(); mp[pos[i]] = i; fa[i] = i; &#125; x = n + 1, y = n + 2; fa[x] = x, fa[y] = y; for(int i = 1; i &lt;= n; ++i)&#123; // cout&lt;&lt;pos[i]&lt;&lt;\" \"&lt;&lt;a-pos[i]&lt;&lt; \" \"&lt;&lt;b-pos[i]&lt;&lt;endl; // cout&lt;&lt;\"!!\"&lt;&lt;mp[a - pos[i]]&lt;&lt; \" \"&lt;&lt;mp[b - pos[i]]&lt;&lt;endl; if(!mp[a - pos[i]])&#123; merge(i, y); // merge(mp[]) &#125; else &#123; merge(mp[a - pos[i]], i); &#125; if(!mp[b - pos[i]])&#123; merge(i, x); &#125; else &#123; merge(mp[b - pos[i]], i); &#125; // cout&lt;&lt;findx(i)&lt;&lt;endl; &#125; int x1 = findx(x), x2 = findx(y); if(x1 == x2)&#123;cout&lt;&lt;\"NO\"&lt;&lt;endl;return 0;&#125; cout&lt;&lt;\"YES\"&lt;&lt;endl; for(int i = 1; i &lt;= n; ++i)&#123; // cout&lt;&lt;findx(i)&lt;&lt;endl; if(findx(i) == x1)cout&lt;&lt;\"0\"&lt;&lt; \" \"; else cout&lt;&lt;\"1\"&lt;&lt;\" \"; &#125;&#125; luogu P3295 [SCOI2016]萌萌哒题目传送门 题目大意给定一个序列$S$的长度为$n$以及$m$对区间$(l_1,r_1,l_2,r_2)$知每一对区间中的每个数都相同，求最终序列的方案数。 大体思路有$m$对区间，每对区间中的每个数都相同。因为最终要求的是方案数，不用考虑单独的一种方案，考虑使用并查集维护，将每一对区间中的每一对数塞到一个并查集内部，最终答案就是$10^x＊９$($ｘ$为并查集的总数)。此时合并的复杂度最差为$O(n^2)$，但是查询的复杂度仅为$O(n)$，无法接受。然后通过细（看）致（了）思（题）考（解），发现可以使用类似ST表的倍增进行解决。设$id[j][i]$表示以$i$为左端点，长度为$2^j$的区间的编号，在合并时，直接合并代表两段区间的$(logn)$个区间即可。查询时，因为查询的是原始的$n$个节点，所以需要针对一段区间，将其合并下放。（实现方式与st表类似）。此时合并$O(logn)$，查询$O(logn)$，可以通过。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;const int maxn = 100010;const ll mod = 1e9 + 7;int n, m;int tot, l1, r1, l2, r2;int id[30][maxn], num[maxn * 30];int fa[maxn * 30], h[maxn * 30];int bin[30];int findx(int x)&#123;return fa[x] == x ? x : fa[x] = findx(fa[x]);&#125;void merge(int x, int y)&#123; int fi = findx(x), fj = findx(y); if(h[fi] &gt; h[fj])&#123; swap(fi, fj); &#125; if(h[fi] == h[fj])h[fj] ++; fa[fi] = fj;&#125;ll ksm(ll now, ll a)&#123; ll res = 1, base = now; while(a)&#123; if(a &amp; 1) res = (1ll * res * base) % mod; base = (1ll * base * base) % mod; a &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); #endif scanf(\"%d%d\", &amp;n, &amp;m); bin[0] = 1; for(int p = 1; p &lt;= 20; ++p)&#123; bin[p] = (bin[p - 1] &lt;&lt; 1) % mod; &#125; for(int j = 0; j &lt;= 20; ++j)&#123; for(int i = 1; i &lt;= n; ++i)&#123; id[j][i] = ++tot, num[tot] = i; fa[tot] = tot, h[tot] = 1; &#125; &#125; for(int i = 1; i &lt;= m; ++i)&#123; scanf(\"%d%d%d%d\", &amp;l1, &amp;r1, &amp;l2, &amp;r2); for(int j = 20; j &gt;= 0; --j)&#123; if(l1 + bin[j] - 1 &lt;= r1)&#123; merge(id[j][l1], id[j][l2]); l1 += bin[j], l2 += bin[j]; &#125; &#125; &#125; // cout&lt;&lt;1&lt;&lt;endl; for(int j = 20; j; --j)&#123; // cout&lt;&lt;j&lt;&lt; \" \"; for(int i = 1; i + bin[j] - 1 &lt;= n; ++i)&#123; int x = findx(id[j][i]), a = num[x]; merge(id[j - 1][a], id[j - 1][i]); merge(id[j - 1][a + bin[j - 1]], id[j - 1][i + bin[j - 1]]); // cout&lt;&lt;\"j\"&lt;&lt;j&lt;&lt; \" \"&lt;&lt;i&lt;&lt;endl; &#125; &#125; // cout&lt;&lt;1&lt;&lt;endl; ll cnt = 0; for(int i = 1; i &lt;= n; ++i)&#123; if(findx(id[0][i]) == id[0][i])cnt++; &#125; // cout&lt;&lt;cnt&lt;&lt;endl; cout&lt;&lt;(9ll * ksm(10, cnt - 1)) % mod; return 0;&#125; 7.25 分治相关luogu P1429 平面最近点对（加强版）题目传送门 题目大意平面上有$n$个点$(2≤n≤200000)$，求距离最近的点对 主要思路考虑直接枚举$n$个点，$O(n^2)$显然不可做。。。。考虑分治，将平面沿$x$坐标的中位数裁开，这样要求的解被分成三类。 1.在左侧的解2.在右侧的解3.横跨分割线的解 解1与解2分开递归计算即可，重点考虑解3如何处理。然后发现了一种优美的性质。对于一个点来说，其要想和横跨分治边界的另一个点更新最优解，最多只有$6$个点符合要求。设左侧的递归答案为$d1$，右侧的递归答案为$d2$，则当前最优解为$\\delta=min(d1,d2)$,如果要想使$dis(x,y) &lt; \\delta$，很明显另一个点的取值只能是一个$[\\delta,2\\delta]$的矩形，又因为$\\delta=min(d1,d2)$，则右侧每两个点之间的距离$dis\\le\\delta$，也就是说，最多只能有$6$个点被选择。先按$x$轴第一关键字，$y$轴第二关键字排序,每一层分治的复杂度为$O(6n)$，总复杂度$O(logn)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;using namespace std;const int maxn = 200010;const int inf = 2 &lt;&lt; 20;int n;struct node &#123; double x, y;&#125;a[maxn];int tmp[maxn];bool cmp1(node &amp;a, node &amp;b)&#123; return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;&#125;bool cmp2(int &amp;i, int &amp;j)&#123; return a[i].y &lt; a[j].y;&#125;double dist(int i, int j)&#123; return sqrt((a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y));&#125;double merge(int l, int r)&#123; double d = inf; if(l == r)return d; if(l + 1 == r)return dist(l, r); int mid = (l + r) &gt;&gt; 1; double d1 = merge(l, mid); double d2 = merge(mid + 1, r); d = min(d1, d2); int cnt = 0; for(int i = l; i &lt;= r; ++i)&#123; if(fabs(a[mid].x - a[i].x) &lt; d)&#123; tmp[++cnt] = i; &#125; &#125; sort(tmp + 1, tmp + cnt + 1, cmp2); double d3; for(int i = 1; i &lt;= cnt; ++i)&#123; for(int j = i + 1; j &lt;= cnt &amp;&amp; fabs(a[tmp[j]].y - a[tmp[i]].y) &lt; d; j++)&#123; d3 = dist(tmp[i], tmp[j]); if(d &gt; d3)d = d3; &#125; &#125; return d;&#125;int main()&#123; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; ++i)scanf(\"%lf%lf\", &amp;a[i].x, &amp;a[i].y); sort(a + 1, a + n + 1, cmp1); printf(\"%.4lf\", merge(1, n)); return 0;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://siundiy.com/tags/题解/"}]},{"title":"新式骗分——模拟退火","slug":"新式骗分——模拟退火","date":"2019-06-13T16:22:02.000Z","updated":"2019-07-29T12:27:56.392Z","comments":true,"path":"2019/06/14/新式骗分——模拟退火/","link":"","permalink":"http://siundiy.com/2019/06/14/新式骗分——模拟退火/","excerpt":"博客咕咕咕的时间有点长(似乎是太长了) 今天写一下模拟退火吧。。。发现了骗分的新大陆","text":"博客咕咕咕的时间有点长(似乎是太长了) 今天写一下模拟退火吧。。。发现了骗分的新大陆 一：背景模拟退火解决的是一种什么样的问题呢？ 模拟退火算法（Simulate Anneal，SA）是一种通用概率演算法， 用来在一个大的搜寻空间内找寻命题的最优解。 模拟退火是由S.Kirkpatrick, C.D.Gelatt和&gt;M.P.Vecchi在1983年所发明的。V.Čern&yacute;在1985年也独立发明此演算法。模&gt;拟退火算法是解决TSP问题的有效方法之一。—— 来自百度百科 照例引用百度百科。 其实模拟退火就是一种解决问题的普遍方法。 二：爬山算法及其优化 针对一个求最值的问题，我们可以采用一种贪心的方法，被称作“爬山算法”。爬山算法指的就是每一步都将当前节点的值与其邻居节点比较，如果有更优值就取，否则就维持当前的解。很明显，这个算法可以找到一个局部最优解。但是其有一个致命的缺陷，那就是只能找到局部最优解，但是并不能保证找到的解是一个全局最优解。 就比如说上面这个图，当我们在D点出发，使用爬山算法，即可到达B点，很明显这既是局部最优解，又是全局最优解。但是如果从C点或E点出发，我们最后会到达A点，（然后愉快的WA） 这种做法很明显是不行的，那么怎么使其变的正确 或者说大约正确呢？ 上文提到的三位大佬想出来了一个绝妙的解决方案： 使用随机算法，使得每一次搜索到比当前解差的解时，都有一定概率接受这个解。但是光随机也是不行的，所以随着循环次数的增加，会不断降低接受更劣解的概率。这就是模拟退火的主要思想。 三：具体实现 先定义一下变量及数组 t: 温度 决定了接受更劣解的概率 与down一起决定了退火的时长 更高的初始温度意味着更精确的答案， 但也意味着需要更多的时间down: 每一次循环降低t的系数，一般是 0.9 ~ 1 的一个实数delta: 当前解与最优解的差now_w: 目前得到的最优解ew：当前解 步骤：1.透过最优解计算出当前解。2.如果获得了更优解 直接接受3.更劣解有概率接受 12345678910111213141516171819 void sa()&#123; double t = 3000; while(t &gt; 1e-15)&#123; double ex = ans_x + (rand() * 2 - RAND_MAX) * t; double ey = ans_y + (rand() * 2 - RAND_MAX) * t; double ew = get_eng(ex, ey);//构造解的函数 double delta = ew - ans_w; if(delta &lt; 0)&#123; ans_x = ex; ans_y = ey; ans_w = ew; &#125; else if(exp(-delta / t) * RAND_MAX &gt; rand())&#123; ans_x = ex; ans_y = ey; &#125; t *= down; &#125;&#125; 来自luoguP1337 [JSOI2004]平衡点 / 吊打XXX 值得注意的几个点： (rand() 2 - RAND_MAX) t : 求新解的方法exp(-delta / t) * RAND_MAX &gt; rand() : 来自前人的玄学判断 模拟退火流程图","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://siundiy.com/tags/算法/"}]},{"title":"可爱的数据结构——线段树","slug":"可爱的数据结构———线段树","date":"2019-03-30T00:03:19.000Z","updated":"2019-08-06T11:38:31.178Z","comments":true,"path":"2019/03/30/可爱的数据结构———线段树/","link":"","permalink":"http://siundiy.com/2019/03/30/可爱的数据结构———线段树/","excerpt":"可爱的数据结构——线段树前言什么是数据结构呢？ 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关 —-来自百度百科","text":"可爱的数据结构——线段树前言什么是数据结构呢？ 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关 —-来自百度百科简单来说，数据结构就是通过合理的方式在计算机中存储数据，来达到修改、查询的目的。 几个例子（纯个人看法） 朴素的数据结构 数组（-_-） 链表 队列 栈 看起来高端一些的数据结构 矩阵 哈希表（hash） 堆 树状数组 更高级的数据结构 线段树 各种平衡树 主席树 什么是线段树呢？ 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 —-依然来自百度百科 换句话说，就是把一个区间变成一个多层的树形结构，以一种二分与递归的思想实现高效的区间操作 一个例子写一个数据结构，要求支持在O(logn)的时间复杂度内支持区间加与区间和。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://siundiy.com/tags/数据结构/"},{"name":"线段树","slug":"线段树","permalink":"http://siundiy.com/tags/线段树/"}]},{"title":"网络流初识———EK","slug":"网络流初识——EK","date":"2018-12-16T04:23:25.164Z","updated":"2019-03-28T09:12:20.968Z","comments":true,"path":"2018/12/16/网络流初识——EK/","link":"","permalink":"http://siundiy.com/2018/12/16/网络流初识——EK/","excerpt":"前言当初刚开始学OI的时候，对各种奇怪的中高级算法抱有极大的兴趣（结果自然是看不懂-_-），网络流则是排在前列的几大算法之一（话说我是如何在连建图和SPFA都搞不明白的情况下看进去的…）。 如今过了一年（技术还是没有什么长进，该不会的还是不会），重新看了一篇网络流与费用流，似乎。。。有那么一点理解了，谨以此文，来表达我对网络流的一点看法。 什么是网络流？“网络流(network-flows)是一种类比水流的解决问题方法，与线性规划密切相关。”（来自百度百科） 举个例子，从某地要向某地输水，中间有许多粗细不同的管子，网络流算法解决的就是利用这些管子怎样使单位时间总输送量最大化的问题。","text":"前言当初刚开始学OI的时候，对各种奇怪的中高级算法抱有极大的兴趣（结果自然是看不懂-_-），网络流则是排在前列的几大算法之一（话说我是如何在连建图和SPFA都搞不明白的情况下看进去的…）。 如今过了一年（技术还是没有什么长进，该不会的还是不会），重新看了一篇网络流与费用流，似乎。。。有那么一点理解了，谨以此文，来表达我对网络流的一点看法。 什么是网络流？“网络流(network-flows)是一种类比水流的解决问题方法，与线性规划密切相关。”（来自百度百科） 举个例子，从某地要向某地输水，中间有许多粗细不同的管子，网络流算法解决的就是利用这些管子怎样使单位时间总输送量最大化的问题。 如何解决网络流问题？前置知识会建图，会dfs、bfs（似乎只需要这些。。。） 在开始之前…我们先来明晰几个概念： 点的属性： 源点(s): 一切的开始，入度为0 汇点(t): 一切的结束，出度为0 边的属性： 首先很明显图应该是DAG 流量(flow)：每条边能通过的最大值 如何建图？先不负责任的提出解决方案：对于每一条有向边，建一条与之方向相反（出入点相反），流量为0的边。 为什么？ 我们先来明确一下网络流的工作原理： 每一次搜索结束后，便会找到一条从源点到汇点的路径（这条路径叫增广路），且该路径上的边的流量均大于0，通过这条路可以增加的流量便是这条路径中的最小流量（自行理解一下）。然后在每次搜索结束时，将这条路径上的边的流量减去可以增加的流量。重复此过程直到找不出路径为止。 这种看起来就像是贪心的算法很明显是错的… 你搜索到的流量会与你搜索的路径的顺序有关，这怎么行！ 所以在建图时，要采用上文所述的方式，建一条反向边，并且在搜索完毕后减去增加流量的同时，在反向边加上增加的流量，这样在下一次搜索增广路时可以沿着反向边把流量回退，从而实现发现真正意义上的最大流的目的。 上代码！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 51000;const int inf = 1e9 + 7;int n;int p, m, f, u, v;int s, t;int num[maxn];struct edge&#123; int nt, to, flow, val; inline void set(int n, int t, int f)&#123; nt = n, to = t, flow = f; &#125;&#125;e[maxn &lt;&lt; 2];int h[maxn], c[maxn], tot = -1;void adde(int a, int b, int c)&#123;e[++tot].set(h[a], b, c), h[a] = tot; e[++tot].set(h[b], a, 0), h[b] = tot;&#125;queue &lt;int&gt; q;int dis[maxn], vis[maxn], pre[maxn], last[maxn], flow[maxn]; //存路径和更新的流量bool bfs(int s, int t)&#123; for(int i = 0; i &lt;= n; ++i)pre[i] = -1, vis[i] = 0; memset(last, -1, sizeof(last)); while(!q.empty())q.pop(); q.push(s); pre[s] = inf; flow[s] = inf; vis[s] = 1; while(!q.empty())&#123; int now = q.front(); q.pop(); for(int i = h[now]; i != -1; i = e[i].nt)&#123; int nex = e[i].to; if(e[i].flow &gt; 0 &amp;&amp; vis[nex] == 0)&#123; pre[nex] = now; last[nex] = i; if(e[i].flow &lt; flow[now]) flow[nex] = e[i].flow; else flow[nex] = flow[now]; if(!vis[nex])&#123; vis[nex] = 1; q.push(nex); &#125; &#125; &#125; &#125; return pre[t] != -1;&#125;int maxflow = 0;void ek(int s, int t)&#123; while(bfs(s, t))&#123; maxflow += flow[t]; for(int i = t; i != s; i = pre[i])&#123; e[last[i]].flow -= flow[t]; e[last[i] ^ 1].flow += flow[t]; &#125; &#125;&#125;int main()&#123; int s, t; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;s, &amp;t); for(int i = 0; i &lt;= n; ++i) h[i] = -1; int u, v, f; for(int i = 1; i &lt;= m; ++i)&#123; scanf(\"%d%d%d\", &amp;u,&amp;v,&amp;f); adde(u, v, f); &#125; ek(s, t); cout&lt;&lt;maxflow&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://siundiy.com/tags/网络流/"}]}]}